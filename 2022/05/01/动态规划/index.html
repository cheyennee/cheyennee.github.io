<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>动态规划 | Cheyennee</title><meta name="keywords" content="blog"><meta name="author" content="Cheyennee,714851125@qq.com"><meta name="copyright" content="Cheyennee"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录与动态规划相关的算法">
<meta property="og:type" content="article">
<meta property="og:title" content="动态规划">
<meta property="og:url" content="http://cheyennee.github.io/2022/05/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="Cheyennee">
<meta property="og:description" content="记录与动态规划相关的算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/dp/cover.jpg">
<meta property="article:published_time" content="2022-05-01T06:49:18.000Z">
<meta property="article:modified_time" content="2022-12-11T14:18:15.231Z">
<meta property="article:author" content="Cheyennee">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/dp/cover.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://cheyennee.github.io/2022/05/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '动态规划',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-11 22:18:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cheyennee</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">动态规划</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-01T06:49:18.000Z" title="发表于 2022-05-01 14:49:18">2022-05-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-11T14:18:15.231Z" title="更新于 2022-12-11 22:18:15">2022-12-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="动态规划"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>​		动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的。</p>
<p>​		<strong>做动规的题目，写代码之前一定要把状态转移在dp数组上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</strong>。</p>
<p>动态规划的步骤：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1 给你n ，请计算 F(n) 。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) = F(1) + F(0) = 1 + 0 = 1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) = F(2) + F(1) = 1 + 1 = 2</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) = F(3) + F(2) = 2 + 1 = 3</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p><strong>题目已经把递推公式直接给我们了：状态转移方程 dp[i] &#x3D; dp[i - 1] + dp[i - 2];</strong></p>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<p>​	dp[0] &#x3D; 0; dp[1] &#x3D; 1;</p>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>从递归公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="keyword">function</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span><br><span class="line">注意：给定 n 是一个正整数。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1 阶 + 1 阶</span><br><span class="line">2 阶</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1 阶 + 1 阶 + 1 阶</span><br><span class="line">1 阶 + 2 阶</span><br><span class="line">2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>dp[i] &#x3D; dp[i-1]+dp[i-2]</p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="keyword">function</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</span><br><span class="line">请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：cost = [10, 15, 20] </span><br><span class="line">输出：15 </span><br><span class="line">解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 输出：6 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>dp[i] &#x3D; Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])</p>
<p>dp[0]&#x3D;0, dp[1]&#x3D;0;</p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="keyword">function</span>(<span class="params">cost</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=cost.<span class="property">length</span>;i++)</span><br><span class="line">        dp[i] = <span class="title class_">Math</span>.<span class="title function_">min</span>(dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>], dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[cost.<span class="property">length</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h3><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</span><br><span class="line">机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</span><br><span class="line">问总共有多少条不同的路径？</span><br></pre></td></tr></table></figure>

<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：m = 2, n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释： 从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">向下 -&gt; 向右 -&gt; 向右</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>

<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。</p>
<p>按照动规五部曲来分析：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<p>dp[i] [j]：表示从（0 ，0）出发，到(i, j) 有dp[i] [j]条不同的路径。</p>
<ol start="2">
<li>确定递推公式</li>
</ol>
<p>想要求dp[i] [j]，只能有两个方向来推导出来，即dp[i - 1] [j] 和 dp[i] [j - 1]。</p>
<p>此时在回顾一下 dp[i - 1] [j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i] [j - 1]同理。</p>
<p>那么很自然，dp[i] [j] &#x3D; dp[i - 1] [j] + dp[i] [j - 1]，因为dp[i] [j]只有这两个方向过来。</p>
<ol start="3">
<li>dp数组的初始化</li>
</ol>
<p>如何初始化呢，首先dp[i] [0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0] [j]也同理。</p>
<p>所以初始化代码为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">for (int j = 0; j &lt; n; j++) dp[0][j] = 1;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>这里要看一下递推公式dp[i] [j] &#x3D; dp[i - 1] [j] + dp[i] [j - 1]，dp[i] [j]都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。</p>
<p>这样就可以保证推导dp[i] [j]的时候，dp[i - 1] [j] 和 dp[i] [j - 1]一定是有数值的。</p>
<ol start="5">
<li>举例推导dp数组</li>
</ol>
<h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="keyword">function</span>(<span class="params">m, n</span>)&#123;</span><br><span class="line">    <span class="comment">// 创建数组与dp初始化同步进行</span></span><br><span class="line">    <span class="comment">// 数组初始值为1</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="矩阵的最小路径和"><a href="#矩阵的最小路径和" class="headerlink" title="矩阵的最小路径和"></a>矩阵的最小路径和</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]</span><br><span class="line">返回值：12</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">minPathSum</span>(<span class="params"> matrix </span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> row = matrix.<span class="property">length</span>, col = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(row).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(col));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 初始化第一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;col;i++)</span><br><span class="line">        dp[<span class="number">0</span>][i]=dp[<span class="number">0</span>][i-<span class="number">1</span>]+matrix[<span class="number">0</span>][i];</span><br><span class="line">    <span class="comment">// 初始化第一列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;row;i++)</span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]+matrix[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;row;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;col;j++)</span><br><span class="line">            dp[i][j]=<span class="title class_">Math</span>.<span class="title function_">min</span>(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+matrix[i][j];</span><br><span class="line">    <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="不同路径II"><a href="#不同路径II" class="headerlink" title="不同路径II"></a>不同路径II</h3><h4 id="描述：-1"><a href="#描述：-1" class="headerlink" title="描述："></a>描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</span><br><span class="line">机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</span><br><span class="line"></span><br><span class="line">现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</span><br><span class="line">网格中的障碍物和空位置分别用 1 和 0 来表示。</span><br></pre></td></tr></table></figure>

<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：2 解释：</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>

<h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>​		(i, j)如果就是障碍的话应该就保持初始状态（初始状态为0）。</p>
<p>​		这个题的易错点有两个：</p>
<ul>
<li>设置初始值的时候，行列中只要有任意一个是障碍物，那这个障碍物后续的格子都无法到达。且数组初始值为0。</li>
<li>dp的时候，如果碰到障碍物那么当前格子就应该设置为0，否则使用公式</li>
</ul>
<h4 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="keyword">function</span>(<span class="params">obstacleGrid</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> m = obstacleGrid.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> n = obstacleGrid[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// for循环判断这里简直是太妙了！！！</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;m&amp;&amp;obstacleGrid[i][<span class="number">0</span>]===<span class="number">0</span>;i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n&amp;&amp;obstacleGrid[<span class="number">0</span>][i]===<span class="number">0</span>;i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j]===<span class="number">0</span>)</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</span><br><span class="line">说明: 你可以假设 n 不小于 2 且不大于 58。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>dp[i]：拆分数字i，可以得到的最大乘积为dp[i]。</p>
<p>有两种渠道得到dp[i]。一个是j * (i - j) 直接相乘。一个是j * dp[i - j]，相当于是拆分(i - j)。</p>
<p><strong>dp[i] &#x3D; max(dp[i], max((i - j) * j, dp[i - j] * j));</strong></p>
<p>在取最大值的时候，为什么还要比较dp[i]呢？</p>
<p>因为在j循环中，每次dp[i]都会改变，需要记录dp[i]的最大值。</p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intergerBreak = <span class="keyword">function</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i], (i-j)*j, j*dp[i-j]);</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/dp/pic1.png" alt="示例" style="zoom:80%;">

<p>思路：</p>
<p>**dp[i] ： 1到i节点组成的二叉搜索树的个数为dp[i]**。</p>
<p>dp[i] +&#x3D; dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</p>
<p>dp[i] +&#x3D; dp[j - 1] * dp[i - j]; <strong>j-1 为以j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</span><br><span class="line">元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</span><br><span class="line">元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</span><br><span class="line">元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numTrees = <span class="keyword">function</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="comment">// 此处j可以等于i，因为有子树有0个元素的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            dp[i]+=dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="背包问题基础"><a href="#背包问题基础" class="headerlink" title="背包问题基础"></a>背包问题基础</h3><p>只需要掌握01背包和完全背包即可</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/dp/pic2.png" alt="背包问题分类">



<h3 id="01背包问题—二维数组"><a href="#01背包问题—二维数组" class="headerlink" title="01背包问题—二维数组"></a>01背包问题—二维数组</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p><strong>dp[i] [j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testWeightBagProblem = <span class="keyword">function</span>(<span class="params">weight, value, size</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> len = weight.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(len).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(size+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=weight[<span class="number">0</span>];i&lt;=size;i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = value[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;=size;j++)</span><br><span class="line">            <span class="keyword">if</span>(j&lt;weight[i])</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-weight[i]]+value[i]);</span><br><span class="line">    <span class="keyword">return</span> dp[len-<span class="number">1</span>][size];        </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h3 id="01背包问题—一维数组"><a href="#01背包问题—一维数组" class="headerlink" title="01背包问题—一维数组"></a>01背包问题—一维数组</h3><p>需要满足的条件是上一层可以重复利用，直接拷贝到当前层</p>
<h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p>遍历顺序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; weight.<span class="title function_">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(int j = bagWeight; j &gt;= weight[i]; j--) &#123; </span><br><span class="line">        <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="title function_">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。<strong>倒序遍历是为了保证物品i只被放入一次！</strong>。但如果一旦正序遍历了，那么物品0就会被重复加入多次！从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p>
<p>​		<strong>代码中不可以先遍历背包容量嵌套遍历物品。</strong>因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。</p>
<h4 id="解法：-2"><a href="#解法：-2" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testWeightBagProblem = <span class="keyword">function</span>(<span class="params">weight, value, size</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> len = weight.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(size+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=size;j&gt;=weight[i];j--)</span><br><span class="line">            <span class="comment">// 因为一维数组的解法是基于覆盖的思路，所以max里面这个dp[j]实际就是上一轮的结果</span></span><br><span class="line">            dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], value[i]+dp[j-weight[i]]);</span><br><span class="line">    <span class="keyword">return</span> dp[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><h4 id="描述：-2"><a href="#描述：-2" class="headerlink" title="描述："></a>描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</span><br><span class="line">注意: 每个数组中的元素不会超过 100,数组的大小不会超过 200</span><br></pre></td></tr></table></figure>

<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1: </span><br><span class="line">输入: [1, 5, 11, 5] </span><br><span class="line">输出: true </span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br><span class="line"></span><br><span class="line">示例 2: </span><br><span class="line">输入: [1, 2, 3, 5] </span><br><span class="line">输出: false </span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure>

<h4 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h4><p>​		元素只能使用一次，故是01背包问题。</p>
<p><strong>只有确定了如下四点，才能把01背包问题套到本题上来。</strong></p>
<ul>
<li>背包的体积为sum &#x2F; 2</li>
<li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li>
<li>背包如果正好装满，说明找到了总和为 sum &#x2F; 2 的子集。</li>
<li>背包中每一个元素是不可重复放入。</li>
</ul>
<p>​		本题中，**dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]**。递推公式：dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);</p>
<p>​		如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。</p>
<h4 id="解法：-3"><a href="#解法：-3" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canPartition = <span class="keyword">function</span>(<span class="params">nums</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> sum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b);</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(sum/<span class="number">2</span>+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果是奇数则不可能分成两个相等的子集</span></span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">2</span>===<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=sum/<span class="number">2</span>;j&gt;=nums[i];j--)</span><br><span class="line">            dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j-nums[i]]+nums[i]);</span><br><span class="line">    <span class="keyword">return</span> dp[sum/<span class="number">2</span>]===sum/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h3><h4 id="描述：-3"><a href="#描述：-3" class="headerlink" title="描述："></a>描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">有一堆石头，每块石头的重量都是正整数。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</span><br><span class="line">如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= stones.length &lt;= 30</span><br><span class="line">1 &lt;= stones[i] &lt;= 1000</span><br></pre></td></tr></table></figure>

<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,4,1,8,1] </span><br><span class="line">输出：1 </span><br><span class="line">解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</span><br></pre></td></tr></table></figure>

<h4 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h4><p>​		本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，<strong>这样就化解成01背包问题了</strong>。</p>
<p>​		<strong>dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背dp[j]这么重的石头</strong>。</p>
<p>​		<strong>dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p>
<p>​		因为提示中给出1 &lt;&#x3D; stones.length &lt;&#x3D; 30，1 &lt;&#x3D; stones[i] &lt;&#x3D; 1000，所以最大重量就是30 * 1000 。而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/dp/pic3.png" alt="模拟过程" style="zoom:80%;">

<h4 id="解法：-4"><a href="#解法：-4" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastStoneWeightII = <span class="keyword">function</span>(<span class="params">stones</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = stones.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a+b);</span><br><span class="line">    <span class="keyword">let</span> target = <span class="title class_">Math</span>.<span class="title function_">floor</span>(sum/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(target+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;stones.<span class="property">length</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=target;j&gt;=stones[i];j--)</span><br><span class="line">            dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j-stones[i]]+stones[i]);</span><br><span class="line">    <span class="comment">// dp[target]表示这一部分能装的最大重量</span></span><br><span class="line">    <span class="comment">// 那么sum-dp[target]就是另一部分的重量</span></span><br><span class="line">    <span class="keyword">return</span> (sum-dp[target])-dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><h4 id="描述：-4"><a href="#描述：-4" class="headerlink" title="描述："></a>描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个非负整数数组，a1, a2, ..., an, 和一个目标数S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</span><br><span class="line">返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</span><br></pre></td></tr></table></figure>

<h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure>

<h4 id="思路：-5"><a href="#思路：-5" class="headerlink" title="思路："></a>思路：</h4><p>​		结果为target，那么就一定有 left组合 - right组合 &#x3D; target。left + right等于sum，而sum是固定的。于是有： left - (sum - left) &#x3D; target -&gt; left &#x3D; (target + sum)&#x2F;2 。target是固定的，sum是固定的，left就可以求出来。</p>
<p>​		(S + sum) &#x2F; 2&#x3D;&#x3D;&#x3D;1时无解。S的绝对值已经大于sum时也无解。</p>
<p>​		<strong>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</strong>。不考虑nums[i]的情况下，填满容量为j的背包，有dp[j]种方法。那么考虑nums[i]的话（只要搞到nums[i]），凑成dp[j]就有dp[j - nums[i]] 种方法。</p>
<p>​		dp[j]有多少方法呢，也就是把所有的 dp[j - nums[i]] 累加起来。所以求组合类问题的公式，都是类似这种：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></table></figure>

<p>​		dp[0] &#x3D; 1，理论上也很好解释，装满容量为0的背包，有1种方法，就是装0件物品。</p>
<h4 id="解法：-5"><a href="#解法：-5" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findTargetSumWays = <span class="keyword">function</span>(<span class="params">nums, target</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> sum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>)=&gt;</span>a+b);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(target)&gt;sum)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((target+sum)%<span class="number">2</span>===<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> halfSum = (sum+target)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(halfSum+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=halfSum;j&gt;=nums[i];j--)</span><br><span class="line">            dp[j] += dp[j-nums[i]];</span><br><span class="line">    <span class="keyword">return</span> dp[halfSum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给你一个二进制字符串数组 strs 和两个整数 m 和 n 。请你找出并返回 strs 的最大子集的大小，该子集中最多有 m 个 0 和 n 个 1 。</span><br><span class="line">如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3 输出：4</span><br><span class="line">解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。 其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span><br><span class="line"></span><br><span class="line">示例 2： </span><br><span class="line">输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1 </span><br><span class="line">输出：2 </span><br><span class="line">解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>​		<strong>strs 数组里的元素就是物品，每个物品都是一个！而m 和 n相当于是一个背包，两个维度的背包</strong>。	</p>
<p>​		<strong>dp[i] [j]：最多有i个0和j个1的strs的最大子集的大小为dp[i] [j]。</strong></p>
<p>​		dp[i] [j] &#x3D; max(dp[i] [j], dp[i - zeroNum] [j - oneNum] + 1);</p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMaxForm = <span class="keyword">function</span>(<span class="params">strs, m, n</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m+<span class="number">1</span>).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> numOfZeros, numOfOnes;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> str <span class="keyword">of</span> strs)&#123;</span><br><span class="line">        numOfOnes = <span class="number">0</span>;</span><br><span class="line">        numOfZeros = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> str)</span><br><span class="line">            <span class="keyword">if</span>(c===<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                numOfZeros++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                numOfOnes++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=m;i&gt;=numOfZeros;i--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j=n;j&gt;=numOfOnes;j--)</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i][j], dp[i-numOfZeros][j-numOfOnes]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>​		<strong>完全背包和01背包问题不同的地方在于，每种物品有无限件</strong>。解题的时候，01背包和完全背包的不同体现在遍历顺序上。01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。而完全背包的物品是可以添加多次的，所以要从小到大去遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; </span><br><span class="line">        <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。<strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓！</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">completePack</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> weight = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> value = [<span class="number">15</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line">    <span class="keyword">let</span> bagWeight = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(bagWeight+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;weight.<span class="property">length</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=weight[i];j&lt;=bagWeight;j++)</span><br><span class="line">            dp[j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j-weight[i]]+value[i]);</span><br><span class="line">    <span class="keyword">return</span> dp[weight.<span class="property">length</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		先遍历物品，再遍历背包可以用于计算组合数。组合数：{1, 5}，但不会出现{5, 1}的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		先遍历背包，再遍历物品可以用于计算排列数。排列数：{1，5}， {5，1}</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: amount = 5, coins = [1, 2, 5] </span><br><span class="line">输出: 4 </span><br><span class="line">解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1</span><br><span class="line"></span><br><span class="line">示例 2: </span><br><span class="line">输入: amount = 3, coins = [2] </span><br><span class="line">输出: 0 </span><br><span class="line">解释: 只用面额2的硬币不能凑成总金额3。</span><br><span class="line"></span><br><span class="line">示例 3: </span><br><span class="line">输入: amount = 10, coins = [10] </span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> change = <span class="keyword">function</span>(<span class="params">amount, coins</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(amount+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;coins.<span class="property">length</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=coins[i];j&lt;=amount;j++)</span><br><span class="line">            dp[j]+=dp[j-coins[i]];</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a>组合总和IV</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1, 2, 3] target = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：(1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1)请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum4 = <span class="keyword">function</span>(<span class="params">nums, target</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(target+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=target;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;nums.<span class="property">length</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=nums[j])</span><br><span class="line">                dp[i] += dp[i-nums[j]];</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="爬楼梯升级版"><a href="#爬楼梯升级版" class="headerlink" title="爬楼梯升级版"></a>爬楼梯升级版</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span><br><span class="line">每次你可以爬 1 、2 ...m个台阶。你有多少种不同的方法可以爬到楼顶呢？</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>​		1阶，2阶，…. m阶就是物品，楼顶就是背包。每一阶可以重复使用，例如跳了1阶，还可以继续跳1阶。问跳到楼顶有几种方法其实就是问装满背包有几种方法。<strong>这就是一个完全背包问题了！</strong></p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> climb = <span class="keyword">function</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> m = <span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=j)</span><br><span class="line">                dp[i]+=dp[i-j];</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><p>描述：</p>
<p>​		给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的<strong>最少的硬币个数</strong>。如果没有任何一种硬币组合能组成总金额，返回 -1。你可以认为<strong>每种硬币的数量是无限</strong>的。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1： </span><br><span class="line">输入：coins = [1, 2, 5], amount = 11 </span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br><span class="line"></span><br><span class="line">示例 2： </span><br><span class="line">输入：coins = [2], amount = 3 </span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">示例 3： </span><br><span class="line">输入：coins = [1], amount = 0 </span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">示例 4： </span><br><span class="line">输入：coins = [1], amount = 1 </span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 5： </span><br><span class="line">输入：coins = [1], amount = 2 </span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>​		<strong>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</strong></p>
<p>​		<strong>dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</strong></p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coinChange = <span class="keyword">function</span>(<span class="params">coins, amount</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!amount)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(amount+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="title class_">Infinity</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;coins.<span class="property">length</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=coins[i];j&lt;=amount;j++)</span><br><span class="line">            dp[j]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[amount]===<span class="title class_">Infinity</span>?-<span class="number">1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</span><br><span class="line">给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</span><br><span class="line">完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1： </span><br><span class="line">输入：n = 12 </span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br><span class="line"></span><br><span class="line">示例 2： </span><br><span class="line">输入：n = 13 </span><br><span class="line">输出：2 </span><br><span class="line">解释：13 = 4 + 9</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>​		<strong>dp[j]：和为j的完全平方数的最少数量为dp[j]</strong></p>
<p>​		<strong>dp[j] &#x3D; min(dp[j - i * i] + 1, dp[j]);</strong></p>
<p>​		初始化：dp[0]&#x3D;0(凑数)，非0下标为Infinity</p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numSquares1 = <span class="keyword">function</span>(<span class="params">n</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="title class_">Infinity</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;<span class="title class_">Math</span>.<span class="title function_">pow</span>(i,<span class="number">2</span>)&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="title class_">Math</span>.<span class="title function_">pow</span>(i,<span class="number">2</span>);j&lt;=n;j++)</span><br><span class="line">            dp[j] = <span class="title class_">Math</span>.<span class="title function_">min</span>(dp[j], dp[j-<span class="title class_">Math</span>.<span class="title function_">pow</span>(i,<span class="number">2</span>)]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h3><h4 id="描述：-5"><a href="#描述：-5" class="headerlink" title="描述："></a>描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</span><br><span class="line">说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。</span><br></pre></td></tr></table></figure>

<h4 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1： </span><br><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;] </span><br><span class="line">输出: true </span><br><span class="line">解释: 返回 true 。因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br><span class="line"></span><br><span class="line">示例 2： </span><br><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;] </span><br><span class="line">输出: true </span><br><span class="line">解释: 返回 true 。因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。注意你可以重复使用字典中的单词。</span><br><span class="line"></span><br><span class="line">示例 3： </span><br><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;] </span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h4 id="思路：-6"><a href="#思路：-6" class="headerlink" title="思路："></a>思路：</h4><p>​		<strong>dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词</strong>。</p>
<p>​		dp[0]初始为true完全就是为了推导公式。下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</p>
<h4 id="解法：-6"><a href="#解法：-6" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wordBreak = <span class="keyword">function</span>(<span class="params">s, wordDict</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=s.<span class="property">length</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;wordDict.<span class="property">length</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=wordDict[j].<span class="property">length</span>)</span><br><span class="line">                <span class="comment">// slice参数(start,end)</span></span><br><span class="line">                <span class="keyword">if</span>(s.<span class="title function_">slice</span>(i-wordDict[j].<span class="property">length</span>, i)===wordDict[j]&amp;&amp;dp[i-wordDict[j].<span class="property">length</span>])</span><br><span class="line">                    dp[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="property">length</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1： </span><br><span class="line">输入：[1,2,3,1] </span><br><span class="line">输出：4 </span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。   偷窃到的最高金额 = 1 + 3 = 4 。</span><br><span class="line"></span><br><span class="line">示例 2： </span><br><span class="line">输入：[2,7,9,3,1] </span><br><span class="line">输出：12 </span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。   偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>​		**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。</p>
<p>​		如果偷第i房间，那么dp[i] &#x3D; dp[i - 2] + nums[i] 。如果不偷第i房间，那么dp[i] &#x3D; dp[i - 1]。dp[i]取最大值，即<strong>dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);</strong></p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span>(<span class="params">nums</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span>(len===<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(len).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        dp[i]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">2</span>]+nums[i], dp[i-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[len-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打家劫舍ii"><a href="#打家劫舍ii" class="headerlink" title="打家劫舍ii"></a>打家劫舍ii</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [2,3,2] </span><br><span class="line">输出：3 </span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br><span class="line"></span><br><span class="line">示例 2： </span><br><span class="line">输入：nums = [1,2,3,1] </span><br><span class="line">输出：4 </span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4 。</span><br><span class="line"></span><br><span class="line">示例 3： </span><br><span class="line">输入：nums = [0] </span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>​		对于一个数组，成环的话主要有如下三种情况：不包含首尾元素；考虑包含首元素，不包含尾元素；考虑包含尾元素，不包含首元素。</p>
<p>​		在第二种方案中，假设不偷最后一间房下，若最大值求得的是没有偷第一间房的情况下的值。那么这种假设中包含了方案一的情况。同理在第三种方案中，也包含了方案一的情况。故实际上只需要考虑方案二和方案三的情况。</p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span>(<span class="params">nums</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="title function_">robRange</span>(nums, <span class="number">0</span>, n-<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="title function_">robRange</span>(nums, <span class="number">1</span>, n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(result1, result2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">robRange</span>(<span class="params">nums, start, end</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(start===end)</span><br><span class="line">        <span class="keyword">return</span> nums[end];</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[start] =nums[start];</span><br><span class="line">    dp[start+<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[start], nums[start+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start+<span class="number">2</span>;i&lt;=end;i++)</span><br><span class="line">        dp[i]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">2</span>]+nums[i], dp[i-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打家劫舍III"><a href="#打家劫舍III" class="headerlink" title="打家劫舍III"></a>打家劫舍III</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</span><br><span class="line">计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/dp/pic4.png" alt="打家劫舍III" style="zoom:50%;">

<p>思路：</p>
<p>​		<strong>本题一定是要后序遍历，因为通过递归函数的返回值来做下一步计算</strong>。</p>
<p><strong>树形dp题，因为是在树上进行状态转移。</strong>dp数组是一个长度为2的数组，用于记录一个节点 偷与不偷两个状态所得到的金钱。</p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">postOrder</span>(<span class="params">node</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="comment">// 空节点时，偷与不偷获得的钱数都是0</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">        <span class="keyword">const</span> left = <span class="title function_">postOrder</span>(node.<span class="property">left</span>);</span><br><span class="line">        <span class="keyword">const</span> right = <span class="title function_">postOrder</span>(node.<span class="property">right</span>);</span><br><span class="line">        <span class="comment">// 不偷当前节点，左右子节点都可以偷或不偷，取最大值</span></span><br><span class="line">        <span class="keyword">const</span> donot = <span class="title class_">Math</span>.<span class="title function_">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>])+<span class="title class_">Math</span>.<span class="title function_">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 偷当前节点，左右子节点只能不偷</span></span><br><span class="line">        <span class="keyword">const</span> donode = node.<span class="property">val</span> + left[<span class="number">0</span>]+right[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> [donot, donode];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title function_">postOrder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(...res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机（只能买卖一支股票）"><a href="#买卖股票的最佳时机（只能买卖一支股票）" class="headerlink" title="买卖股票的最佳时机（只能买卖一支股票）"></a>买卖股票的最佳时机（只能买卖一支股票）</h3><h4 id="描述：-6"><a href="#描述：-6" class="headerlink" title="描述："></a>描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</span><br><span class="line">你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</span><br><span class="line">返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</span><br></pre></td></tr></table></figure>

<h4 id="示例：-6"><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>

<h4 id="思路：-7"><a href="#思路：-7" class="headerlink" title="思路："></a>思路：</h4><p>​		<strong>重点：股票只能买卖一支！！！</strong></p>
<p>​		dp[i] [j] 表示天数 [0, i] 区间里，下标 i 这一天状态为 j 的时候能够获得的最大利润。其中：j &#x3D; 0，表示当前不持股；j &#x3D; 1，表示当前持股。下标为 <code>i</code> 的这一天的计算结果包含了区间 <code>[0, i]</code> 所有的信息，因此最后输出 <code>dp[len - 1][0]</code>。</p>
<p>dp[i] [0]：规定了今天不持股，有以下两种情况：</p>
<ul>
<li>昨天不持股，今天什么都不做；</li>
<li>昨天持股，今天卖出股票（现金数增加）；</li>
</ul>
<p>dp[i] [1]：规定了今天持股，有以下两种情况：</p>
<ul>
<li>昨天持股，今天什么都不做（现金数与昨天一样）；</li>
<li>昨天不持股，今天买入股票（注意：只允许交易一次，因此手上的现金数就是当天的股价的相反数）。</li>
</ul>
<p>dp[i] [0] &#x3D; Math.max(dp[i - 1] [0], dp[i - 1] [1] + prices[i]);<br>dp[i] [1] &#x3D; Math.max(dp[i - 1] [1], -prices[i]);</p>
<p>&#x2F;&#x2F;第二个式子中不能写成dp[i-1] [0]-prices[i]。因为只允许交易一次，而初始现金是0，所以一直没交易过，昨天不持股今天持股之后手上的现金只剩-prices[i]了。</p>
<h4 id="解法：-7"><a href="#解法：-7" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> len = prices.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = [];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]+prices[i]);</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">1</span>], -prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机II（可买多支股票）"><a href="#买卖股票的最佳时机II（可买多支股票）" class="headerlink" title="买卖股票的最佳时机II（可买多支股票）"></a>买卖股票的最佳时机II（可买多支股票）</h3><h4 id="描述：-7"><a href="#描述：-7" class="headerlink" title="描述："></a>描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br></pre></td></tr></table></figure>

<h4 id="示例：-7"><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure>

<h4 id="思路：-8"><a href="#思路：-8" class="headerlink" title="思路："></a>思路：</h4><p>dp[i] [1] &#x3D; Math.max(dp[i-1] [1], dp[i-1] [0] - prices[i]);<br>dp[i] [0] &#x3D; Math.max(dp[i-1] [0], dp[i-1] [1] + prices[i]);</p>
<h4 id="解法：-8"><a href="#解法：-8" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>, -prices[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]+prices[i]);</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>]-prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机III-最多完成两次交易"><a href="#买卖股票的最佳时机III-最多完成两次交易" class="headerlink" title="买卖股票的最佳时机III(最多完成两次交易)"></a>买卖股票的最佳时机III(最多完成两次交易)</h3><h4 id="描述：-8"><a href="#描述：-8" class="headerlink" title="描述："></a>描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br></pre></td></tr></table></figure>

<h4 id="示例：-8"><a href="#示例：-8" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [3,3,5,0,0,3,1,4] </span><br><span class="line">输出：6 </span><br><span class="line">解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。</span><br></pre></td></tr></table></figure>

<h4 id="思路：-9"><a href="#思路：-9" class="headerlink" title="思路："></a>思路：</h4><p>一天一共就有五个状态：</p>
<ol>
<li>没有操作</li>
<li>第一次买入</li>
<li>第一次卖出</li>
<li>第二次买入</li>
<li>第二次卖出</li>
</ol>
<p>dp[i] [j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i] [j]表示第i天状态j所剩最大现金。</p>
<p>达到dp[i] [1]状态，有两个具体操作：</p>
<ul>
<li>操作一：第i天买入股票了，那么dp[i] [1] &#x3D; dp[i-1] [0] - prices[i]</li>
<li>操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i] [1] &#x3D; dp[i - 1] [1]</li>
</ul>
<p> dp[i] [1] &#x3D; max(dp[i-1] [0] - prices[i], dp[i - 1] [1]);</p>
<p>同理dp[i] [2]也有两个操作：</p>
<ul>
<li>操作一：第i天卖出股票了，那么dp[i] [2] &#x3D; dp[i - 1] [1] + prices[i]</li>
<li>操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i] [2] &#x3D; dp[i - 1] [2]</li>
</ul>
<p>dp[i] [2] &#x3D; max(dp[i - 1] [1] + prices[i], dp[i - 1] [2])</p>
<p>同理可推出剩下状态部分：</p>
<p>dp[i] [3] &#x3D; max(dp[i - 1] [3], dp[i - 1] [2] - prices[i]);</p>
<p>dp[i] [4] &#x3D; max(dp[i - 1] [4], dp[i - 1] [3] + prices[i]);</p>
<p><strong>初始化</strong>：dp[0] [0]&#x3D;0; dp[0] [1]&#x3D;-prices[0]; dp[0] [2]&#x3D;0; dp[0] [3]&#x3D;-prices[0]; dp[0] [4]&#x3D;0;</p>
<h4 id="解法：-9"><a href="#解法：-9" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> len = prices.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>]-prices[i]);</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">2</span>], dp[<span class="number">1</span>]+prices[i]);</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">3</span>], dp[<span class="number">2</span>]-prices[i]);</span><br><span class="line">        dp[<span class="number">4</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">4</span>], dp[<span class="number">3</span>]+prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机IV-最多完成k笔交易"><a href="#买卖股票的最佳时机IV-最多完成k笔交易" class="headerlink" title="买卖股票的最佳时机IV(最多完成k笔交易)"></a>买卖股票的最佳时机IV(最多完成k笔交易)</h3><h4 id="描述：-9"><a href="#描述：-9" class="headerlink" title="描述："></a>描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</span><br><span class="line">设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</span><br><span class="line">注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br></pre></td></tr></table></figure>

<h4 id="示例：-9"><a href="#示例：-9" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 2, prices = [2,4,1] </span><br><span class="line">输出：2 </span><br><span class="line">解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2。</span><br></pre></td></tr></table></figure>

<h4 id="思路：-10"><a href="#思路：-10" class="headerlink" title="思路："></a>思路：</h4><p>​		<strong>除了0以外，偶数就是卖出，奇数就是买入</strong></p>
<h4 id="解法：-10"><a href="#解法：-10" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">k, prices</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = prices.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>*k+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 奇数是买入，偶数是卖出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*k;i+=<span class="number">2</span>)</span><br><span class="line">        dp[i]-=prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.<span class="property">length</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;<span class="number">2</span>*k+<span class="number">1</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(j%<span class="number">2</span>)</span><br><span class="line">                dp[j]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[j]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[j], dp[j-<span class="number">1</span>]+prices[i]);</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">2</span>*k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最佳买卖股票时机含冷冻期（可多次交易）"><a href="#最佳买卖股票时机含冷冻期（可多次交易）" class="headerlink" title="最佳买卖股票时机含冷冻期（可多次交易）"></a>最佳买卖股票时机含冷冻期（可多次交易）</h3><h4 id="描述：-10"><a href="#描述：-10" class="headerlink" title="描述："></a>描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</span><br><span class="line">设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</span><br><span class="line">- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</span><br><span class="line">- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</span><br></pre></td></tr></table></figure>

<h4 id="示例：-10"><a href="#示例：-10" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2] </span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure>

<h4 id="思路：-11"><a href="#思路：-11" class="headerlink" title="思路："></a>思路：</h4><p>​		dp[i] [j]，第i天状态为j，所剩的最多现金为dp[i] [j]。</p>
<p>​		具体可以区分出如下四个状态：</p>
<ul>
<li>状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</li>
<li>卖出股票状态，这里就有两种卖出股票状态<ul>
<li>状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</li>
<li>状态三：今天卖出了股票</li>
</ul>
</li>
<li>状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) - prices[i]);</span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong>：dp[0] [0]&#x3D;-prices[0]; dp[0] [1]&#x3D;0; dp[0] [2]&#x3D;0; dp[0] [3]&#x3D;0;</p>
<h4 id="解法：-11"><a href="#解法：-11" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = prices.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// 0是买入 1是卖出，度过了冷冻期 2是卖出 3是冷冻期</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]-prices[i], dp[<span class="number">3</span>]-prices[i]);</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">1</span>], dp[<span class="number">3</span>]);</span><br><span class="line">        dp[<span class="number">2</span>] = dp[<span class="number">0</span>]+prices[i];</span><br><span class="line">        dp[<span class="number">3</span>] = dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(...dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 含冷冻期</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxProfit5</span>(<span class="params">prices</span>)&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 0：手上持有股票</span></span><br><span class="line"><span class="comment">     * 1：手上不持股，并且处于冷冻期</span></span><br><span class="line"><span class="comment">     * 2：手上不持股，并且不处于冷冻期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> dp = [-prices[<span class="number">0</span>],<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;prices.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = [dp[<span class="number">0</span>],dp[<span class="number">1</span>],dp[<span class="number">2</span>]];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(temp[<span class="number">0</span>], temp[<span class="number">2</span>]-prices[i]);</span><br><span class="line">        dp[<span class="number">1</span>]=temp[<span class="number">0</span>]+prices[i];</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(temp[<span class="number">2</span>], temp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">2</span>], dp[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机含手续费-不限交易次数"><a href="#买卖股票的最佳时机含手续费-不限交易次数" class="headerlink" title="买卖股票的最佳时机含手续费(不限交易次数)"></a>买卖股票的最佳时机含手续费(不限交易次数)</h3><h4 id="描述：-11"><a href="#描述：-11" class="headerlink" title="描述："></a>描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。</span><br><span class="line">注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</span><br></pre></td></tr></table></figure>

<h4 id="示例：-11"><a href="#示例：-11" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 </span><br><span class="line">输出: 8</span><br><span class="line">解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</span><br></pre></td></tr></table></figure>

<h4 id="解法：-12"><a href="#解法：-12" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span>(<span class="params">prices, fee</span>)&#123;</span><br><span class="line">    <span class="comment">// 0卖出，1买入</span></span><br><span class="line">    <span class="keyword">let</span> dp = [<span class="number">0</span>, -prices[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;prices.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]+prices[i]-fee);</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[<span class="number">1</span>], dp[<span class="number">0</span>]-prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</span><br><span class="line">子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18] </span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>​		<strong>dp[i]表示i之前包括i的以nums[i]结尾最长上升子序列的长度。</strong>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p>
<p>if (nums[i] &gt; nums[j]) dp[i] &#x3D; max(dp[i], dp[j] + 1);</p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="keyword">function</span>(<span class="params">nums</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[j])</span><br><span class="line">                dp[i]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">        result = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i], result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个未经排序的整数数组，找到最长连续递增的子序列，并返回该序列的长度。连续递增的子序列可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,5,4,7] </span><br><span class="line">输出：3 </span><br><span class="line">解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪心</span></span><br><span class="line"><span class="keyword">var</span> findLengthOfLCITS = <span class="keyword">function</span>(<span class="params">nums</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="property">length</span>===<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.<span class="property">length</span>-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i+<span class="number">1</span>]&gt;nums[i])</span><br><span class="line">            count++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(count&gt;result)</span><br><span class="line">            result=count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动规</span></span><br><span class="line"><span class="keyword">var</span> findLengthOfLCITS1 = <span class="keyword">function</span>(<span class="params">nums</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;nums.<span class="property">length</span>-<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(nums[i+<span class="number">1</span>]&gt;nums[i])</span><br><span class="line">            dp[i+<span class="number">1</span>]=dp[i]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(...dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最长重复子数组（也就是连续子序列）"><a href="#最长重复子数组（也就是连续子序列）" class="headerlink" title="最长重复子数组（也就是连续子序列）"></a>最长重复子数组（也就是连续子序列）</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： A: [1,2,3,2,1] B: [3,2,1,4,7] </span><br><span class="line">输出：3 </span><br><span class="line">解释： 长度最长的公共子数组是 [3, 2, 1] 。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>​		dp[i] [j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i] [j]。</p>
<p>​		dp[0] [0]&#x3D;0; dp[i] [0] 和dp[0] [j]初始化为0。</p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findLength = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> m = nums1.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> n = nums2.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m+<span class="number">1</span>).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i-<span class="number">1</span>]===nums2[j-<span class="number">1</span>])</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            result = <span class="title class_">Math</span>.<span class="title function_">max</span>(result, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</span><br><span class="line">一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</span><br><span class="line">例如，&quot;ace&quot; 是 &quot;abcde&quot; 的子序列，但 &quot;aec&quot; 不是 &quot;abcde&quot; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</span><br><span class="line">若这两个字符串没有公共子序列，则返回 0。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3 </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>​		dp[i] [j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i] [j]</p>
<p>​		递推公式的两种情况：</p>
<ul>
<li>text1[i - 1] 与 text2[j - 1]相同。如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</li>
<li>text1[i - 1] 与 text2[j - 1]不相同。看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i] [j - 1]);</li>
</ul>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="keyword">function</span>(<span class="params">text1, text2</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = text1.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> n2 = text2.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n1+<span class="number">1</span>).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(n2+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">            <span class="comment">// 当text1[i-1]=text2[j-1]的时候说明</span></span><br><span class="line">            <span class="comment">// 可以考虑text1[0:i-1]和text2[0:j-1]的最长公共子序列</span></span><br><span class="line">            <span class="keyword">if</span>(text1[i-<span class="number">1</span>]===text2[j-<span class="number">1</span>])</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[text1.<span class="property">length</span>][text2.<span class="property">length</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最长公共子串-与子序列的区别在于，子序列可以不连续，而子串是连续的"><a href="#最长公共子串-与子序列的区别在于，子序列可以不连续，而子串是连续的" class="headerlink" title="最长公共子串[与子序列的区别在于，子序列可以不连续，而子串是连续的]"></a>最长公共子串[与子序列的区别在于，子序列可以不连续，而子串是连续的]</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定两个字符串str1和str2,输出两个字符串的最长公共子串</span><br><span class="line">题目保证str1和str2的最长公共子串存在且唯一。 </span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;1AB2345CD&quot;,&quot;12345EF&quot;</span><br><span class="line">返回值：&quot;2345&quot;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>​		dp[i] [j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i] [j]</p>
<p>​		递推公式的两种情况：</p>
<ul>
<li>text1[i - 1] 与 text2[j - 1]相同。如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;同时还要记录找到的最长长度以及记录公共子串的尾索引</li>
<li>text1[i - 1] 与 text2[j - 1]不相同，则置0.</li>
</ul>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">LCS</span>(<span class="params"> str1 ,  str2 </span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n1=str1.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> n2=str2.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n1+<span class="number">1</span>).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(n2+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> maxLength = <span class="number">0</span>, maxLastIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i-<span class="number">1</span>]===str2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&gt;maxLength)&#123;</span><br><span class="line">                    maxLength=dp[i][j];</span><br><span class="line">                    maxLastIndex=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1.<span class="title function_">substring</span>(maxLastIndex-maxLength, maxLastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。以这种方法绘制线条，并返回我们可以绘制的最大连线数。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/dp/pic5.png" alt="示例" style="zoom:50%;">

<p>思路：</p>
<p>​		<strong>本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！</strong></p>
<p>解法：</p>
<p>​		与最长公共子序列的代码一致</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxUncrossedLines = <span class="keyword">function</span>(<span class="params">nums1, nums2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = nums1.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> n2 = nums2.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n1+<span class="number">1</span>).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(n2+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=n1;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i-<span class="number">1</span>]===nums2[j-<span class="number">1</span>])</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=<span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4] </span><br><span class="line">输出: 6 </span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>dp[i]：包括下标i之前的最大连续子序列和为dp[i]。</p>
<p>dp[i] &#x3D; max(dp[i - 1] + nums[i], nums[i]);</p>
<p>​		此处状态的定义不是题目中问题的定义，不能直接把最后一个状态返回回去。题目中的输出是把所有的dp[0]、dp[1]…dp[n-1]都看一遍取最大值，所以代码中需要有一个max变量用于保存最大值。</p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可用贪心</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动规</span></span><br><span class="line"><span class="keyword">var</span> maxSubArrsy = <span class="keyword">function</span>(<span class="params">nums</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(len).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> max = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">// dp[i-1]+nums[i]将nums[i]加入当前子序</span></span><br><span class="line">        <span class="comment">// nums[i]为从头开始计算子序列和</span></span><br><span class="line">        dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>]+nums[i], nums[i]);</span><br><span class="line">        max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定字符串 s 和 t ，判断 s 是否为 t 的子序列。字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot; </span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>​		**dp[i] [j] 表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，相同子序列的长度为dp[i] [j]**。这样定义可以在二维矩阵中留出初始化区间。</p>
<p>有两种情况：</p>
<ul>
<li>s[i-1]&#x3D;t[j-1]：t中找到了一个字符在s中也出现了。那么dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1。</li>
<li>s[i-1]!&#x3D;t[j-1]：相当于t要删除元素，继续匹配。t如果把当前元素t[j - 1]删除，那么dp[i] [j] 的数值就是 看s[i - 1]与 t[j - 2]的比较结果了，即：dp[i] [j] &#x3D; dp[i] [j - 1];</li>
</ul>
<p>这个题与最长公共子序列很相似，只是在计算的过程中少了s[i-1] [j]的情况。</p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSubsequence = <span class="keyword">function</span>(<span class="params">s, t</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> m = s.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> n = t.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m+<span class="number">1</span>).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]===t[j])</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]===m?<span class="attr">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h3><p><em>【困难题】</em></p>
<h4 id="描述：-12"><a href="#描述：-12" class="headerlink" title="描述："></a>描述：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，&quot;ACE&quot; 是 &quot;ABCDE&quot; 的一个子序列，而 &quot;AEC&quot; 不是）。题目数据保证答案符合 32 位带符号整数范围。</span><br></pre></td></tr></table></figure>

<h4 id="示例：-12"><a href="#示例：-12" class="headerlink" title="示例："></a>示例：</h4><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/dp/pic6.png" alt="示例" style="zoom:50%;">

<h4 id="思路：-12"><a href="#思路：-12" class="headerlink" title="思路："></a>思路：</h4><p>​		dp[i] [j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i] [j]。</p>
<p>​		两种情况需要考虑：</p>
<ul>
<li>s[i-1]与t[j-1]相等。dp[i] [j]可以由两部分组成。一部分是用s[i - 1]来匹配，那么个数为dp[i - 1] [j - 1]。一部分是不用s[i - 1]来匹配，个数为dp[i - 1] [j]。故dp[i] [j] &#x3D; dp[i - 1] [j - 1] + dp[i - 1] [j];</li>
<li>s[i - 1] 与 t[j - 1]不相等。dp[i] [j] &#x3D; dp[i - 1] [j];</li>
</ul>
<h4 id="解法：-13"><a href="#解法：-13" class="headerlink" title="解法："></a>解法：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numDistinct = <span class="keyword">function</span>(<span class="params">s, t</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(s.<span class="property">length</span>+<span class="number">1</span>).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(t.<span class="property">length</span>+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=s.<span class="property">length</span>;i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=s.<span class="property">length</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">1</span>;j&lt;=t.<span class="property">length</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(s[i-<span class="number">1</span>]===t[j-<span class="number">1</span>])</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">return</span> dp[s.<span class="property">length</span>][t.<span class="property">length</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：</span><br><span class="line"></span><br><span class="line">F(0) = 0,   F(1) = 1</span><br><span class="line">F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line"></span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>解法：[动态规划]</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        dp[i]=(dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])%<span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p>描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s，找到 s 中最长的回文子串</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>​		dp[i] [j]表示字符串s的第i到j个字母组成的串是否是回文串。</p>
<p>​		初始化条件：dp[i] [i]是回文串。</p>
<p>解法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getLongestPalindrome</span>(<span class="params"> A </span>) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">let</span> n = A.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> A.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="title class_">Array</span>(n));</span><br><span class="line">    <span class="keyword">let</span> max_len = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 枚举子串的长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> L=<span class="number">2</span>;L&lt;n+<span class="number">1</span>;L++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            j = L+i-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 右边界越界</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 不是回文串</span></span><br><span class="line">            <span class="keyword">if</span>(A[i]!==A[j])</span><br><span class="line">                dp[i][j]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i&lt;<span class="number">3</span>)</span><br><span class="line">                    dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; (j-i+<span class="number">1</span>&gt;max_len))&#123;</span><br><span class="line">                max_len = j-i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

































<p>相似的题目：</p>
<ul>
<li>整数拆分、不同的二叉搜索树</li>
<li>拆分成两部分：分割等和子集、最后一块石头的重量II、目标和</li>
<li>零钱兑换II(组合数)、组合总和IV(排列数)、爬楼梯升级版</li>
<li>零钱兑换、完全平方数、单词拆分</li>
<li>[最长公共子序列、不相交的线]解法完全一致、判断子序列、不同的子序列</li>
<li>最长递增子序列、最长连续递增序列、最长重复子串：这些都需要有一个result来存放最大的值</li>
</ul>
<p>总结：</p>
<ul>
<li>纯背包问题是能否凑成一定的数量，动态规划的形式为：dp[j]&#x3D;Math.max(dp[j], dp[j-weight[i]]+value[i])</li>
<li>组合数形式的背包问题是凑成这个数量的方案有几种，动态规划的形式为：dp[j]+&#x3D;dp[j-weight[i]]</li>
<li>计算排列数时dp[0]初始化为1</li>
<li>计算最小数时，dp数组初始化值为Infinity，dp[0]&#x3D;0</li>
<li>最长子序列初始值为1</li>
</ul>
<p>注意点：</p>
<ul>
<li>初始化的时候要注意到底是0还是1还是Infinity还是-Infinity</li>
</ul>
<p>错题：</p>
<ul>
<li>最后一块石头的重量dp[j]表示的是容量为j的背包所能装下的最大物品重量</li>
<li>目标和与组合总和搞混</li>
<li>零钱兑换初始化存在问题，整个数组初始化为Infinity，但是dp[0]应该初始化为0</li>
<li>打家劫舍IIdp数组初始化长度以及遍历时下标易出错；打家劫舍III不会做(树形动规)</li>
<li>最佳买卖股票时机含冷冻期dp递推关系错误</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://cheyennee.github.io">Cheyennee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://cheyennee.github.io/2022/05/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">http://cheyennee.github.io/2022/05/01/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cheyennee.github.io" target="_blank">Cheyennee</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/dp/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/15/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/greed/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">贪心算法</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/23/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"><img class="next-cover" src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/recur/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">回溯算法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cheyennee</div><div class="author-info__description">生而为人，还请努力</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cheyennee"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">在路上</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">斐波那契数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">2.</span> <span class="toc-text">爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">3.</span> <span class="toc-text">使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number">4.</span> <span class="toc-text">不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">4.3.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A"><span class="toc-number">4.4.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">5.</span> <span class="toc-text">矩阵的最小路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II"><span class="toc-number">6.</span> <span class="toc-text">不同路径II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A-1"><span class="toc-number">6.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">6.2.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-1"><span class="toc-number">6.3.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-1"><span class="toc-number">6.4.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">7.</span> <span class="toc-text">整数拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">不同的二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%9F%BA%E7%A1%80"><span class="toc-number">9.</span> <span class="toc-text">背包问题基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E2%80%94%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">10.</span> <span class="toc-text">01背包问题—二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E2%80%94%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">11.</span> <span class="toc-text">01背包问题—一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-2"><span class="toc-number">11.1.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-2"><span class="toc-number">11.2.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">12.</span> <span class="toc-text">分割等和子集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A-2"><span class="toc-number">12.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-2"><span class="toc-number">12.2.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-3"><span class="toc-number">12.3.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-3"><span class="toc-number">12.4.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII"><span class="toc-number">13.</span> <span class="toc-text">最后一块石头的重量II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A-3"><span class="toc-number">13.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-3"><span class="toc-number">13.2.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-4"><span class="toc-number">13.3.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-4"><span class="toc-number">13.4.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">14.</span> <span class="toc-text">目标和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A-4"><span class="toc-number">14.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-4"><span class="toc-number">14.2.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-5"><span class="toc-number">14.3.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-5"><span class="toc-number">14.4.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-number">15.</span> <span class="toc-text">一和零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">16.</span> <span class="toc-text">完全背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II"><span class="toc-number">17.</span> <span class="toc-text">零钱兑换II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIV"><span class="toc-number">18.</span> <span class="toc-text">组合总和IV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%8D%87%E7%BA%A7%E7%89%88"><span class="toc-number">19.</span> <span class="toc-text">爬楼梯升级版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number">20.</span> <span class="toc-text">零钱兑换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">21.</span> <span class="toc-text">完全平方数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">22.</span> <span class="toc-text">单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A-5"><span class="toc-number">22.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-5"><span class="toc-number">22.2.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-6"><span class="toc-number">22.3.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-6"><span class="toc-number">22.4.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">23.</span> <span class="toc-text">打家劫舍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Dii"><span class="toc-number">24.</span> <span class="toc-text">打家劫舍ii</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII"><span class="toc-number">25.</span> <span class="toc-text">打家劫舍III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%88%E5%8F%AA%E8%83%BD%E4%B9%B0%E5%8D%96%E4%B8%80%E6%94%AF%E8%82%A1%E7%A5%A8%EF%BC%89"><span class="toc-number">26.</span> <span class="toc-text">买卖股票的最佳时机（只能买卖一支股票）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A-6"><span class="toc-number">26.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-6"><span class="toc-number">26.2.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-7"><span class="toc-number">26.3.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-7"><span class="toc-number">26.4.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8F%AF%E4%B9%B0%E5%A4%9A%E6%94%AF%E8%82%A1%E7%A5%A8%EF%BC%89"><span class="toc-number">27.</span> <span class="toc-text">买卖股票的最佳时机II（可买多支股票）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A-7"><span class="toc-number">27.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-7"><span class="toc-number">27.2.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-8"><span class="toc-number">27.3.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-8"><span class="toc-number">27.4.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII-%E6%9C%80%E5%A4%9A%E5%AE%8C%E6%88%90%E4%B8%A4%E6%AC%A1%E4%BA%A4%E6%98%93"><span class="toc-number">28.</span> <span class="toc-text">买卖股票的最佳时机III(最多完成两次交易)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A-8"><span class="toc-number">28.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-8"><span class="toc-number">28.2.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-9"><span class="toc-number">28.3.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-9"><span class="toc-number">28.4.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV-%E6%9C%80%E5%A4%9A%E5%AE%8C%E6%88%90k%E7%AC%94%E4%BA%A4%E6%98%93"><span class="toc-number">29.</span> <span class="toc-text">买卖股票的最佳时机IV(最多完成k笔交易)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A-9"><span class="toc-number">29.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-9"><span class="toc-number">29.2.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-10"><span class="toc-number">29.3.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-10"><span class="toc-number">29.4.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%EF%BC%88%E5%8F%AF%E5%A4%9A%E6%AC%A1%E4%BA%A4%E6%98%93%EF%BC%89"><span class="toc-number">30.</span> <span class="toc-text">最佳买卖股票时机含冷冻期（可多次交易）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A-10"><span class="toc-number">30.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-10"><span class="toc-number">30.2.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-11"><span class="toc-number">30.3.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-11"><span class="toc-number">30.4.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9-%E4%B8%8D%E9%99%90%E4%BA%A4%E6%98%93%E6%AC%A1%E6%95%B0"><span class="toc-number">31.</span> <span class="toc-text">买卖股票的最佳时机含手续费(不限交易次数)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A-11"><span class="toc-number">31.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-11"><span class="toc-number">31.2.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-12"><span class="toc-number">31.3.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">32.</span> <span class="toc-text">最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="toc-number">33.</span> <span class="toc-text">最长连续递增序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89"><span class="toc-number">34.</span> <span class="toc-text">最长重复子数组（也就是连续子序列）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">35.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2-%E4%B8%8E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E4%BA%8E%EF%BC%8C%E5%AD%90%E5%BA%8F%E5%88%97%E5%8F%AF%E4%BB%A5%E4%B8%8D%E8%BF%9E%E7%BB%AD%EF%BC%8C%E8%80%8C%E5%AD%90%E4%B8%B2%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84"><span class="toc-number">36.</span> <span class="toc-text">最长公共子串[与子序列的区别在于，子序列可以不连续，而子串是连续的]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF"><span class="toc-number">37.</span> <span class="toc-text">不相交的线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number">38.</span> <span class="toc-text">最大子序和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">39.</span> <span class="toc-text">判断子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">40.</span> <span class="toc-text">不同的子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9A-12"><span class="toc-number">40.1.</span> <span class="toc-text">描述：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-12"><span class="toc-number">40.2.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%EF%BC%9A-12"><span class="toc-number">40.3.</span> <span class="toc-text">思路：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%EF%BC%9A-13"><span class="toc-number">40.4.</span> <span class="toc-text">解法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-number">41.</span> <span class="toc-text">斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">42.</span> <span class="toc-text">最长回文子串</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/07/js%E9%A2%98/" title="js题"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/dp/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js题"/></a><div class="content"><a class="title" href="/2023/07/07/js%E9%A2%98/" title="js题">js题</a><time datetime="2023-07-07T14:28:39.043Z" title="发表于 2023-07-07 22:28:39">2023-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/18/top100/" title="top100"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="top100"/></a><div class="content"><a class="title" href="/2023/06/18/top100/" title="top100">top100</a><time datetime="2023-06-18T07:47:11.000Z" title="发表于 2023-06-18 15:47:11">2023-06-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/ts/" title="TS"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TS"/></a><div class="content"><a class="title" href="/2023/06/06/ts/" title="TS">TS</a><time datetime="2023-06-06T14:32:28.000Z" title="发表于 2023-06-06 22:32:28">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/01/playwright/" title="playwright"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/linux/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="playwright"/></a><div class="content"><a class="title" href="/2023/05/01/playwright/" title="playwright">playwright</a><time datetime="2023-04-30T23:25:56.000Z" title="发表于 2023-05-01 07:25:56">2023-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/27/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" title="前端安全"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/interview/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端安全"/></a><div class="content"><a class="title" href="/2023/03/27/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" title="前端安全">前端安全</a><time datetime="2023-03-27T05:15:38.000Z" title="发表于 2023-03-27 13:15:38">2023-03-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Cheyennee</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>