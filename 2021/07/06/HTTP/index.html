<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>HTTP | Cheyennee</title><meta name="keywords" content="blog"><meta name="author" content="Cheyennee,714851125@qq.com"><meta name="copyright" content="Cheyennee"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录与HTTP相关的内容">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP">
<meta property="og:url" content="http://cheyennee.github.io/2021/07/06/HTTP/index.html">
<meta property="og:site_name" content="Cheyennee">
<meta property="og:description" content="记录与HTTP相关的内容">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/cover.jpg">
<meta property="article:published_time" content="2021-07-06T09:24:55.000Z">
<meta property="article:modified_time" content="2023-07-27T03:36:21.848Z">
<meta property="article:author" content="Cheyennee">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/cover.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://cheyennee.github.io/2021/07/06/HTTP/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HTTP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-27 11:36:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cheyennee</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">HTTP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-06T09:24:55.000Z" title="发表于 2021-07-06 17:24:55">2021-07-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-27T03:36:21.848Z" title="更新于 2023-07-27 11:36:21">2023-07-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/HTTP/">HTTP</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HTTP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h3 id="什么是HTTP？"><a href="#什么是HTTP？" class="headerlink" title="什么是HTTP？"></a>什么是HTTP？</h3><p>​		<code>HTTP</code> (HyperText Transfer Protocol)，即超文本传输协议，是实现网络通信的一种规范。HTTP传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别。<code>HTTP</code>常被用于在<code>Web</code>浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密。</p>
<p>​		特点：</p>
<ul>
<li>支持客户&#x2F;服务器模式</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间</li>
<li>无状态：HTTP协议无法根据之前的状态进行本次的请求处理</li>
</ul>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>​		<code>HTTP</code>传递信息是以<strong>明文的形式</strong>发送内容，不安全。而<code>HTTPS</code>出现正是为了解决<code>HTTP</code>不安全的特性。</p>
<p>​		为了保证这些隐私数据能加密传输，HTTPS让<code>HTTP</code>运行安全的<code>SSL/TLS</code>协议上，即 HTTPS &#x3D; HTTP + SSL&#x2F;TLS，通过 <code>SSL</code>证书来<strong>验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</strong></p>
<p>​		<code>SSL</code> 协议位于<code>TCP/IP</code> 协议与各种应用层协议之间，浏览器和服务器在使用 <code>SSL</code> 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持。</p>
<h3 id="HTTPS链接的流程"><a href="#HTTPS链接的流程" class="headerlink" title="HTTPS链接的流程"></a>HTTPS链接的流程</h3><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/pic1.png" alt="流程" style="zoom:50%;">

<ul>
<li>客户端通过URL访问服务器建立SSL连接</li>
<li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端</li>
<li>客户端与服务器协商SSL连接的安全等级，也就是信息加密的等级</li>
<li>客户端根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li>
<li>服务器利用自己的私钥解密出会话密钥</li>
<li>服务器利用会话密钥加密与客户端之间的通信</li>
</ul>
<h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><ul>
<li>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL&#x2F;TLS协议进行了加密处理，相对更安全</li>
<li>HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443</li>
<li>HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP</li>
<li>HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高</li>
</ul>
<h3 id="HTTPS是如何保证安全的？"><a href="#HTTPS是如何保证安全的？" class="headerlink" title="HTTPS是如何保证安全的？"></a>HTTPS是如何保证安全的？</h3><p>HTTP存在的问题：</p>
<ul>
<li>通信中使用明文容易被窃取</li>
<li>无法验证对方身份，对方有可能被伪装</li>
</ul>
<p>HTTPS通过SSL能进行：</p>
<ul>
<li>信息加密</li>
<li>身份校验</li>
<li>信息完整性验证</li>
</ul>
<h3 id="SSL实现这些功能的方法："><a href="#SSL实现这些功能的方法：" class="headerlink" title="SSL实现这些功能的方法："></a>SSL实现这些功能的方法：</h3><ul>
<li>对称加密：采用协商的密钥对<strong>数据</strong>加密</li>
<li>非对称加密：实现身份认证和会话密钥协商。公钥加密，私钥解密。</li>
<li>摘要算法：验证信息的完整性。摘要算法能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。</li>
<li>数字签名：身份验证。私钥加密，公钥解密。</li>
</ul>
<h3 id="HTTPS的TLS四次握手"><a href="#HTTPS的TLS四次握手" class="headerlink" title="HTTPS的TLS四次握手"></a><strong>HTTPS的TLS四次握手</strong></h3><pre><code>  客户端发起HTTPS请求，连接服务器的443端口。服务器端返回数字证书和公钥。客户端验证数字证书，生成对称密钥，使用公钥加密对称密钥，发送给服务器端。服务器端使用私钥解密密钥，得到对称密钥。通知客户端后续通信使用对称密钥进行。
</code></pre>
<p>​		HTTPS先进行TCP三次握手，再进行TLS四次握手。</p>
<h3 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h3><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>​		用户数据报协议，是一个简单的<strong>面向数据报的通信协议</strong>，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层。也就是说无论应用层交给<code>UDP</code>多长的报文，它统统发送，一次发送一个报文。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务。</p>
<p>​		<code>UDP</code>报头包括4个字段，每个字段占用2个字节（即16个二进制位），也就是8个字节，标题短，开销小。</p>
<h4 id="UDP特点"><a href="#UDP特点" class="headerlink" title="UDP特点"></a>UDP特点</h4><ul>
<li>UDP 不提供复杂的控制机制，利用 IP 提供面向<strong>无连接</strong>的通信服务。无需提前与对方建立连接。</li>
<li>传输途中出现丢包，UDP 也不负责重发</li>
<li>当包的到达顺序出现乱序时，UDP没有纠正的功能。</li>
<li>并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞</li>
</ul>
<h4 id="UDP如何实现可靠传输"><a href="#UDP如何实现可靠传输" class="headerlink" title="UDP如何实现可靠传输"></a>UDP如何实现可靠传输</h4><p>​		UDP不可靠无法保证数据的可靠传输，故只能通过应用层来实现。实现方式可以参考TCP可靠性传输，只是实现转移到了应用层。</p>
<p>​		具体来说，可以添加如下机制：</p>
<ul>
<li><ol>
<li>添加seq&#x2F;ack机制，确保数据发送到对端</li>
</ol>
</li>
<li><ol start="2">
<li>添加发送和接收缓存区，主要是用户超时重传</li>
</ol>
</li>
<li><ol start="3">
<li>添加超时重传机制</li>
</ol>
</li>
</ul>
<p>​		详细说明：发送端发送数据时，生成一个随机seq&#x3D;x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack&#x3D;x的包，表示对方已经收到了数据。发送端收到ack包后，删除缓冲区对应的数据。时间到达后，定时检查是否需要重传数据。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>​		传输控制协议，是一种可靠、<strong>面向字节流的通信协议</strong>，把上面应用层交下来的数据看成无结构的字节流来发送。可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小。</p>
<p>​		<code>TCP</code>报文首部有20个字节，额外开销大。</p>
<h4 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h4><ul>
<li>TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。</li>
<li>此外，TCP 作为一种面向<strong>有连接</strong>的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。</li>
<li>根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现）</li>
</ul>
<h4 id="TCP如何保障自己的安全"><a href="#TCP如何保障自己的安全" class="headerlink" title="TCP如何保障自己的安全"></a>TCP如何保障自己的安全</h4><ul>
<li>检验和。TCP检验和的计算与UDP一样，在计算时要加上12比特的伪首部，检验范围包括TCP首部及数据部分。而UDP是可选的。计算方法：发送方将整个报文段分为多个16位的段，然后将所有段进行反码相加，将结果存放在检验和字段中，接收方用相同的方法进行计算，如果最终结果的检验字段所有位都是1则正确，为0则错误，丢弃此报文。</li>
<li>序列号。对每个报文进行编号。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">序列号的作用：</span><br><span class="line">- 保证可靠性，当接收到的数据失序时，立马就能知道</span><br><span class="line">- 去除重复的报文，数据传输过程中的确认应答，重发控制等功能都要依靠序列号来实现</span><br><span class="line">- 提高效率，可以实现多次发送，一次确认</span><br></pre></td></tr></table></figure>

<ul>
<li>ACK应答机制。每发送一条消息，就需要对方发送一条消息来回复消息是否被收到。</li>
<li>连接管理机制。三次握手建立连接与四次挥手断开连接，保证TCP全双工通信。</li>
<li>快重传与超时重传。快重传与超时重传机制同时存在，谁先检测到报文失序谁就生效。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 快重传。发送方连续收到3个接收方发送的同一个ACK时，此时快速重传ACK序号以及其之后的所有数据报。</span><br><span class="line">- 超时重传。当发送方发送了数据给接收方，当超过了约定的时间也没有接收到确认消息，则重传此报文。</span><br><span class="line">** 重传时间由TCP自适应算法生成</span><br></pre></td></tr></table></figure>

<ul>
<li>滑动窗口。滑动窗口可以提高报文传输的效率，同时避免发送方发送过多的数据而导致接收方无法正常处理数据。数据的发送方和接收方都有滑动窗口。对于发送方来说，窗口内就是可以发送的报文，当窗口的前沿紧挨的报文发送并且确认时，窗口向后移动。窗口的后沿也可以向前移动，当接收方处理不了那么多的报文时，就会发送消息告诉发送方，此时滑动窗口就需要缩小。</li>
<li>拥塞控制。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 慢开始：一开始发送报文时，不清楚网络情况，试探性的发送一个拥塞窗口的数据量</span><br><span class="line">- 如果没有达到慢开始的门限值，则以指数形式增长，直到达到门限值</span><br><span class="line">- 当到达门限值时，采用拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间就把发送方的拥塞窗口+1，直到网络拥塞</span><br><span class="line">- 当发生网络拥塞的时候，把门限值设置为出现拥塞时发送窗口大小的一半，然后把拥塞窗口设置为1，再次执行慢开始算法</span><br><span class="line">- 在发送方知道丢失了个别的报文段时，采用快恢复算法，将门限值设置成拥塞窗口大小的一半，并将拥塞窗口设置为当前门限值，并执行拥塞避免算法</span><br><span class="line">- 当发送方一连接收到三个对同一报文段的重复确认时，采用快重传算法，立即进行重传   </span><br></pre></td></tr></table></figure>

<h4 id="UDP与TCP的区别"><a href="#UDP与TCP的区别" class="headerlink" title="UDP与TCP的区别"></a>UDP与TCP的区别</h4><ul>
<li>TCP 是<strong>面向连接</strong>的协议，建立连接3次握手、断开连接四次挥手，UDP是面向<strong>无连接</strong>，数据传输前后不连接，发送端只负责将数据发送到网络，接收端从消息队列读取</li>
<li>TCP 提供<strong>可靠</strong>的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。丢包后也能重发。UDP 则尽可能传递数据，但<strong>不保证传递交付给对方</strong>，即使丢包，也不负责重发。</li>
<li>TCP 面向<strong>字节流</strong>，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，<strong>在目的站重新装配</strong>。UDP协议<strong>面向报文</strong>，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用</li>
<li>TCP 只能点对点<strong>全双工</strong>通信。UDP 支持一对一、一对多、多对一和多对多的交互通信</li>
</ul>
<h4 id="TCP与UDP的应用场景"><a href="#TCP与UDP的应用场景" class="headerlink" title="TCP与UDP的应用场景"></a>TCP与UDP的应用场景</h4><table>
<thead>
<tr>
<th>应用层协议</th>
<th>应用</th>
<th>传输层协议</th>
</tr>
</thead>
<tbody><tr>
<td>SMTP</td>
<td>电子邮件</td>
<td>TCP</td>
</tr>
<tr>
<td>TELNET</td>
<td>远程终端接入</td>
<td>TCP</td>
</tr>
<tr>
<td>HTTP</td>
<td>万维网</td>
<td>TCP</td>
</tr>
<tr>
<td>FTP</td>
<td>文件传输</td>
<td>TCP</td>
</tr>
<tr>
<td>DNS</td>
<td>域名转换</td>
<td>UDP</td>
</tr>
<tr>
<td>TFTP</td>
<td>文件传输</td>
<td>UDP</td>
</tr>
<tr>
<td>SNMP</td>
<td>网络管理</td>
<td>UDP</td>
</tr>
<tr>
<td>NFS</td>
<td>远程文件服务器</td>
<td>UDP</td>
</tr>
</tbody></table>
<p>TCP 适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用对效率要求高，对准确性要求低的场景</p>
<h4 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a><strong>拥塞控制和流量控制的区别</strong></h4><p>​		拥塞控制和流量控制不同，拥塞控制是全局性的过程，而流量控制是点对点通信量的控制。</p>
<p>​		拥塞控制就是为了防止过多的数据注入到网络中。拥塞控制是一个全局性的过程，涉及到所有主机，所有路由，以及与降低网络传输性能有关的因素。</p>
<p>​		流量控制往往是点对点通信量的控制，是端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便接收端来得及接收。</p>
<h4 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h4><h5 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h5><p>​	客户端向服务端发送数据，服务端接收的两个数据包粘在一起的情况。</p>
<h5 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h5><ol>
<li>TCP是基于字节流的。TCP首部没有表示数据长度的字段，传输的数据对于TCP来说仅仅是一段没有边界的字节流。</li>
<li>发送方产生粘包（缓冲区数据发送是一个堆压的过程）。当发送的数据包过于小时，那么TCP协议默认将这些较小的数据包进行合并发送。</li>
<li>接收方产生粘包（放数据的速度 &gt; 应用层拿数据速度）。接收方接收数据过慢，导致新旧数据包粘在一起。</li>
</ol>
<h5 id="如何解决粘包"><a href="#如何解决粘包" class="headerlink" title="如何解决粘包"></a>如何解决粘包</h5><p>​		在首部添加表示数据包长度的字段。</p>
<h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>​		<code>OSI</code>将计算机网络体系结构划分为七层，每一层实现各自的功能和协议，并完成与相邻层的接口通信。即每一层扮演固定的角色，互不打扰。</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/pic2.png" alt="OSI七层" style="zoom:38%;">

<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>​		应用层位于 OSI 参考模型的第七层，其作用是通过应用程序间的交互来完成特定的网络应用。<strong>该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。</strong>例如域名系统 <code>DNS</code>，支持万维网应用的 <code>HTTP</code> 协议，电子邮件系统采用的 <code>SMTP</code>协议等。在应用层交互的数据单元我们称之为报文。</p>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>​		<strong>表示层的作用是使通信的应用程序能够解释交换数据的含义</strong>，其位于 <code>OSI</code>参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。该层提供的服务主要包括数据压缩，数据加密以及数据描述，<strong>使应用程序不必担心在各台计算机中表示和存储的内部格式差异。</strong></p>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>​		会话层就是<strong>负责建立、管理和终止表示层实体之间的通信会话</strong>。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>​		<strong>传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题。</strong>传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层。其中，主要的传输层协议是<code>TCP</code>和<code>UDP</code>。</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>​		两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。网络层的主要任务就是<strong>选择合适的网间路由和交换节点</strong>，确保数据按时成功传送。</p>
<p>​		在发送数据时，网络层把传输层产生的报文或用户数据报<strong>封装成分组和包</strong>，向下传输到数据链路层。</p>
<p>​		在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 IP 层。</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>​		两台主机之间的数据传输，是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 <code>IP</code>数据报组装成帧，在两个相邻节点间的链路上传送帧。</strong></p>
<p>​		每一帧的数据可以分成：**报头<code>head</code>和数据<code>data</code>**两部分:</p>
<ul>
<li>head 标明数据发送者、接受者、数据类型，如 MAC地址</li>
<li>data 存储了计算机之间交互的数据</li>
</ul>
<p>​		通过控制信息我们可以<strong>知道一个帧的起止比特位置</strong>，此外，也能使接收端<strong>检测出所收到的帧有无差错</strong>，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>​		作为<code>OSI</code> 参考模型中最低的一层，物理层的作用是<strong>实现计算机节点之间比特流的透明传送</strong>。该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。该层主要是和硬件有关，与软件关系不大。</p>
<h3 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		TCP&#x2F;IP，<strong>传输控制协议</strong>&#x2F;<strong>网际协议</strong>，是指能够在多个不同网络间实现信息传输的协议簇。</p>
<ul>
<li>TCP（传输控制协议）</li>
</ul>
<p>一种<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议</p>
<ul>
<li>IP（网际协议）</li>
</ul>
<p>用于封包交换数据网络的协议</p>
<p>​		TCP&#x2F;IP协议不仅仅指的是<code>TCP</code>和<code>IP</code>两个协议，而是指一个由<code>FTP</code>、<code>SMTP</code>、<code>TCP</code>、<code>UDP</code>、<code>IP</code>等协议构成的协议簇，只是因为在<code>TCP/IP</code>协议中<code>TCP</code>协议和<code>IP</code>协议最具代表性，所以通称为TCP&#x2F;IP协议簇。</p>
<h4 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h4><p>​		TCP&#x2F;IP协议簇按层次分别了五层体系或者四层体系。五层体系的协议结构是综合了 OSI 和 TCP&#x2F;IP 优点的一种协议，包括应用层、传输层、网络层、数据链路层和物理层。五层协议的体系结构只是为介绍网络原理而设计的，实际应用还是 TCP&#x2F;IP 四层体系结构，包括应用层、传输层、网络层（网际互联层）、网络接口层。如下图所示：</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/pic3.png" alt="TCPIP" style="zoom:50%;">

<h5 id="五层体系"><a href="#五层体系" class="headerlink" title="五层体系"></a>五层体系</h5><p>应用层：<code>TCP/IP</code> 模型将 <code>OSI</code>参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务</p>
<p>传输层、网络层、数据链路层、物理层与OSI七层中的功能一致</p>
<h5 id="四层体系"><a href="#四层体系" class="headerlink" title="四层体系"></a>四层体系</h5><p>应用层：对应于OSI模型的上三层：会话层、表示层和应用层。</p>
<p>传输层：对应OSI模型的传输层。（报文段）</p>
<p>网络层：对应OSI模型的网络层。（数据报）</p>
<p>网络接口层：对应OSI模型的最后两层：数据链路层、物理层。（帧）</p>
<h4 id="OSI参考模型与TCP-x2F-IP参考模型的区别"><a href="#OSI参考模型与TCP-x2F-IP参考模型的区别" class="headerlink" title="OSI参考模型与TCP&#x2F;IP参考模型的区别"></a>OSI参考模型与TCP&#x2F;IP参考模型的区别</h4><p>相同点：</p>
<ul>
<li>OSI 参考模型与 TCP&#x2F;IP 参考模型都采用了<strong>层次结构</strong></li>
<li>都能够提供<strong>面向连接和无连接</strong>两种通信服务机制</li>
</ul>
<p>不同点：</p>
<ul>
<li>OSI 采用的七层模型； TCP&#x2F;IP 是四层或五层结构</li>
<li>TCP&#x2F;IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分</li>
<li>OSI 参考模型将网络划分为七层，但实现起来较困难。TCP&#x2F;IP 参考模型作为一种简化的分层结构是可以的</li>
<li>TCP&#x2F;IP协议去掉表示层和会话层的原因在于会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包，而应用程序之间是几乎无法实现代码的抽象共享的，这也就造成 <code>OSI</code> 设想中的应用程序维度的分层是无法实现的</li>
</ul>
<h3 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h3><h4 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		域名解析系统，进行域名和与之对应的IP地址进行转换的服务器。</p>
<h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>​		域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名…例如<code>www.xxx.com</code>，<code>www</code>为三级域名、<code>xxx</code>为二级域名、<code>com</code>为顶级域名，系统为用户做了兼容，域名末尾的根域名<code>.</code>一般不需要输入。</p>
<h4 id="DNS查询方式"><a href="#DNS查询方式" class="headerlink" title="DNS查询方式"></a>DNS查询方式</h4><ul>
<li>递归查询。如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案。</li>
<li>迭代查询。如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求。</li>
</ul>
<h4 id="域名缓存"><a href="#域名缓存" class="headerlink" title="域名缓存"></a>域名缓存</h4><p>​		在域名服务器解析的时候，使用缓存保存域名和<code>IP</code>地址的映射。计算机中<code>DNS</code>的记录也分成了两种缓存方式：</p>
<ul>
<li>浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗</li>
<li>操作系统缓存：操作系统的缓存其实是用户自己配置的 <code>hosts</code> 文件</li>
</ul>
<h4 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h4><ul>
<li>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</li>
<li>若没有命中，则继续搜索操作系统的 DNS 缓存</li>
<li>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用<strong>递归查询</strong>自己的 DNS 缓存，查找成功则返回结果。本地域名服务器其实是本地区的域名服务器。若在学校接入的互联网，那么本地区域名服务器基本上是在学校中；若在小区中接入的互联网，那么本地区域名服务器就是提供接入互联网的应用服务上，也就是电信或者联通。</li>
<li>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行<strong>迭代查询</strong><ul>
<li>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</li>
<li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li>
<li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>
</ul>
</li>
<li>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</li>
<li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</li>
<li>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来</li>
</ul>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><h4 id="是什么？-2"><a href="#是什么？-2" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		内容分发网络。也就是根据用户位置分配最近的资源，使得用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫<strong>边缘节点</strong>，其实就是缓存了源站内容的代理服务器，从而降低网络拥塞，提高用户访问响应速度和命中率。<code>CDN</code> 的关键技术主要有内容存储和分发技术。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>​		在没有应用<code>CDN</code>时，我们使用域名访问某一个站点时的路径为：用户提交域名→浏览器对域名进行解释→<code>DNS</code> 解析得到目的主机的IP地址→根据IP地址访问发出请求→得到请求数据并回复。</p>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>​		使用CDN之后，DNS返回的不再是一个IP地址，而是一个<code>CNAME</code>别名记录，指向CDN的全局负载均衡。<code>CNAME</code>实际上在域名解析的过程中承担了中间人（或者说代理）的角色，这是<code>CDN</code>实现的关键。</p>
<p>​		由于没有返回<code>IP</code>地址，于是本地<code>DNS</code>会向负载均衡系统再发送请求 ，则进入到<code>CDN</code>的全局负载均衡系统进行智能调度：</p>
<ul>
<li>看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点</li>
<li>看用户所在的运营商网络，找相同网络的边缘节点</li>
<li>检查边缘节点的负载情况，找负载较轻的节点</li>
<li>其他，比如节点的“健康状况”、服务能力、带宽、响应时间等</li>
</ul>
<p>​		结合上面的因素，得到最合适的边缘节点，然后把这个节点返回给用户，用户就能够就近访问<code>CDN</code>的缓存代理。</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/pic4.png" alt="负载均衡" style="zoom:80%;">

<h5 id="缓存代理"><a href="#缓存代理" class="headerlink" title="缓存代理"></a>缓存代理</h5><p>​		缓存系统是 <code>CDN</code>的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源。</p>
<p>​		其中有两个衡量<code>CDN</code>服务质量的指标：</p>
<ul>
<li>命中率：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比</li>
<li>回源率：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比</li>
</ul>
<p>​		缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户。回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源。</p>
<h3 id="HTTP1-0-x2F-1-1-x2F-2-0"><a href="#HTTP1-0-x2F-1-1-x2F-2-0" class="headerlink" title="HTTP1.0&#x2F;1.1&#x2F;2.0"></a>HTTP1.0&#x2F;1.1&#x2F;2.0</h3><h4 id="HTTP-1-0（无连接、无状态、一次连接只能完成一个请求）"><a href="#HTTP-1-0（无连接、无状态、一次连接只能完成一个请求）" class="headerlink" title="HTTP 1.0（无连接、无状态、一次连接只能完成一个请求）"></a>HTTP 1.0（无连接、无状态、一次连接只能完成一个请求）</h4><p>​		<code>HTTP 1.0</code> 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个<code>TCP</code>连接。服务器完成请求处理后立即断开<code>TCP</code>连接，服务器不跟踪每个客户也不记录过去的请求。简单来讲，每次与服务器交互，都需要新开一个连接。</p>
<p>​		最终导致一个<code>html</code>文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关闭连接。这种形式明显<strong>造成了性能上的缺陷</strong>。</p>
<h4 id="HTTP-1-1（一个连接能完成多个请求）"><a href="#HTTP-1-1（一个连接能完成多个请求）" class="headerlink" title="HTTP 1.1（一个连接能完成多个请求）"></a>HTTP 1.1（一个连接能完成多个请求）</h4><p>​		在<code>HTTP1.1</code>中，默认支持长连接（<code>Connection: keep-alive</code>），即在一个TCP连接上可以传送多个<code>HTTP</code>请求和响应，减少了建立和关闭连接的消耗和延迟。建立一次连接，多次请求均由这个连接完成。这样，在加载<code>html</code>文件的时候，文件中多个请求和响应就可以在一个连接中传输。</p>
<p>​		同时，<code>HTTP 1.1</code>还允许<strong>客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果</strong>，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p>
<p>​		同时，<code>HTTP1.1</code>在<code>HTTP1.0</code>的基础上，增加更多的请求头和响应头来完善的功能，如下：</p>
<ul>
<li>引入了更多的缓存控制策略，如If-Unmodified-Since, If-Match, If-None-Match等缓存头来控制缓存策略</li>
<li>引入range，允许值请求资源某个部分</li>
<li>引入host，实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点</li>
</ul>
<p>并且还添加了其他的请求方法：<code>put</code>、<code>delete</code>、<code>options</code>…</p>
<h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h4><p>​		主要是进行性能提升，添加了某些特性：</p>
<ul>
<li>多路复用</li>
<li>二进制分帧</li>
<li>首部压缩</li>
<li>服务器推送</li>
</ul>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>​		复用TCP连接，在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。</p>
<h5 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h5><p>​		HTTP2中采用二进制格式传输数据，而HTTP1中采用文本格式传输数据。故HTTP2中解析效果更好。</p>
<p>​		HTTP2中将请求和响应数据分割成更小的帧，并且采用二进制编码。HTTP2中，<strong>同域名下所有通信都在单个连接中完成，该连接可以承载任意数量的双向数据流。</strong>每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据<strong>帧首部的流标识</strong>可以重新组装，这也是多路复用同时发送数据的实现条件。</p>
<h5 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h5><p>​		<code>HTTP2</code>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送。</p>
<h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h5><p>​		<code>HTTP2</code>引入服务器推送，允许服务端推送资源给客户端。服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源。免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。典型场景：前端向后端请求一个HTML，服务器把HTML页面中的CSS、JS等资源也推送给浏览器。当浏览器再次发送请求时，可以直接从缓存中读取。</p>
<h3 id="常见的HTTP状态码"><a href="#常见的HTTP状态码" class="headerlink" title="常见的HTTP状态码"></a>常见的HTTP状态码</h3><h4 id="是什么？-3"><a href="#是什么？-3" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		HTTP状态码的作用是服务器告诉客户端当前请求响应的状态，通过状态码就能判断和分析服务器的运行状态。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>1XX：代表请求已被接收，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</li>
<li>2XX：代表请求已成功被服务器接收、理解、并接受。</li>
<li>3XX：代表完成请求需要进一步操作。通常，这些状态码用来重定向。</li>
<li>4XX：客户端可能发生了错误，妨碍了服务器的处理。</li>
<li>5XX：标识服务器无法完成明显有效的请求。这类状态码代表服务器在处理请求的过程中有错误或异常状态发生。</li>
</ul>
<h4 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h4><ul>
<li>100：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输。</li>
<li>101：服务器根据客户端的请求切换协议，主要用于websocket或HTTP2升级</li>
<li>200：请求已成功，请求所希望的响应头或数据体将随此响应返回</li>
<li>201：请求成功并且服务器创建了新的资源</li>
<li>202：服务器已经接收请求，但尚未处理</li>
<li>204：服务器已经接收请求，但是请求的内容已被删除</li>
<li>301：请求的网页已永久移动到新位置</li>
<li>302：临时性重定向，服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li>
<li>303：临时性重定向，请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码</li>
<li>304：自从上次请求后，请求的网页未修改过</li>
<li>400：服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求</li>
<li>401：请求未授权。请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li>
<li>403：禁止访问，服务器拒绝请求</li>
<li>404：服务器找不到请求的网页</li>
<li>500：服务端错误</li>
<li>503：服务器端暂时无法处理请求，可能是过载或维护</li>
</ul>
<h3 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h3><h4 id="是什么？-4"><a href="#是什么？-4" class="headerlink" title="是什么？"></a>是什么？</h4><p>GET方法请求一个指定资源，使用GET的请求应该只被用于获取数据</p>
<p>POST方法用于将实体提交到指定的资源，通常导致服务器上的状态变化或副作用</p>
<h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><p>都是TCP链接</p>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ul>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>
<li>GET请求会被浏览器主动缓存，而POST不会，除非手动设置。</li>
<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>
<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>
<li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li>
<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>
<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>
<li>GET参数通过URL传递，POST放在Request body中</li>
<li>对于<code>GET</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，服务器响应200（返回数据）。对于<code>POST</code>，浏览器先发送<code>header</code>，服务器响应100 <code>continue</code>，浏览器再发送<code>data</code>，服务器响应200 ok。并不是所有浏览器都会在<code>POST</code>中发送两次包，<code>Firefox</code>就只发送一次。</li>
</ul>
<h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><h4 id="函数副作用"><a href="#函数副作用" class="headerlink" title="函数副作用"></a>函数副作用</h4><p>​		副作用是指，当调用函数的时候，除了返回函数值外，还对主调用函数产生附加的影响。副作用函数不仅仅返回了一个值，还在函数内部做了其他的事情，比如：1.修改了一个变量；2.设置了一个对象成员；3.抛出异常；4.打印到终端；5.读取或写入文件；等。</p>
<h4 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h4><p>​		不产生副作用。函数与外界交换数据只能通过参数和返回值。函数从外部接受的所有输入信息都通过参数传递到该函数内部；函数输出到函数外部的所有信息都通过返回值传递到该函数外部。</p>
<h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><ul>
<li>GET：发送请求来获取服务器上的某个资源</li>
<li>POST：向URL指定的资源提交数据或附加新的数据</li>
<li>PUT：向服务器提交数据，与POST方法类似。但是PUT指定了资源在服务器上的位置，而POST没有</li>
<li>HEAD：只请求页面首部</li>
<li>DELETE：删除服务器上的资源</li>
<li>OPTIONS：获取当前URL支持的请求方法</li>
<li>TRACE：用于激活远程的、应用层的请求消息</li>
<li>CONNECT：把请求连接转换到TCP&#x2F;IP通道</li>
</ul>
<h3 id="HTTP请求头"><a href="#HTTP请求头" class="headerlink" title="HTTP请求头"></a>HTTP请求头</h3><h4 id="是什么？-5"><a href="#是什么？-5" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		定义了一个超文本传输协议事务中的操作参数。HTTP头部字段可以自己根据需要定义，因此可能在 <code>Web</code>服务器和浏览器上发现非标准的头字段。</p>
<h4 id="常见请求头"><a href="#常见请求头" class="headerlink" title="常见请求头"></a>常见请求头</h4><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/pic5.png" alt="常见请求头" style="zoom:80%;">

<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>能够接受的响应内容类型</td>
<td>Accept: text&#x2F;plain</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>能够接受的字符集</td>
<td>Accept-Charset: utf-8</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>能够接受的编码方式</td>
<td>Accept-Encoding: gzip</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>能够接受的响应内容的自然语言列表</td>
<td>Accept-Language: en-US</td>
</tr>
<tr>
<td>Authorization</td>
<td>认证信息</td>
<td>Authorization: Basic QWxhZGRp&#x3D;&#x3D;</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>用于指定此次请求&#x2F;响应中的所有缓存机制</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Connection</td>
<td>浏览器想要优先使用的连接类型</td>
<td>Connection: keep-alive</td>
</tr>
<tr>
<td>Cookie</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求体的长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求体的类型</td>
<td>Content-Type: application&#x2F;x-www-form-urlencoded</td>
</tr>
<tr>
<td>Date</td>
<td>发送请求的日期时间</td>
<td>Date: Tue, 15 Nov 1994 08:12:31 GMT</td>
</tr>
<tr>
<td>Expect</td>
<td>浏览器要求服务器做出特定的行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>Host</td>
<td>服务器的域名以及服务器所监听的传输控制协议端口号</td>
<td>Host: en.wikipedia.org:80</td>
</tr>
<tr>
<td>Range</td>
<td>仅请求某个实体的部分</td>
<td>Range: bytes&#x3D;500-999</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器身份标识字符串</td>
<td>User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:12.0) Gecko&#x2F;20100101 Firefox&#x2F;21.0</td>
</tr>
<tr>
<td>Origin</td>
<td>发起一个跨域请求</td>
<td>Origin: <a target="_blank" rel="noopener" href="http://www.example-social-network.com/">http://www.example-social-network.com</a></td>
</tr>
<tr>
<td>Referer</td>
<td>请求来源</td>
<td>在<a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a> 里有一个<code>www.baidu.com</code> 链接，那么点击这个<code>www.baidu.com</code> ，它的<code>header</code> 信息里就有：Referer: <a target="_blank" rel="noopener" href="http://www.google.com/">http://www.google.com</a></td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>允许在对应内容未被修改的情况下返回304未修改</td>
<td>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>允许在对应内容未被修改的情况下返回304未修改</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
</tbody></table>
<h4 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h4><h5 id="协商缓存-HTTP304"><a href="#协商缓存-HTTP304" class="headerlink" title="协商缓存 HTTP304"></a>协商缓存 HTTP304</h5><p>​		协商缓存是利用的是<code>【Last-Modified，If-Modified-Since】</code>和<code>【ETag、If-None-Match】</code>这两对请求头响应头来管理的。</p>
<p>​		<code>Last-Modified</code> 表示本地文件最后修改日期，浏览器会在request header加上<code>If-Modified-Since</code>（上次返回的<code>Last-Modified</code>的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p>
<p>​		<code>Etag</code>就像一个指纹，资源变化都会导致<code>ETag</code>变化，跟最后修改时间没有关系，<code>ETag</code>可以保证每一个资源是唯一的。</p>
<p>​		<code>If-None-Match</code>的header会将上次返回的<code>Etag</code>发送给服务器，询问该资源的<code>Etag</code>是否有更新，有变动就会发送新的资源回来。</p>
<p>​		协商缓存就是浏览器和服务器需要协商才能确定是使用浏览器缓存的资源还是服务器的资源。具体的就是在该次请求的返回头部加上一个字段，标识这个文件的版本。这个字段在http1.0是Last-Modified,在http1.1是Etag。如果资源有更新就使用服务器返回的，否则就使用浏览器的。</p>
<h5 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h5><p>​		强制缓存不需要发送请求到服务端，根据请求头<code>expires</code>和<code>cache-control</code>判断是否命中强缓存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cache-control:</span><br><span class="line">- max-age = 519400(s)</span><br><span class="line">- no-cache 不用强制缓存</span><br><span class="line">- no-store 不用所有缓存</span><br></pre></td></tr></table></figure>

<p>​		强制缓存就是强制使用浏览器缓存下来的资源。在指定的一段时间内使用自己缓存的文件就行，不需要再次发出请求。具体的是在该次请求的<strong>返回头部</strong>加上一个字段，标识这段不需要请求的时间有多长。这个字段在http1.0是expires，在http1.1是cache-control。如果强制缓存和协商缓存同时存在，强制缓存优先。</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/pic6.png" alt="强制/协商缓存" style="zoom:80%;">

<h4 id="协商缓存与强制缓存的使用场景"><a href="#协商缓存与强制缓存的使用场景" class="headerlink" title="协商缓存与强制缓存的使用场景"></a>协商缓存与强制缓存的使用场景</h4><p>​		对于频繁变动的资源使用协商缓存，对于很少变化的资源使用强制缓存。</p>
<p>​		根据用户行为来判断触发什么样的缓存策略。1.打开网页。首先查找缓存中是否有匹配的，如果有则使用；没有则发送网络请求。2.普通刷新，可以使用本地缓存[强制缓存]。3.强制刷新，使用协商缓存。</p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>​		<code>cookie</code>为某些网站为了辨别用户身份而储存在<strong>用户本地终端上</strong>的数据，通过响应头<code>set-cookie</code>决定</p>
<p>​		作为一段一般不超过 <strong>4KB</strong> 的小型文本数据，它由一个<strong>名称（Name）、一个值（Value）和其它几个用于控制 <code>Cookie</code>有效期、安全性、使用范围的可选属性组成</strong></p>
<p><code>Cookie</code> 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如<strong>用户登录状态</strong>、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如<strong>用户自定义设置、主题</strong>等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等</li>
</ul>
<h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a><strong>cookie和session的区别</strong></h3><h5 id="cookie的作用"><a href="#cookie的作用" class="headerlink" title="cookie的作用"></a>cookie的作用</h5><pre><code>  HTTP协议是无状态的，客户端和服务器端是无法识别对方的。HTTP cookie是HTTP协议无状态的一种补充。
</code></pre>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><pre><code>  session是服务器端保存用户状态信息的一种数据结构

  cookie是客户端保存用户状态信息的一种机制
</code></pre>
<h5 id="建立cookie的过程"><a href="#建立cookie的过程" class="headerlink" title="建立cookie的过程"></a>建立cookie的过程</h5><pre><code>  服务器端第一次收到请求时，创建session对象，同时生成一个sessionId，并通过设置响应头，要求客户端设置cookie。客户端收到响应后建立cookie，之后每次访问该服务器，都会带上cookie，服务器从发送过来的cookie中，识别发送者的身份。
</code></pre>
<h3 id="token和cookie的相同点和异同点"><a href="#token和cookie的相同点和异同点" class="headerlink" title="token和cookie的相同点和异同点"></a><strong>token和cookie的相同点和异同点</strong></h3><h5 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h5><p>​		都是对HTTP无状态的补充</p>
<p>​		都是首次登陆后产生的</p>
<h5 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h5><p>​		cookie存在header中，token可以存在于header、requestbody、url中。</p>
<p>​		服务器端不需要存储token，只进行验证。而cookie则要在服务器端存session。</p>
<p>​		cookie会造成csrf攻击，token则可以避免。</p>
<h3 id="地址栏输入URL敲下回车后发生了什么？"><a href="#地址栏输入URL敲下回车后发生了什么？" class="headerlink" title="地址栏输入URL敲下回车后发生了什么？"></a>地址栏输入URL敲下回车后发生了什么？</h3><h4 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h4><ul>
<li>URL解析</li>
<li>DNS查询</li>
<li>TCP连接</li>
<li>HTTP请求</li>
<li>响应请求</li>
<li>页面渲染</li>
</ul>
<h4 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h4><p>​		首先判断输入的是一个合法的<code>URL</code> 还是一个待搜索的关键词，并且根据输入的内容进行对应操作。</p>
<p>​		一个URL的结构解析如下：</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/pic7.png" alt="URL结构" style="zoom:80%;">

<h4 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h4><h4 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h4><p>​		三次握手：客户端将标有SYN的数据包发送给服务器；服务器收到客户端发来的数据包后，发送标有SYN&#x2F;ACK的数据包；客户端接收到服务器发送来的数据包后，发送标有ACK的数据包。</p>
<h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><p>​		建立TCP连接后，可以在这个基础上进行通信，浏览器发送HTTP请求到目标服务器。</p>
<p>​		请求的内容包括：</p>
<ul>
<li>请求行：请求方法、请求URL、HTTP协议及版本</li>
<li>请求头</li>
<li>空行</li>
<li>请求主体</li>
</ul>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/pic8.png" alt="HTTP请求" style="zoom:80%;">

<h4 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h4><p>​		当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个<code>HTTP</code>响应消息，包括：</p>
<ul>
<li>状态行</li>
<li>响应头</li>
<li>空行</li>
<li>响应正文</li>
</ul>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/pic9.png" alt="HTTP响应" style="zoom:80%;">

<p>​		在服务器响应之后，由于现在<code>http</code>默认开始长连接<code>keep-alive</code>，当页面关闭之后，<code>tcp</code>链接则会经过四次挥手完成断开。</p>
<h4 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h4><p>当浏览器接收到服务器响应的资源后，<strong>首先会对资源进行解析</strong>：</p>
<ul>
<li>查看响应头的信息，根据不同的指示做对应处理，比如重定向，存储cookie，解压gzip，缓存资源等等</li>
<li>查看响应头的 Content-Type的值，根据不同的资源类型采用不同的解析方式</li>
</ul>
<p>关于页面的渲染过程如下：</p>
<ul>
<li>解析HTML，构建 DOM 树。解析过程中遇到图片、样式表、JS文件就启动下载。</li>
<li>解析 CSS ，生成 CSS 规则树</li>
<li>合并 DOM 树和 CSS 规则，生成 render 树</li>
<li>布局 render 树（ Layout &#x2F; reflow ），负责各元素尺寸、位置的计算</li>
<li>绘制 render 树（ paint ），绘制页面像素信息</li>
<li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</li>
</ul>
<h5 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h5><ul>
<li>根据HTML规范将字符流解析为标记</li>
<li>词法分析将标记转换为对象并定义属性和规则</li>
<li>根据HTML标记关系将对象组成DOM树</li>
</ul>
<h5 id="构建CSS规则树"><a href="#构建CSS规则树" class="headerlink" title="构建CSS规则树"></a>构建CSS规则树</h5><ul>
<li>字符流转为标记流</li>
<li>根据标记创建节点</li>
<li>节点创建CSS规则树</li>
</ul>
<h5 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h5><ul>
<li>从DOM树的根节点遍历所有可见节点</li>
<li>对每个可见节点，找到恰当的CSS规则并应用</li>
<li>发布可视节点的内容和计算样式</li>
</ul>
<h5 id="JS解析过程"><a href="#JS解析过程" class="headerlink" title="JS解析过程"></a>JS解析过程</h5><ul>
<li>浏览器创建document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading</li>
<li>HTML解析器遇到没有aysnc和defer的脚本时，将它们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且<strong>在脚本下载和执行时解析器会暂停。</strong></li>
<li>这样就可以用document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</strong></li>
<li>当解析器遇到设置了<strong>async</strong>属性的script时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素</li>
<li>当文档完成解析，document.readyState变成interactive</li>
<li>所有<strong>defer</strong>脚本会<strong>按照在文档出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档树</strong>，禁止使用document.write()</li>
<li>浏览器<strong>在Document对象上触发DOMContentLoaded事件</strong></li>
<li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readyState变为complete，window触发load事件</li>
</ul>
<h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><p>​		用于开启新的线程下载脚本文件，并使脚本在文档解析完成后执行。</p>
<p>​		这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，<strong>脚本会被延迟到整个页面都解析完毕后再运行</strong>。因此，在<code>&lt;script&gt;</code>元素中设置<code>defer</code>属性，相当于告诉浏览器立即下载，但延迟执行。</p>
<p>​		<code>HTML5</code>规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于<code>DOMContentLoaded</code>事件执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在<code>DOMContentLoad</code>时间触发前执行，因此最好只包含一个延迟脚本。</p>
<h5 id="async"><a href="#async" class="headerlink" title="async"></a>async</h5><p>​		HTML5新增属性，用于异步下载脚本文件，下载完毕立即解释执行代码。</p>
<p>​		这个属性与<code>defer</code>类似，都用于改变处理脚本的行为。同样与<code>defer</code>类似，<code>async</code>只适用于外部脚本文件，并告诉浏览器立即下载文件。但与<code>defer</code>不同的是，标记为<code>async</code>的脚本并不保证按照它们的先后顺序执行。</p>
<p>​		第二个脚本文件可能会在第一个脚本文件之前执行。因此确保两者之间互不依赖非常重要。指定<code>async</code>属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。</p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>​		三次握手（Three-way Handshake）是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。主要作用就是为了确认双方的<strong>接收能力和发送能力</strong>是否正常、指定自己的<strong>初始化序列号</strong>为后面的可靠性传送做准备。</p>
<p>过程如下：</p>
<ul>
<li>第一次握手(<strong>SYN报文</strong>)：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态</li>
<li>第二次握手(<strong>ACK和SYN报文</strong>)：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态</li>
<li>第三次握手(<strong>ACK报文</strong>)：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接</li>
</ul>
<p>上述每一次握手的作用如下：</p>
<ul>
<li>第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</li>
<li>第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。<strong>不过此时服务器并不能确认客户端的接收能力是否正常</strong></li>
<li>第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常</li>
</ul>
<p>通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了</p>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p><code>tcp</code>终止一个连接，需要经过四次挥手</p>
<p>过程如下：</p>
<ul>
<li>第一次挥手：客户端发送一个 <strong>FIN 报文</strong>，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认</li>
<li>第二次挥手：服务端收到 FIN 之后，会发送 <strong>ACK 报文</strong>，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态</li>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 <strong>FIN 报文</strong>，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态</li>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 <strong>ACK 报文</strong>作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态</li>
</ul>
<h4 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h4><p>​		服务端在收到客户端断开连接<code>Fin</code>报文后，并不会立即关闭连接，而是先发送一个<code>ACK</code>包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送<code>FIN</code>报文断开连接，因此需要四次挥手。</p>
<h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><h4 id="是什么？-6"><a href="#是什么？-6" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		websocket是一种网络传输协议，位于OSI模型的应用层。可在<strong>单个TCP</strong>连接中进行<strong>全双工通信</strong>。客户端和服务器只需要完成<strong>一次握手</strong>，两者就能创建<strong>持久性的连接</strong>，并进行<strong>双向数据</strong>传递。</p>
<p>​		websocket是应用层协议，与HTTP同等的应用层协议，都基于TCP协议。他是一种双向通信协议，在建立连接之后，服务端和客户端都能主动向对方发送或接收数据。</p>
<p>​		WebSocket是HTML5提供的一种浏览器与服务器进行<strong>全双工通讯</strong>的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<p>​		WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是: 服务器可以向客户端主动推动消息客户端也可以主动向服务器推送消息。</p>
<p>​		WebSocket原理: 客户端向 WebSocket 服务器通知 (notify) 一个带有所有接收者ID (recipients IDs)的事件 (event)，服务器接收后立即通知所有活跃的 (active) 客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。</p>
<p>​		HTTP协议的缺点：通信只能由客户端发起。而websocket中，服务器可以向客户端推送信息，客户端也可以向服务器发送信息。</p>
<h4 id="克服轮询通信的缺点"><a href="#克服轮询通信的缺点" class="headerlink" title="克服轮询通信的缺点"></a>克服轮询通信的缺点</h4><p>​		在<code>websocket</code>出现之前，开发实时<code>web</code>应用的方式为轮询。需要不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果。轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 <code>CPU</code>资源。</p>
<h4 id="websocket与http的关系"><a href="#websocket与http的关系" class="headerlink" title="websocket与http的关系"></a>websocket与http的关系</h4><p><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/pic10.png" alt="关系"></p>
<h4 id="websocket与http的相同点和不同点"><a href="#websocket与http的相同点和不同点" class="headerlink" title="websocket与http的相同点和不同点"></a>websocket与http的相同点和不同点</h4><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><ul>
<li>都是基于tcp，都是可靠传输协议</li>
<li>都是应用层协议</li>
</ul>
<h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><ul>
<li>websocket是双向通信协议，可以双向发送或接收信息；http是单向的</li>
<li>websocket不需要客户端发起请求就能实现推送；http需要客户端发起请求，才能进行响应</li>
</ul>
<h4 id="总体过程"><a href="#总体过程" class="headerlink" title="总体过程"></a>总体过程</h4><p>​		<strong>总体过程：</strong>首先，客户端经过三次握手后，建立TCP连接。连接建立后，发起HTTP请求。HTTP请求里存放websocket支持的版本号等信息，如Upgrade等。然后，服务端收到客户端的握手请求后，同样采用HTTP协议回馈数据。最后，客户端收到连接成功的消息后，借助TCP传输信道进行全双工通信。</p>
<p>​		详细过程：当web应用调用new WebSocket(url)接口时，客户端就开始与地址为url的服务端建立握手连接的过程。</p>
<ol>
<li>浏览器与服务器通过TCP三次握手建立连接，如果这个连接失败，那么后面的过程都不会执行，浏览器将收到错误消息通知。</li>
<li>在TCP连接建立成功后，浏览器通过HTTP协议传送websocket支持的版本号、原始地址、主机地址等一系列字段给服务端。</li>
<li>websocket服务端收到浏览器端发送来的握手请求后，如果数据包数据和格式正确，客户端和服务端的协议版本匹配，就接受本次握手连接，并给出对应的数据回复，回复的数据包也是采用HTTP协议传输。</li>
<li>浏览器收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发onopen消息，浏览器就可以通过send接口向服务器发送数据。否则，握手失败，浏览器通过onerror就可以知道失败的原因。</li>
</ol>
<h4 id="特点-相比HTTP"><a href="#特点-相比HTTP" class="headerlink" title="特点(相比HTTP)"></a>特点(相比HTTP)</h4><ul>
<li>全双工</li>
<li>二进制帧。由于websocket侧重于实时通信，而HTTP侧重于提高传输效率，故两者帧结构有很大的区别。不存在HTTP2中的多路复用等特性。</li>
<li>协议名。引入ws和wss分别代表明文和密文websocket协议，且默认端口使用80或443，与HTTP一致。</li>
<li>只有一个握手过程。客户端connection必须设置为upgrade，upgrade必须设置为websocket。</li>
</ul>
<h4 id="请求字段与HTTP不同之处"><a href="#请求字段与HTTP不同之处" class="headerlink" title="请求字段与HTTP不同之处"></a>请求字段与HTTP不同之处</h4><p>​		“Upgrade: websocket”：表明这是一个websocket类型请求，意在告诉服务端需要将通信协议切换到websocket。</p>
<p>​		“Sec-WebSocket-Key”：是客户端发送一个base64编码的密文，要求服务端必须返回一个对应加密的”Sec-WebSocket-Accept”应答，否则客户端会抛出错误，并关闭连接。</p>
<p>​		服务端收到报文后，如果支持websocket协议，那么会将自己的通信协议切换到websocket，返回以下信息：</p>
<ul>
<li>“HTTP1.1 101 WebSocket Protocol Handshake”：返回状态码为101，表示同意客户端的协议切换请求</li>
<li>“Upgrade: websocket”</li>
<li>“Connection: upgrade”</li>
<li>“Sec-Websocket-Accept:*”</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部</li>
<li>更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少</li>
<li>保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证</li>
<li>更好的二进制支持：定义了二进制帧，更好处理二进制内容</li>
<li>支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议</li>
<li>更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li>
</ul>
<h4 id="websocket应用场景"><a href="#websocket应用场景" class="headerlink" title="websocket应用场景"></a>websocket应用场景</h4><ul>
<li>弹幕</li>
<li>媒体聊天</li>
<li>协同编辑</li>
<li>基于位置的应用</li>
<li>体育实况更新</li>
<li>股票基金报价实时更新</li>
</ul>
<h4 id="websocket心跳"><a href="#websocket心跳" class="headerlink" title="websocket心跳"></a>websocket心跳</h4><h5 id="什么是心跳"><a href="#什么是心跳" class="headerlink" title="什么是心跳"></a>什么是心跳</h5><p>​		心跳是客户端定时给服务端发送消息，证明客户端是在线的，如果超过一定时间没有发送则是离线了。</p>
<h5 id="判断离线在线"><a href="#判断离线在线" class="headerlink" title="判断离线在线"></a>判断离线在线</h5><p>​		当客户端第一次发送请求至服务器端时会携带唯一标识以及时间戳，服务端到数据库或缓存中查询该请求的唯一标识，如果不存在则存入数据库或缓存中。</p>
<p>​		当客户端第二次发送请求时，携带之前的唯一标识以及时间戳，服务器去数据库或缓存中查询该请求的唯一标识，如果存在则把上次的时间戳拿出来，使用当前时间戳减去上去的时间，得到的毫秒数如果大于指定时间的话，就是离线，否则是在线。</p>
<h5 id="若服务端宕机，客户端怎么做、服务端再次上线呢？"><a href="#若服务端宕机，客户端怎么做、服务端再次上线呢？" class="headerlink" title="若服务端宕机，客户端怎么做、服务端再次上线呢？"></a>若服务端宕机，客户端怎么做、服务端再次上线呢？</h5><p>​		服务端宕机时，客户端需要断开连接，通过onclose关闭连接。服务端再次上线时则需要清除之前的数据，若不清除，则请求到达服务端时会被认为是离线。</p>
<h5 id="心跳检测、websocket连接"><a href="#心跳检测、websocket连接" class="headerlink" title="心跳检测、websocket连接"></a>心跳检测、websocket连接</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socket; <span class="comment">//websocket的实例</span></span><br><span class="line"><span class="keyword">var</span> lockReconnect = <span class="literal">false</span>; <span class="comment">//避免重复连接</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getwebsocket</span>(<span class="params"></span>) &#123; <span class="comment">//新建websocket的函数 页面初始化 断开连接时重新调用</span></span><br><span class="line">    <span class="keyword">var</span> wsUrl = <span class="string">&#x27;ws://10.200.101.121:9001/websocket?wsToken=&#x27;</span> + <span class="variable language_">window</span>.<span class="property">token</span> + <span class="string">&#x27;&amp;djxh=&#x27;</span> + <span class="variable language_">window</span>.<span class="property">djxh</span>;</span><br><span class="line">    socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(wsUrl);</span><br><span class="line">    socket.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="comment">//console.log(&#x27;websocket服务出错了&#x27;);</span></span><br><span class="line">        <span class="title function_">reconnect</span>(wsUrl);</span><br><span class="line">    &#125;;</span><br><span class="line">    socket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="comment">//console.log(&#x27;websocket服务关闭了&#x27;);</span></span><br><span class="line">        <span class="title function_">reconnect</span>(wsUrl);</span><br><span class="line">    &#125;;</span><br><span class="line">    socket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">        heartCheck.<span class="title function_">reset</span>().<span class="title function_">start</span>(); <span class="comment">//传递信息</span></span><br><span class="line">    &#125;;</span><br><span class="line">    socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="comment">//如果获取到消息，心跳检测重置</span></span><br><span class="line">        <span class="comment">//拿到任何消息都说明当前连接是正常的</span></span><br><span class="line">        <span class="comment">//console.log(&#x27;websocket服务获得数据了&#x27;);</span></span><br><span class="line">        <span class="comment">//接受消息后的UI变化</span></span><br><span class="line">        <span class="title function_">doWithMsg</span>(event.<span class="property">data</span>);</span><br><span class="line">        heartCheck.<span class="title function_">reset</span>().<span class="title function_">start</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//收到消息推送</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">doWithMsg</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">        <span class="title function_">getdjxh</span>() <span class="comment">//这个函数是业务上面申请列表的函数 可以忽略</span></span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">external</span>.<span class="title class_">CallFun</span>(<span class="string">&#x27;receiveMsg&#x27;</span>); <span class="comment">//这个也是</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重新链接</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reconnect</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lockReconnect) <span class="keyword">return</span>;</span><br><span class="line">    lockReconnect = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//没连接上会一直重连，设置延迟避免请求过多</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">getwebsocket</span>();</span><br><span class="line">        lockReconnect = <span class="literal">false</span>;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//心跳检测</span></span><br><span class="line"><span class="keyword">var</span> heartCheck = &#123;</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">60000</span>, <span class="comment">//60秒</span></span><br><span class="line">    <span class="attr">timeoutObj</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">serverTimeoutObj</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">reset</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">timeoutObj</span>);</span><br><span class="line">        <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">serverTimeoutObj</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">start</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">timeoutObj</span> = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">//这里发送一个心跳，后端收到后，返回一个心跳消息，</span></span><br><span class="line">            <span class="comment">//onmessage拿到返回的心跳就说明连接正常</span></span><br><span class="line">            socket.<span class="title function_">send</span>(<span class="string">&quot;心跳测试&quot;</span>);</span><br><span class="line">            <span class="comment">//如果超过一定时间还没重置，说明后端主动断开了</span></span><br><span class="line">            self.<span class="property">serverTimeoutObj</span> = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">              <span class="comment">//如果onclose会执行reconnect，我们执行ws.close()就行了.</span></span><br><span class="line">              <span class="comment">//如果直接执行reconnect 会触发onclose导致重连两次</span></span><br><span class="line">              socket.<span class="title function_">close</span>(); </span><br><span class="line">            &#125;, self.<span class="property">timeout</span>)</span><br><span class="line">        &#125;, <span class="variable language_">this</span>.<span class="property">timeout</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维码扫码登录原理"><a href="#二维码扫码登录原理" class="headerlink" title="二维码扫码登录原理"></a>二维码扫码登录原理</h3><p>​		扫码登录本质是将APP端的用户登录信息（通常是Token）通过扫码的形式安全稳定地同步给web端。</p>
<ol>
<li>用户打开 Web 端网页，进入扫码登录的界面:</li>
<li>从 Web 端服务器获取二维码的图并获取其状态</li>
<li>Web 端服务器在生成二维码时，会生成一个 uuid 和二维码进行关联，并将 uuid 存入 db 记录中</li>
<li>用户打开 APP 端，对着二维码进行扫码授权操作;</li>
<li>APP 客户端从二维码中读取到 uuid，带着 APP 内的身份信息访问 APP 端服务器</li>
<li>APP 端服务器获取到用户的身份信息后，将用户 id 更新到 db 中对应 uuid 的记录中，此时 Web 服务器就能拿到对应的用户 id，之后生成登录身份信息返回给浏览器，即用户在 Web 端完成了登录</li>
</ol>
<h3 id="多次异步请求同一个接口，结果返回的顺序问题"><a href="#多次异步请求同一个接口，结果返回的顺序问题" class="headerlink" title="多次异步请求同一个接口，结果返回的顺序问题"></a><strong>多次异步请求同一个接口，结果返回的顺序问题</strong></h3><pre><code>  异步请求返回顺序依赖网络，无法控制，所以每次请求的时长不一致，也就是不能保证请求返回顺序。
</code></pre>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h5><p>​		在前端定义一个全局变量，记录请求次数的标识符，并把这个标识符带上传给后端，在aiax的回调中也返回过来，判断全局变量的值是否等于该标识符，如果等于就肯定是最后一次发起的请求，然后再渲染页面。</p>
<h3 id="跨域（与前后端无关，与浏览器有关）"><a href="#跨域（与前后端无关，与浏览器有关）" class="headerlink" title="跨域（与前后端无关，与浏览器有关）"></a>跨域<strong>（与前后端无关，与浏览器有关）</strong></h3><h4 id="跨域请求发生的时间"><a href="#跨域请求发生的时间" class="headerlink" title="跨域请求发生的时间"></a>跨域请求发生的时间</h4><pre><code>  跨域不是指浏览器不会发出请求，也不是指服务器没有发送响应结果；而是浏览器成功发出请求，服务器也成功接受请求，也成功把响应结果返回了。只是浏览器在接受资源的时候，进行了拦截。因此，**跨域发生在浏览器对请求结果的响应阶段。**
</code></pre>
<h4 id="是什么？-7"><a href="#是什么？-7" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		浏览器允许向服务器发送跨域请求。同源策略：协议+域名+端口相同。</p>
<h4 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h4><h5 id="JSONP跨域"><a href="#JSONP跨域" class="headerlink" title="JSONP跨域"></a>JSONP跨域</h5><p>原理：</p>
<p>​		利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的<strong>GET</strong>请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    script.<span class="property">type</span> = <span class="string">&#x27;text/javascript&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    script.<span class="property">src</span> = <span class="string">&quot;http://www.baidu.com:8080/login?user=admin&amp;callback=handleCallback&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">handleCallback</span>(<span class="params">res</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(res));</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>缺点：只能发送GET一种请求。</p>
<h5 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h5><p>​		浏览器是否拦截响应请求取决于服务器。服务器明确表示允许响应就响应，服务器表示拒绝响应或者不作表示，就拦截请求。</p>
<p>​		CORS将所有请求分为简单请求和预检请求。简单请求需满足以下条件，除此之外都是预检请求：</p>
<ol>
<li>请求方法为get、head、post</li>
<li>Content-Type为下面三种之一<ol>
<li>text&#x2F;plain</li>
<li>multipart&#x2F;form-data</li>
<li>application&#x2F;x-www-form-urlencoded</li>
</ol>
</li>
</ol>
<p>​		对于<strong>简单请求</strong>，在发送请求的时候，浏览器会带上当前的源地址（协议+域名+端口号），服务器端只需要在收到请求后，发送的响应信息中，在**<code>Access-Control-Allow-Origin</code>**这个字段中，将它设置为和当前源地址相同。浏览器收到响应信息后，会检查这个字段，如果与当前源地址相同，就不再进行拦截。</p>
<p>​		对于<strong>预检请求</strong>，浏览器在发送请求前，会发送一个前置请求，请求类型为options，同时携带下面三个参数，表示真实要发送的请求类型和内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /api/user HTTP/2.1</span><br><span class="line"></span><br><span class="line">Origin: http://example.com</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: a, b, content-type</span><br></pre></td></tr></table></figure>

<p>​		服务器端在收到前置请求后，会在响应中添加如下字段。浏览器在收到前置请求的响应后，根据字段判断，如果允许的源地址和当前地址相同，则会再发送真实请求完成通信，并且浏览器会将该响应缓存，并且在Max-Age缓存起来，在该时间内不再发送预先请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 0kDate: Tue, 21 Apr 2029 88:83:85 GHT</span><br><span class="line"></span><br><span class="line">Access-Control-Allow-Origin: http://example.com //表示允许跨域的源地址</span><br><span class="line">Access-Control-Allow-Methods: POST //表示允许的请求方法</span><br><span class="line">Access-Control-Allow-Headersala, b, content-type //表示允许的请求头</span><br><span class="line">Access-Control-Max-Age: 86408 //在86408秒内，对该请求不再做检查，浏览器不需要再发前置请求</span><br></pre></td></tr></table></figure>

<h5 id="nodejs中间件代理跨域"><a href="#nodejs中间件代理跨域" class="headerlink" title="nodejs中间件代理跨域"></a>nodejs中间件代理跨域</h5><p>​		开启代理服务器，实现数据的转发。利用http-proxy-middleware这个中间件，相当于浏览器与服务端中添加一个代理者。当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地。<strong>服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制。</strong></p>
<p><strong>代理种类</strong></p>
<ul>
<li>正向代理</li>
</ul>
<p>​		客户端向代理服务器发送请求并指定目标（目标服务器），然后代理向目标服务器转交请求并将获得的内容返回给客户端。客户端一般必须进行一些特别的设置才能使用正向代理。一般使用webpack的proxy来进行。</p>
<p>​		正向代理是对客户端的代理，由客户端设立，客户端了解代理服务器和目标服务器，但目标服务器不了解真正的客户端是谁；使用正向代理可达到突破访问限制、提高访问速度、对服务器隐藏客户端IP等目的。</p>
<ul>
<li>反向代理</li>
</ul>
<p>​		反向代理是指以代理服务器来接受请求，然后将请求转发给内部网络上的服务器，将返回的结果传递给客户端，此时代理服务器对外表现为一个服务器。</p>
<p>​		反向代理是对服务器的代理，由服务器设立，客户端不了解真正的服务器是谁，使用反向代理可达到负载均衡、保障服务端安全、对客户端隐藏服务器IP等目的。</p>
<h5 id="window-name-iframe"><a href="#window-name-iframe" class="headerlink" title="window.name+iframe"></a>window.name+iframe</h5><p>原理：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。window.name属性的特点：当前页设置的值，在页面重新加载(非同域也可以)后，值依然不变。</p>
<ul>
<li>a.html: <code>http://www.domain1.com/a.html</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">function</span>(<span class="params">url,  callback</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">    <span class="comment">// 加载跨域页面</span></span><br><span class="line">    iframe.<span class="property">src</span> = url;</span><br><span class="line">    <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">    iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(state===<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span></span><br><span class="line">            <span class="title function_">callback</span>(iframe.<span class="property">contentWindow</span>.<span class="property">name</span>);</span><br><span class="line">            <span class="title function_">destroyFrame</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state === <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">            iframe.<span class="property">contentWindow</span>.<span class="property">location</span> = <span class="string">&#x27;http://www.domain1.com/proxy.html&#x27;</span>;</span><br><span class="line">            state =<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(iframe);</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">destoryFrame</span>(<span class="params"></span>)&#123;</span><br><span class="line">        iframe.<span class="property">contentWindow</span>.<span class="property">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        iframe.<span class="property">contentWindow</span>.<span class="title function_">close</span>();</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">proxy</span>(<span class="string">&#x27;http://www.domain2.com/b.html&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>proxy.html: <code>http://www.domain1.com/proxy.html</code></li>
</ul>
<p>中间代理页，与a.html同域，内容为空</p>
<ul>
<li>b.html：<code>http://www.domain2.com/b.html</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;this is domain2 data&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="postMessage跨域-iframe"><a href="#postMessage跨域-iframe" class="headerlink" title="postMessage跨域+iframe"></a>postMessage跨域+iframe</h5><p>​		postMessage可以用于解决：1.页面和其新打开的窗口进行数据传递；2.多窗口之间消息传递；3.页面与嵌套的iframe消息传递；4.上面三个场景的跨域数据传递。</p>
<p>​		用法：postMessage(data, origin)。data: html5规范支持任意基本类型或可复制的对象。origin: 协议+主机+端口。</p>
<ul>
<li>a.html: <code>http://www.domain1.com/a.html</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> data = &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>: <span class="string">&#x27;aaa&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data), <span class="string">&#x27;http://www.domain2.com&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;data from domain2: &#x27;</span>+e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>b.html: <code>http://www.domain2.com/b.html</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;data from domain1: &#x27;</span>+e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> data = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(data)&#123;</span></span><br><span class="line"><span class="language-javascript">            data.<span class="property">number</span> = <span class="number">16</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="title function_">postMessage</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data), <span class="string">&#x27;http://www.domain1.com&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="线程进程协程"><a href="#线程进程协程" class="headerlink" title="线程进程协程"></a>线程进程协程</h3><ul>
<li>进程是分配资源的基本单位。进程是一段程序的执行过程，拥有代码和打开的文件资源、数据资源、独立的内存空间。</li>
<li>线程是调度和分配的基本单位。线程共享所在进程中的内存空间。</li>
<li>协程是一种用户态的轻量级线程，协程的调度完全由用户控制，而进程和线程是由CPU内核进行调度的。</li>
</ul>
<h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><ul>
<li>管道通信。操作系统在内核中开辟一段缓冲区，进程1可以将需要交互的数据拷贝到这个缓冲区中，进程2就可以读取。数据有最大长度限制。</li>
<li>消息队列通信。消息队列就是用户可以添加和读取消息的列表，消息队列里提供了一种从一个进程向另一个进程发送数据块的方法，但是与管道通信一样每个数据块都有最大长度限制。</li>
<li>共享内存通信。由一个进程创建一段能被其他进程访问的内存，多个进程都可以访问，共享进程最快的是信号量通信方式。</li>
<li>socket。以上几种都是在同一主机之间的进程通信方式，不同主机之间进程方式为socket通信。</li>
</ul>
<h3 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h3><p>​		浏览器从关闭到开启，打开一个新页面最少需要：1个浏览器进程，1个GPU进程，1个网络进程，1个渲染进程。</p>
<p>​		如果后续再打开新标签的话，浏览器进程、GPU进程、网络进程是共享的，不会重新启动。如果新打开的标签页与当前标签页属于同一个站点，则共用一个渲染进程；否则新创建一个渲染进程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 浏览器进程：负责控制浏览器除标签页外的页面，包括地址栏、书签、前进后退按钮等，以及负责与其他进程的协调工作，同时提供存储功能。</span><br><span class="line">- GPU进程：负责整个浏览器界面的渲染。</span><br><span class="line">- 网络进程：负责发起和接受网络请求。</span><br><span class="line">- 渲染进程：负责控制显示tab标签页内的所有内容，核心任务是将HTML、CSS、JS转为用户可以与之交互的网页，浏览器引擎Blink和JS引擎V8都运行在该进程中。</span><br></pre></td></tr></table></figure>

<h3 id="浏览器线程"><a href="#浏览器线程" class="headerlink" title="浏览器线程"></a>浏览器线程</h3><ul>
<li>GUI线程。负责渲染浏览器界面，解析HTML、CSS、构建DOOM树等。GUI线程与JS线程是互斥的。</li>
<li>JS线程。负责处理JS脚本。</li>
<li>事件触发线程。归属于浏览器，用于控制事件循环。</li>
<li>异步HTTP请求线程。XMLHttpRequest在连接后是通过浏览器新开一个线程请求的。</li>
</ul>
<h3 id="手写JSONP"><a href="#手写JSONP" class="headerlink" title="手写JSONP"></a>手写JSONP</h3><h4 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h4><ol>
<li><p>定义jsonp函数，传入参数为url，请求携带参数params，回调函数callbackName</p>
</li>
<li><p>jsonp函数内部需要完成两件事情，一是拼接url、params和callbackName为完整路径；二是返回一个promise；</p>
</li>
<li><p>promise中完成jsonp跨域</p>
<p>1)创建一个script标签</p>
<p>2)将拼接好的url设置为script标签的src属性</p>
<p>3)将script标签添加到dom中</p>
<p>4)处理callback执行结果，请求成功后删除添加的script</p>
</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">&#123;url, params, callbackName&#125;</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getUrl</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> datasrc = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> params)&#123;</span><br><span class="line">            <span class="keyword">if</span>(params.<span class="title function_">hasOwnProperty</span>(key))</span><br><span class="line">                datasrc += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span></span><br><span class="line">        &#125;</span><br><span class="line">        datasrc += <span class="string">`callBack=<span class="subst">$&#123;callbackName&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;datasrc&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> scriptEle = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">        scriptEle.<span class="property">src</span> = getUrl;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(scriptEle);</span><br><span class="line">        <span class="variable language_">window</span>[callbackName] = <span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="title function_">resolve</span>(data);</span><br><span class="line">            <span class="variable language_">document</span>.<span class="title function_">removeChild</span>(scriptEle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="浏览器缓存的位置"><a href="#浏览器缓存的位置" class="headerlink" title="浏览器缓存的位置"></a><strong>浏览器缓存的位置</strong></h4><pre><code>  浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识，浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。浏览器缓存通过HTTP/HTTPS实现，存储位置有以下四种：
</code></pre>
<ul>
<li><p>Service Worker：运行在浏览器背后的独立线程，可以用来实现缓存功能，但是传输协议必须为https</p>
</li>
<li><p>Memory Cache(内存缓存)：存放在内存中的缓存</p>
</li>
<li><p>Disk Cache(硬盘缓存)：存在硬盘中的缓存</p>
</li>
<li><p>Push Cache(推送缓存)：http2中的内容，会话结束就会消失</p>
</li>
<li><p>以上缓存全部没有命中就进行网络请求</p>
</li>
</ul>
<p>get和post发送几次数据</p>
<ul>
<li>get：浏览器会把http header和data一并发送出去，服务器响应200</li>
<li>post：浏览器先发送header，服务器响应100 continue，浏览器再发送数据，服务器响应200 ok</li>
</ul>
<p>​		在实际WEB开发过程中，缓存技术会涉及到不同层、不同端，比如: 用户层、系统层、代理层、前端后端、服务端等，<strong>每一层的缓存目标都是一致的，就是尽快返回请求数据、减少延迟</strong>，但每层使用的技术实现是各有不同，面对不同层、不同端的优劣，选用不同的技术来提升系统响应效率。下面给出一个整个WEB缓存知识体系:</p>
<p><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/%E7%BC%93%E5%AD%98%E4%BD%93%E7%B3%BB.png" alt="web缓存体系"></p>
<h4 id="浏览器是否使用缓存由谁决定"><a href="#浏览器是否使用缓存由谁决定" class="headerlink" title="浏览器是否使用缓存由谁决定"></a><strong>浏览器是否使用缓存由谁决定</strong></h4><pre><code>  浏览器是否使用缓存、缓存多久，**全部是由后端服务器控制的**。准确来说，当浏览器请求一个网页(或者其他资源)时，**服务器发回响应的[响应头] 部分的某些字段指明了有关缓存的关键信息**。下面给出了HTTP报文中与缓存相关的首部字段:
</code></pre>
<p><img src="file:///C:/Users/pigpi/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p>
<h4 id="HTTP版本是前端控制还是后端控制？"><a href="#HTTP版本是前端控制还是后端控制？" class="headerlink" title="HTTP版本是前端控制还是后端控制？"></a><strong>HTTP版本是前端控制还是后端控制？</strong></h4><p>​		请求发生时具体使用的版本是由客户端主导、客户端和服务器共同协商决定的。</p>
<h4 id="浏览器渲染页面的过程与原理"><a href="#浏览器渲染页面的过程与原理" class="headerlink" title="浏览器渲染页面的过程与原理"></a><strong>浏览器渲染页面的过程与原理</strong></h4><pre><code>  当浏览器的网络线程收到**HTML文档**后，会产生一个渲染任务，并将其传递给**渲染主线程**的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。

  整个渲染流程分为多个阶段，分别是:**HTML解析、样式计算、布局、分层、生成绘制指令、分块、光栅化、画。**

  每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入这样，整个渲染流程就形成了一套组织严容的生产流水线。

  在浏览器URL中输入一个地址，浏览器接收到的是一个HTML文件，而HTML文件实际上是一个很长很长很长的字符串。
</code></pre>
<p><strong>渲染第一步解析HTML代码(渲染主线程)</strong></p>
<p>​		渲染的第一步是解析HTML，也就是解析巨长的字符串。</p>
<ul>
<li>解析过程中遇到CSS解析CSS，遇到JS 执行JS。为了提高解析效率，浏览器在开始解祈前，会启动一个<strong>预解析的线程</strong>，率先下载HTML中的外部CSS文件和外部的JS文件。</li>
<li>如果主线程解析到link标签，此时外部的CSS文件还没有下载解析好，主线程不会等待，继续解析后续的HTML，<strong>因为下载和解析CSS的工作是在预解析线程中进行的。这就是CSS不会阻塞HTML解析的根本原因。</strong></li>
<li>如果主线程解析到script标签，会停止解析HTML，转而等待]S文件下载好，并将全局代码解析执行完成后，才能继续解析HTML。这是<strong>因为JS代码的执行过程可能会修改当前的DOM树，所以DOM树的生成必须暂停。这就是JS会阻塞HTML解析的根本原因。</strong></li>
<li>第一步完成后，会得到DOM (document object modal，文本对象模型)树和CSSOM (Cascading StyleSheets obiect modal，层叠样式表对象模型)树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在CSSOM树中。</li>
</ul>
<p><strong>渲染第二步样式计算(渲染主线程)</strong></p>
<ul>
<li>主线程会遍历得到的DOM树，依次为树中的每个节点计算出它最终的样式，称之为Computed Style.</li>
<li>在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)，相对单位会变成绝对单位，比如em会变成px。</li>
<li>这一步完成后，会得到一棵带有样式的DOM树</li>
</ul>
<p><strong>渲染第三步布局(渲染主线程)</strong></p>
<ul>
<li>布局阶段会依次遍历DOM树的每一个节点，计算每个节点的几何信息，所谓几何信息，指的是每个DOM元素的尺寸和位置。例如节点的宽高，相对包含块的位置。</li>
<li>大部分时候,<strong>DOM树和布局树并非一一对应</strong>。有些元素不在DOM树中但在布局树中，例如::before伪元素、::after伪元素不在DOM树中，但它们拥有几何信息，因此会生成到布局树中;有些元素既不在DOM树也不在布局树，如: display:none 的节点没有几何信息，因此不会生成到布局树。还有匿名行盒、匿名块盒等等都会导致DOM树和布局树无法一一对应。布局完成后会得到布局树(Layout) 。</li>
</ul>
<p><strong>渲染第四步分层(渲染主线程)</strong></p>
<ul>
<li>主线程会使用一套复杂的策略对整个布局树中进行分层。分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率.</li>
<li>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过 will-change属性更大程度的影响分层结果。</li>
</ul>
<p><strong>渲染第五步生成绘制指令(渲染主线程)</strong></p>
<ul>
<li>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来.注意，这一步并不是真的开始绘制，而是生成绘制指令。例如: 将画笔移动到坐标点(10,20) ，画一个20*20的div盒，背景色为红色，边框为1px。</li>
</ul>
<p>​		至此，渲染主线程的任务完成。渲染主线程执行了5个步骤，解析HTML，样式计算，布局，分层，生成绘制指令。后续的任务将由其他线程继续完成。</p>
<p><strong>渲染第六步–分块</strong></p>
<ul>
<li>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成合成线程首先对每个图层进行分块，将其划分为更多的小区域。它会从线程池中拿取多个线程来完成分块工作。</li>
</ul>
<p><strong>渲染第七步–光栅化</strong></p>
<ul>
<li>分块完成后，进入光栅化阶段。光栅化是在GPU中进行的</li>
<li>合成线程会将块信息交给GPU进程启用GPU加速，调用显卡的功能，以极高的速度完成光栅化。</li>
<li>GPU进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。光栅化的结果，就是一块块的位图 (即页面上每个像素点的颜色)。它会优先处理靠近窗口视图的块。</li>
</ul>
<p><strong>渲染第八步画</strong></p>
<ul>
<li>最后一个阶段就是画了</li>
<li>合成线程拿到每个层、每个块的位图后，生成一个个[指引(quad) 信息。指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</li>
<li>变形发生在合成线程，与渲染主线程无关，这是transform效率高(因为它不发生在渲染主线程)的本质原因。</li>
<li>合成线程会把 quad 提交给GPU进程，由GPU进程产生系统调用，提交给GPU硬件，完成最终的屏幕成像。</li>
</ul>
<p><strong>渲染总结</strong></p>
<ul>
<li>当浏览器的网络线程收到HTML文档后，会产生一个渲染任务，并将其传递给<strong>渲染主线程</strong>的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</li>
<li>渲染流程开启后首先解析HTML文档，解析完成后会得到<strong>DOM树和CSSOM树;<strong>然后通过样式计算将DOM树上的节点和其在CSSOM树上的样式建立映射关系，形成</strong>带有样式的DOM树</strong>，然后遍历这个DOM树的每一个节点，计算每个节点的几何信息，生成**布局树:**然后进行分层操作，提升渲染效率:然后会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来，最后，再经过分块，光栅化等操作，将控制权交由GPU，生成一块一块的位图，最终由GPU进程产生系统调用，提交给GPU硬件，完成最终的屏幕成像。</li>
</ul>
<p><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png" alt="渲染流程"></p>
<p>​	<strong>页面重排的本质是重新计算布局树</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://cheyennee.github.io">Cheyennee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://cheyennee.github.io/2021/07/06/HTTP/">http://cheyennee.github.io/2021/07/06/HTTP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cheyennee.github.io" target="_blank">Cheyennee</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/18/react/"><img class="prev-cover" src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">react</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/06/flex/"><img class="next-cover" src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/flex/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">flex</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cheyennee</div><div class="author-info__description">生而为人，还请努力</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cheyennee"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">在路上</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFHTTP%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是HTTP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS"><span class="toc-number">2.</span> <span class="toc-text">HTTPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E9%93%BE%E6%8E%A5%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">HTTPS链接的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">HTTP与HTTPS的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">HTTPS是如何保证安全的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSL%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%BA%9B%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">SSL实现这些功能的方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E7%9A%84TLS%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">7.</span> <span class="toc-text">HTTPS的TLS四次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%8EUDP"><span class="toc-number">8.</span> <span class="toc-text">TCP与UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP"><span class="toc-number">8.1.</span> <span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E7%89%B9%E7%82%B9"><span class="toc-number">8.2.</span> <span class="toc-text">UDP特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">8.3.</span> <span class="toc-text">UDP如何实现可靠传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP"><span class="toc-number">8.4.</span> <span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E7%89%B9%E7%82%B9"><span class="toc-number">8.5.</span> <span class="toc-text">TCP特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AE%89%E5%85%A8"><span class="toc-number">8.6.</span> <span class="toc-text">TCP如何保障自己的安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E4%B8%8ETCP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.7.</span> <span class="toc-text">UDP与TCP的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E4%B8%8EUDP%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.8.</span> <span class="toc-text">TCP与UDP的应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.9.</span> <span class="toc-text">拥塞控制和流量控制的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%98%E5%8C%85"><span class="toc-number">8.10.</span> <span class="toc-text">粘包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AB%E4%B9%89"><span class="toc-number">8.10.1.</span> <span class="toc-text">含义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">8.10.2.</span> <span class="toc-text">产生的原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85"><span class="toc-number">8.10.3.</span> <span class="toc-text">如何解决粘包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">OSI七层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">9.1.</span> <span class="toc-text">应用层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BA%E5%B1%82"><span class="toc-number">9.2.</span> <span class="toc-text">表示层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E5%B1%82"><span class="toc-number">9.3.</span> <span class="toc-text">会话层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">9.4.</span> <span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">9.5.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">9.6.</span> <span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">9.7.</span> <span class="toc-text">物理层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-x2F-IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">10.</span> <span class="toc-text">TCP&#x2F;IP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%92%E5%88%86"><span class="toc-number">10.2.</span> <span class="toc-text">划分</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB"><span class="toc-number">10.2.1.</span> <span class="toc-text">五层体系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%9B%E5%B1%82%E4%BD%93%E7%B3%BB"><span class="toc-number">10.2.2.</span> <span class="toc-text">四层体系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E4%B8%8ETCP-x2F-IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.3.</span> <span class="toc-text">OSI参考模型与TCP&#x2F;IP参考模型的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E5%8D%8F%E8%AE%AE"><span class="toc-number">11.</span> <span class="toc-text">DNS协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-1"><span class="toc-number">11.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D"><span class="toc-number">11.2.</span> <span class="toc-text">域名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">11.3.</span> <span class="toc-text">DNS查询方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E7%BC%93%E5%AD%98"><span class="toc-number">11.4.</span> <span class="toc-text">域名缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">11.5.</span> <span class="toc-text">DNS查询过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDN"><span class="toc-number">12.</span> <span class="toc-text">CDN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-2"><span class="toc-number">12.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">12.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">12.2.1.</span> <span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BB%A3%E7%90%86"><span class="toc-number">12.2.2.</span> <span class="toc-text">缓存代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-0-x2F-1-1-x2F-2-0"><span class="toc-number">13.</span> <span class="toc-text">HTTP1.0&#x2F;1.1&#x2F;2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-0%EF%BC%88%E6%97%A0%E8%BF%9E%E6%8E%A5%E3%80%81%E6%97%A0%E7%8A%B6%E6%80%81%E3%80%81%E4%B8%80%E6%AC%A1%E8%BF%9E%E6%8E%A5%E5%8F%AA%E8%83%BD%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%EF%BC%89"><span class="toc-number">13.1.</span> <span class="toc-text">HTTP 1.0（无连接、无状态、一次连接只能完成一个请求）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-1-1%EF%BC%88%E4%B8%80%E4%B8%AA%E8%BF%9E%E6%8E%A5%E8%83%BD%E5%AE%8C%E6%88%90%E5%A4%9A%E4%B8%AA%E8%AF%B7%E6%B1%82%EF%BC%89"><span class="toc-number">13.2.</span> <span class="toc-text">HTTP 1.1（一个连接能完成多个请求）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-2-0"><span class="toc-number">13.3.</span> <span class="toc-text">HTTP 2.0</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">13.3.1.</span> <span class="toc-text">多路复用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7"><span class="toc-number">13.3.2.</span> <span class="toc-text">二进制分帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A6%96%E9%83%A8%E5%8E%8B%E7%BC%A9"><span class="toc-number">13.3.3.</span> <span class="toc-text">首部压缩</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81"><span class="toc-number">13.3.4.</span> <span class="toc-text">服务器推送</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">14.</span> <span class="toc-text">常见的HTTP状态码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-3"><span class="toc-number">14.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">14.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">14.3.</span> <span class="toc-text">常见的状态码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET%E5%92%8CPOST"><span class="toc-number">15.</span> <span class="toc-text">GET和POST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-4"><span class="toc-number">15.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">15.2.</span> <span class="toc-text">相同点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">15.3.</span> <span class="toc-text">区别：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">16.</span> <span class="toc-text">副作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">16.1.</span> <span class="toc-text">函数副作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="toc-number">16.2.</span> <span class="toc-text">纯函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-number">17.</span> <span class="toc-text">HTTP请求方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-number">18.</span> <span class="toc-text">HTTP请求头</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-5"><span class="toc-number">18.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-number">18.2.</span> <span class="toc-text">常见请求头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="toc-number">18.3.</span> <span class="toc-text">浏览器缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98-HTTP304"><span class="toc-number">18.3.1.</span> <span class="toc-text">协商缓存 HTTP304</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98"><span class="toc-number">18.3.2.</span> <span class="toc-text">强制缓存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E4%B8%8E%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">18.4.</span> <span class="toc-text">协商缓存与强制缓存的使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie"><span class="toc-number">19.</span> <span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">20.</span> <span class="toc-text">cookie和session的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cookie%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">20.0.1.</span> <span class="toc-text">cookie的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">20.0.2.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8Bcookie%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">20.0.3.</span> <span class="toc-text">建立cookie的过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#token%E5%92%8Ccookie%E7%9A%84%E7%9B%B8%E5%90%8C%E7%82%B9%E5%92%8C%E5%BC%82%E5%90%8C%E7%82%B9"><span class="toc-number">21.</span> <span class="toc-text">token和cookie的相同点和异同点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C"><span class="toc-number">21.0.1.</span> <span class="toc-text">相同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%90%8C"><span class="toc-number">21.0.2.</span> <span class="toc-text">异同</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E6%95%B2%E4%B8%8B%E5%9B%9E%E8%BD%A6%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">地址栏输入URL敲下回车后发生了什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90"><span class="toc-number">22.1.</span> <span class="toc-text">简单分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URL%E8%A7%A3%E6%9E%90"><span class="toc-number">22.2.</span> <span class="toc-text">URL解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E6%9F%A5%E8%AF%A2"><span class="toc-number">22.3.</span> <span class="toc-text">DNS查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5"><span class="toc-number">22.4.</span> <span class="toc-text">TCP连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82"><span class="toc-number">22.5.</span> <span class="toc-text">HTTP请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E8%AF%B7%E6%B1%82"><span class="toc-number">22.6.</span> <span class="toc-text">响应请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93"><span class="toc-number">22.7.</span> <span class="toc-text">页面渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BADOM%E6%A0%91"><span class="toc-number">22.7.1.</span> <span class="toc-text">构建DOM树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BACSS%E8%A7%84%E5%88%99%E6%A0%91"><span class="toc-number">22.7.2.</span> <span class="toc-text">构建CSS规则树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%B8%B2%E6%9F%93%E6%A0%91"><span class="toc-number">22.7.3.</span> <span class="toc-text">构建渲染树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">22.7.4.</span> <span class="toc-text">JS解析过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#defer"><span class="toc-number">22.7.5.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#async"><span class="toc-number">22.7.6.</span> <span class="toc-text">async</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">23.</span> <span class="toc-text">TCP三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">24.</span> <span class="toc-text">TCP四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">24.1.</span> <span class="toc-text">四次挥手的原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#websocket"><span class="toc-number">25.</span> <span class="toc-text">websocket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-6"><span class="toc-number">25.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8B%E6%9C%8D%E8%BD%AE%E8%AF%A2%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">25.2.</span> <span class="toc-text">克服轮询通信的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#websocket%E4%B8%8Ehttp%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">25.3.</span> <span class="toc-text">websocket与http的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#websocket%E4%B8%8Ehttp%E7%9A%84%E7%9B%B8%E5%90%8C%E7%82%B9%E5%92%8C%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">25.4.</span> <span class="toc-text">websocket与http的相同点和不同点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-number">25.4.1.</span> <span class="toc-text">相同点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">25.4.2.</span> <span class="toc-text">不同点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-number">25.5.</span> <span class="toc-text">总体过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-%E7%9B%B8%E6%AF%94HTTP"><span class="toc-number">25.6.</span> <span class="toc-text">特点(相比HTTP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%AD%97%E6%AE%B5%E4%B8%8EHTTP%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">25.7.</span> <span class="toc-text">请求字段与HTTP不同之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">25.8.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#websocket%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">25.9.</span> <span class="toc-text">websocket应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#websocket%E5%BF%83%E8%B7%B3"><span class="toc-number">25.10.</span> <span class="toc-text">websocket心跳</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%83%E8%B7%B3"><span class="toc-number">25.10.1.</span> <span class="toc-text">什么是心跳</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%A6%BB%E7%BA%BF%E5%9C%A8%E7%BA%BF"><span class="toc-number">25.10.2.</span> <span class="toc-text">判断离线在线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8B%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%95%E6%9C%BA%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%80%8E%E4%B9%88%E5%81%9A%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%86%8D%E6%AC%A1%E4%B8%8A%E7%BA%BF%E5%91%A2%EF%BC%9F"><span class="toc-number">25.10.3.</span> <span class="toc-text">若服务端宕机，客户端怎么做、服务端再次上线呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B%E3%80%81websocket%E8%BF%9E%E6%8E%A5"><span class="toc-number">25.10.4.</span> <span class="toc-text">心跳检测、websocket连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86"><span class="toc-number">26.</span> <span class="toc-text">二维码扫码登录原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%AC%A1%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%90%8C%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E%E7%9A%84%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-number">27.</span> <span class="toc-text">多次异步请求同一个接口，结果返回的顺序问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">27.0.1.</span> <span class="toc-text">解决方案:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%EF%BC%88%E4%B8%8E%E5%89%8D%E5%90%8E%E7%AB%AF%E6%97%A0%E5%85%B3%EF%BC%8C%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%89%E5%85%B3%EF%BC%89"><span class="toc-number">28.</span> <span class="toc-text">跨域（与前后端无关，与浏览器有关）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%8F%91%E7%94%9F%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">28.1.</span> <span class="toc-text">跨域请求发生的时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-7"><span class="toc-number">28.2.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">28.3.</span> <span class="toc-text">跨域解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JSONP%E8%B7%A8%E5%9F%9F"><span class="toc-number">28.3.1.</span> <span class="toc-text">JSONP跨域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CORS%E8%B7%A8%E5%9F%9F"><span class="toc-number">28.3.2.</span> <span class="toc-text">CORS跨域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#nodejs%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%BB%A3%E7%90%86%E8%B7%A8%E5%9F%9F"><span class="toc-number">28.3.3.</span> <span class="toc-text">nodejs中间件代理跨域</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#window-name-iframe"><span class="toc-number">28.3.4.</span> <span class="toc-text">window.name+iframe</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#postMessage%E8%B7%A8%E5%9F%9F-iframe"><span class="toc-number">28.3.5.</span> <span class="toc-text">postMessage跨域+iframe</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%8D%8F%E7%A8%8B"><span class="toc-number">29.</span> <span class="toc-text">线程进程协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">30.</span> <span class="toc-text">进程间的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9B%E7%A8%8B"><span class="toc-number">31.</span> <span class="toc-text">浏览器进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">32.</span> <span class="toc-text">浏览器线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%86%99JSONP"><span class="toc-number">33.</span> <span class="toc-text">手写JSONP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%80%9D%E8%B7%AF"><span class="toc-number">33.1.</span> <span class="toc-text">主要思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">33.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">33.3.</span> <span class="toc-text">浏览器缓存的位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E7%94%B1%E8%B0%81%E5%86%B3%E5%AE%9A"><span class="toc-number">33.4.</span> <span class="toc-text">浏览器是否使用缓存由谁决定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E7%89%88%E6%9C%AC%E6%98%AF%E5%89%8D%E7%AB%AF%E6%8E%A7%E5%88%B6%E8%BF%98%E6%98%AF%E5%90%8E%E7%AB%AF%E6%8E%A7%E5%88%B6%EF%BC%9F"><span class="toc-number">33.5.</span> <span class="toc-text">HTTP版本是前端控制还是后端控制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">33.6.</span> <span class="toc-text">浏览器渲染页面的过程与原理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/07/js%E9%A2%98/" title="js题"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/dp/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="js题"/></a><div class="content"><a class="title" href="/2023/07/07/js%E9%A2%98/" title="js题">js题</a><time datetime="2023-07-07T14:28:39.043Z" title="发表于 2023-07-07 22:28:39">2023-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/18/top100/" title="top100"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="top100"/></a><div class="content"><a class="title" href="/2023/06/18/top100/" title="top100">top100</a><time datetime="2023-06-18T07:47:11.000Z" title="发表于 2023-06-18 15:47:11">2023-06-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/ts/" title="TS"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="TS"/></a><div class="content"><a class="title" href="/2023/06/06/ts/" title="TS">TS</a><time datetime="2023-06-06T14:32:28.000Z" title="发表于 2023-06-06 22:32:28">2023-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/01/playwright/" title="playwright"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/linux/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="playwright"/></a><div class="content"><a class="title" href="/2023/05/01/playwright/" title="playwright">playwright</a><time datetime="2023-04-30T23:25:56.000Z" title="发表于 2023-05-01 07:25:56">2023-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/27/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" title="前端安全"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/interview/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端安全"/></a><div class="content"><a class="title" href="/2023/03/27/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" title="前端安全">前端安全</a><time datetime="2023-03-27T05:15:38.000Z" title="发表于 2023-03-27 13:15:38">2023-03-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Cheyennee</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>