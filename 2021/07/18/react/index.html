<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>react | Cheyennee</title><meta name="keywords" content="blog"><meta name="author" content="Cheyennee,714851125@qq.com"><meta name="copyright" content="Cheyennee"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录react知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="react">
<meta property="og:url" content="http://cheyennee.github.io/2021/07/18/react/index.html">
<meta property="og:site_name" content="Cheyennee">
<meta property="og:description" content="记录react知识点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/cover.jpg">
<meta property="article:published_time" content="2021-07-18T02:45:16.000Z">
<meta property="article:modified_time" content="2023-07-27T01:51:01.433Z">
<meta property="article:author" content="Cheyennee">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/cover.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://cheyennee.github.io/2021/07/18/react/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'react',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-27 09:51:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cheyennee</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">react</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-18T02:45:16.000Z" title="发表于 2021-07-18 10:45:16">2021-07-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-27T01:51:01.433Z" title="更新于 2023-07-27 09:51:01">2023-07-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/react/">react</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="react"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul>
<li>概念：函数式编程是通过编写纯函数，避免共享状态、可变数据、副作用来构建软件的过程。函数式编程是声明式的编程而不是命令式的。</li>
</ul>
<h3 id="对react的理解？有哪些特性？"><a href="#对react的理解？有哪些特性？" class="headerlink" title="对react的理解？有哪些特性？"></a>对react的理解？有哪些特性？</h3><h4 id="react是什么？"><a href="#react是什么？" class="headerlink" title="react是什么？"></a>react是什么？</h4><p>​		React，用于构建用户界面的 JavaScript 库，只提供了 <strong>UI 层面</strong>的解决方案。遵循组件设计模式、<strong>声明式编程范式和函数式编程概念</strong>，以使前端应用程序更高效。使用虚拟 <code>DOM</code> 来有效地操作 <code>DOM</code>，遵循从高阶组件到低阶组件的<strong>单向数据流</strong>。帮助我们将界面成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套，构成整体页面。<code>react</code> 类组件使用一个名为 <code>render()</code> 的方法或者函数组件<code>return</code>，接收输入的数据并返回需要展示的内容。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>JSX 语法：在JS中通过使用XML的方式去直接声明界面的DOM结构</li>
<li>单向数据绑定</li>
<li>虚拟 DOM</li>
<li>声明式编程。声明式编程是一种编程范式，它关注的是你要做什么，而不是如何做。它<strong>表达逻辑而不显式地定义步骤</strong>。这意味着我们需要根据逻辑的计算来声明要显示的组件。</li>
<li>组件。组件的特点：可组合（每个组件易于和其它组件一起使用，或者嵌套在另一个组件内部）、可重用（每个组件都是具有独立功能的，它可以被使用在多个 UI 场景）、可维护（每个小的组件仅仅包含自身的逻辑，更容易被理解和维护）</li>
</ul>
<h3 id="组件的优点"><a href="#组件的优点" class="headerlink" title="组件的优点"></a>组件的优点</h3><ul>
<li>降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现</li>
<li>调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单</li>
<li>提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级</li>
</ul>
<h3 id="类组件与函数组件"><a href="#类组件与函数组件" class="headerlink" title="类组件与函数组件"></a>类组件与函数组件</h3><h4 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h4><ul>
<li><p>通过使用<code>ES6</code>类的编写形式去编写组件，该类必须继承<code>React.Component</code></p>
</li>
<li><p>如果想要访问父组件传递过来的参数，可通过<code>this.props</code>的方式去访问</p>
</li>
<li><p>在组件中必须实现<code>render</code>方法，在<code>return</code>中返回<code>React</code>对象</p>
</li>
</ul>
<h4 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h4><ul>
<li>通过函数编写的形式去实现一个<code>React</code>组件，函数第一个参数为<code>props</code>用于接收父组件传递过来的参数</li>
</ul>
<h4 id="类组件与函数组件的区别"><a href="#类组件与函数组件的区别" class="headerlink" title="类组件与函数组件的区别"></a>类组件与函数组件的区别</h4><ul>
<li>编写形式</li>
<li>状态管理：类组件调用setState就能进行数据状态管理，而函数组件需要使用hooks进行状态管理</li>
<li>生命周期：函数组件中不存在生命周期，但某些钩子可以替代生命周期的作用。例如useEffect钩子中能完成componentDidMount生命周期的功能，return时，能完成componentWillUnmount生命周期的功能。</li>
<li>调用方式：react内部调用函数组件即是执行函数，而react内部调用类组件需要将组件进行实例化，再调用实例对象的render方法。</li>
<li>this：类组件中this总是可变的，会产生某些与this指向相关的问题。</li>
</ul>
<h3 id="真实DOM和虚拟DOM"><a href="#真实DOM和虚拟DOM" class="headerlink" title="真实DOM和虚拟DOM"></a>真实DOM和虚拟DOM</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>​	真实DOM是文档对象模型，在页面渲染出的每一个节点都是一个真实DOM结构。</p>
<p>​	虚拟DOM本质是以JS对象形式存在的对DOM的描述。创建虚拟DOM目的是为了更好将虚拟的节点渲染到页面视图中，虚拟DOM对象的节点与真实DOM的属性一一对应。</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>虚拟 DOM 减少了页面的排版与重绘操作，而真实 DOM 会频繁重排与重绘</li>
<li>虚拟 DOM 的总损耗是“虚拟 DOM 增删改+真实 DOM 差异增删改+排版与重绘”，真实 DOM 的总损耗是“真实 DOM 完全增删改+排版与重绘”</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>真实DOM优点：</p>
<ul>
<li>易用</li>
</ul>
<p>真实DOM缺点：</p>
<ul>
<li>效率低，解析速度慢，内存占用量过高</li>
<li>性能差：频繁操作真实 DOM，易于导致重绘与回流</li>
</ul>
<p>虚拟DOM优点：</p>
<ul>
<li>简单方便：如果使用手动操作真实 <code>DOM</code> 来完成页面，繁琐又容易出错，在大规模应用下维护起来也很困难</li>
<li>性能方面：使用 Virtual DOM，能够有效避免真实 DOM 树频繁更新，减少多次更新而引起重绘与回流，提高性能</li>
<li>跨平台：React 借助虚拟 DOM，带来了跨平台的能力，一套代码多端运行</li>
</ul>
<p>虚拟DOM缺点：</p>
<ul>
<li>在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化</li>
<li>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，速度比正常稍慢</li>
</ul>
<h3 id="react-diff"><a href="#react-diff" class="headerlink" title="react diff"></a>react diff</h3><h4 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		<code>diff</code>算法通过对比新旧<code>Virtual DOM</code>来找出真正的<code>Dom</code>变化之处。传统diff算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)。因为每个节点都要去和另一棵树的全部节点对比一次，这就是n，如果找到有变化的节点，执行插入、删除、修改也是n的复杂度。所有节点都需要执行上述过程，再乘以n，就是o(n^3)复杂度。</p>
<p>​		为降低时间复杂度，前端框架的diff约定了处理原则：<strong>只做同层对比，type变了就不再对比子节点</strong>。这个处理原则将算法进行了一个优化，时间复杂度为<code>O(n)</code>。因为只需遍历一遍，对比type就行了，type变了就不用对比子节点。此外由于vdom中记录了关联的dom节点，执行dom的增删改也不需要遍历，是o(1)，所以整体算法复杂度是o(n)。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>遵循三个层级的策略：</p>
<ul>
<li>tree层级</li>
<li>conponent 层级</li>
<li>element 层级</li>
</ul>
<h5 id="tree层级"><a href="#tree层级" class="headerlink" title="tree层级"></a>tree层级</h5><p>​		虚拟节点中，对DOM相同层级的节点进行比较。这部分只涉及删除、创建操作。</p>
<h5 id="component层级"><a href="#component层级" class="headerlink" title="component层级"></a>component层级</h5><p>​		同一类的组件，则会继续往下diff运算，如果不是同一类的组件，那么直接删除这个组件下的所有子节点，创建新的。这部分只涉及删除、创建操作。</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic1.png" alt="组件层级" style="zoom:50%;">

<h5 id="element层级"><a href="#element层级" class="headerlink" title="element层级"></a>element层级</h5><p>​		对于比较同一层级的节点，每个节点在对应的层级用唯一的key作为标识，提供了插入、删除和移动。</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic2.png" alt="元素比较" style="zoom:50%;">

<p>​		通过<code>key</code>可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置。</p>
<h4 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h4><p>​		key是虚拟DOM对象的标识，判断元素是新创建的还是被移动的元素，从而减少不必要的元素渲染。当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】，随后react进行【新虚拟DOM】与【旧虚拟DOM】的diffing比较，比较原则如下：<br>​	**a.**旧虚拟DOM中找到了与新虚拟DOM相同的key:</p>
<pre><code>      1. 若虚拟DOM中内容没变，直接使用之前的真实DOM
      2. 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换页面中之前的真实DOM
</code></pre>
<p>​	<strong>b.</strong> 旧虚拟DOM中未找到与新虚拟DOM相同的key：根据数据创建新的真实DOM，随后渲染到页面</p>
<h4 id="使用index作为key可能引发的问题"><a href="#使用index作为key可能引发的问题" class="headerlink" title="使用index作为key可能引发的问题"></a>使用index作为key可能引发的问题</h4><ul>
<li><p>若对数据进行：逆序添加、逆序删除等破坏顺序操作：会产生没有必要的真实DOM更新&#x3D;&#x3D;》界面效果没问题，但效率低</p>
</li>
<li><p>若结构中还包含输入类DOM(input\radio): 会产生错误DOM更新&#x3D;&#x3D;》界面有问题</p>
</li>
<li><p>注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用Index作为key是没有问题的。</p>
</li>
</ul>
<h4 id="如何选择key"><a href="#如何选择key" class="headerlink" title="如何选择key"></a>如何选择key</h4><ul>
<li>最好使用每条数据的唯一标识作为key,比如id\手机号等</li>
<li>如果只是简单的数据展示，用index也可以</li>
</ul>
<h3 id="JSX转成真实DOM的过程"><a href="#JSX转成真实DOM的过程" class="headerlink" title="JSX转成真实DOM的过程"></a>JSX转成真实DOM的过程</h3><h4 id="是什么？-2"><a href="#是什么？-2" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		<code>react</code>通过将组件编写的<code>JSX</code>映射到屏幕，以及组件中的状态发生了变化之后 <code>React</code>会将这些「变化」更新到屏幕上。<code>JSX</code>通过<code>babel</code>最终转化成<code>React.createElement</code>这种形式。</p>
<p>​		在转化过程中，<code>babel</code>在编译时会判断 JSX 中组件的首字母：</p>
<ul>
<li>当首字母为小写时，其被认定为原生 <code>DOM</code> 标签，<code>createElement</code> 的第一个变量被编译为字符串</li>
<li>当首字母为大写时，其被认定为自定义组件，createElement 的第一个变量被编译为对象</li>
</ul>
<p>​		最终都会通过<code>RenderDOM.render(...)</code>方法进行挂载</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>在<code>react</code>中，节点大致可以分成四个类别：</p>
<ul>
<li>原生标签节点</li>
<li>文本节点</li>
<li>函数组件</li>
<li>类组件</li>
</ul>
<p>这些类别最终都会被转化成<code>React.createElement</code>这种形式。</p>
<p><code>React.createElement</code>其被调用时会传入标签类型<code>type</code>，标签属性<code>props</code>及若干子元素<code>children</code>，作用是生成一个虚拟<code>Dom</code>对象。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;avatar.png&quot;</span> <span class="attr">className</span>=<span class="string">&quot;profile&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">src</span>: <span class="string">&quot;avatar.png&quot;</span>,</span><br><span class="line">    <span class="attr">className</span>: <span class="string">&quot;profile&quot;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">Hello</span>, <span class="literal">null</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">type, config, ...children</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (config) &#123;</span><br><span class="line">        <span class="keyword">delete</span> config.<span class="property">__self</span>;</span><br><span class="line">        <span class="keyword">delete</span> config.<span class="property">__source</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ! 源码中做了详细处理，⽐如过滤掉key、ref等</span></span><br><span class="line">    <span class="keyword">const</span> props = &#123;</span><br><span class="line">        ...config,</span><br><span class="line">        <span class="attr">children</span>: children.<span class="title function_">map</span>(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">   <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span> ? child : <span class="title function_">createTextNode</span>(child)</span><br><span class="line">  )</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type,</span><br><span class="line">        props</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createTextNode</span>(<span class="params">text</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="variable constant_">TEXT</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">            <span class="attr">children</span>: [],</span><br><span class="line">            <span class="attr">nodeValue</span>: text</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    createElement</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>createElement</code>会根据传入的节点信息进行一个判断：</p>
<ul>
<li>如果是原生标签节点， type 是字符串，如div、span</li>
<li>如果是文本节点， type就没有，这里是 TEXT</li>
<li>如果是函数组件，type 是函数名</li>
<li>如果是类组件，type 是类名</li>
</ul>
<p>虚拟<code>DOM</code>会通过<code>ReactDOM.render</code>进行渲染成真实<code>DOM</code>，使用方法如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(element, container[, callback])</span><br></pre></td></tr></table></figure>

<p>​	当首次调用时，容器节点里的所有 <code>DOM</code> 元素都会被替换，后续的调用则会使用 <code>React</code> 的 <code>diff</code>算法进行高效的更新。</p>
<p>​	如果提供了可选的回调函数<code>callback</code>，该回调将在组件被渲染或更新之后被执行。</p>
<p>ReactDOM.render方法大致实现过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">vnode, container</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;vnode&quot;</span>, vnode); <span class="comment">// 虚拟DOM对象</span></span><br><span class="line">    <span class="comment">// vnode _&gt; node</span></span><br><span class="line">    <span class="keyword">const</span> node = <span class="title function_">createNode</span>(vnode, container);</span><br><span class="line">    container.<span class="title function_">appendChild</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建真实DOM节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createNode</span>(<span class="params">vnode, parentNode</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123;type, props&#125; = vnode;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="variable constant_">TEXT</span>) &#123;</span><br><span class="line">        node = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        node = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(type);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        node = type.<span class="property">isReactComponent</span></span><br><span class="line">            ? <span class="title function_">updateClassComponent</span>(vnode, parentNode)</span><br><span class="line">        : <span class="title function_">updateFunctionComponent</span>(vnode, parentNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">reconcileChildren</span>(props.<span class="property">children</span>, node);</span><br><span class="line">    <span class="title function_">updateNode</span>(node, props);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历下子vnode，然后把子vnode-&gt;真实DOM节点，再插入父node中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params">children, node</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> child = children[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(child)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; child.<span class="property">length</span>; j++) &#123;</span><br><span class="line">                <span class="title function_">render</span>(child[j], node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">render</span>(child, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateNode</span>(<span class="params">node, nextVal</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(nextVal)</span><br><span class="line">        .<span class="title function_">filter</span>(<span class="function"><span class="params">k</span> =&gt;</span> k !== <span class="string">&quot;children&quot;</span>)</span><br><span class="line">        .<span class="title function_">forEach</span>(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">2</span>) === <span class="string">&quot;on&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> eventName = k.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLocaleLowerCase</span>();</span><br><span class="line">            node.<span class="title function_">addEventListener</span>(eventName, nextVal[k]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node[k] = nextVal[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回真实dom节点</span></span><br><span class="line"><span class="comment">// 执行函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateFunctionComponent</span>(<span class="params">vnode, parentNode</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;type, props&#125; = vnode;</span><br><span class="line">    <span class="keyword">let</span> vvnode = <span class="title function_">type</span>(props);</span><br><span class="line">    <span class="keyword">const</span> node = <span class="title function_">createNode</span>(vvnode, parentNode);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回真实dom节点</span></span><br><span class="line"><span class="comment">// 先实例化，再执行render函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateClassComponent</span>(<span class="params">vnode, parentNode</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;type, props&#125; = vnode;</span><br><span class="line">    <span class="keyword">let</span> cmp = <span class="keyword">new</span> <span class="title function_">type</span>(props);</span><br><span class="line">    <span class="keyword">const</span> vvnode = cmp.<span class="title function_">render</span>();</span><br><span class="line">    <span class="keyword">const</span> node = <span class="title function_">createNode</span>(vvnode, parentNode);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    render</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h4><ul>
<li>使用<strong>React.createElement</strong>或JSX编写React组件，实际上所有的 JSX 代码最后都会转换成React.createElement(…) ，<strong>Babel</strong>帮助我们完成了这个转换的过程。</li>
<li><strong>createElement</strong>函数对key和ref等特殊的props进行处理，并获取defaultProps对默认props进行赋值，并且对传入的孩子节点进行处理，最终构造成一个<strong>虚拟DOM</strong>对象</li>
<li><strong>ReactDOM.render</strong>将生成好的虚拟DOM渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实DOM</li>
</ul>
<h3 id="react生命周期"><a href="#react生命周期" class="headerlink" title="react生命周期"></a>react生命周期</h3><h4 id="旧生命周期流程"><a href="#旧生命周期流程" class="headerlink" title="旧生命周期流程"></a>旧生命周期流程</h4><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic3.png" alt="旧生命周期流程">

<ol>
<li>初始化阶段：由ReactDOM.render()触发—初次渲染</li>
</ol>
<ul>
<li>constructor()</li>
<li>componentWillMount()</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
<ol start="2">
<li>更新阶段：由组件内部this.setState()或由父组件重新render触发</li>
</ol>
<ul>
<li>shouldComponentUpdate()</li>
<li>componentWillUpdate()</li>
<li>render()</li>
<li>componentDidUpdate()</li>
</ul>
<ol start="3">
<li>卸载阶段：由React.unmountComponentAtNode()触发</li>
</ol>
<ul>
<li>componentWillUnmount()</li>
</ul>
<h4 id="新生命周期流程"><a href="#新生命周期流程" class="headerlink" title="新生命周期流程"></a>新生命周期流程</h4><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic4.png" alt="新生命周期" style="zoom:75%;">

<ol>
<li>初始化阶段：由ReactDOM.render()触发—初次渲染</li>
</ol>
<ul>
<li>constructor()：在方法内部通过<code>super</code>关键字获取来自父组件的<code>props</code>。在该方法中，通常的操作为初始化<code>state</code>状态或者在<code>this</code>上挂载方法。</li>
<li>getDerivedStateFromProps()：静态方法，不能访问到组件的实例。第一个参数为即将更新的<code>props</code>，第二个参数为上一个状态的<code>state</code>，可以比较<code>props</code> 和 <code>state</code>来加一些限制条件，防止无用的state更新。该方法<strong>需要返回一个新的对象</strong>作为新的<code>state</code>或者返回<code>null</code>表示<code>state</code>状态不需要更新。</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
<ol start="2">
<li>更新阶段：由组件内部this.setState()或由父组件重新render触发</li>
</ol>
<ul>
<li>getDerivedStateFromProps()：用于更新state</li>
<li>shouldComponentUpdate(nextProps, nextState)：用于告知组件本身基于当前的<code>props</code>和<code>state</code>是否需要重新渲染组件，默认情况返回<code>true</code>。用于更新组件。</li>
<li>render()</li>
<li>getSnapshotBeforeUpdate()：此方法的目的在于获取组件更新前的一些信息，比如组件的滚动位置之类的，在组件更新后可以根据这些信息恢复一些UI视觉上的状态。</li>
<li>componentDidUpdate()</li>
</ul>
<ol start="3">
<li>卸载阶段：由React.unmountComponentAtNode()触发</li>
</ol>
<ul>
<li>componentWillUnmount()</li>
</ul>
<h4 id="即将废弃的生命周期函数"><a href="#即将废弃的生命周期函数" class="headerlink" title="即将废弃的生命周期函数"></a>即将废弃的生命周期函数</h4><ul>
<li>componentWillMount</li>
<li>componentWillReceiveProps</li>
<li>componentWillUpdate</li>
</ul>
<p>​		现在使用会出现警告，下一个大版本需要加上UNSAFE_前缀才能使用，以后可能会被彻底废弃，不建议使用。</p>
<h4 id="为什么要废弃这些生命周期函数"><a href="#为什么要废弃这些生命周期函数" class="headerlink" title="为什么要废弃这些生命周期函数"></a>为什么要废弃这些生命周期函数</h4><p>​		废弃的原因是在React16的Fiber架构中，调和过程会多次执行will周期，不再是一次执行，失去了原有的意义。fiber是异步渲染，很可能因为高优先级任务的出现而打断现有任务导致will执行多次。多次执行will，在周期中如果有setState或dom操作，会触发多次重绘，影响性能，也会导致数据错乱。</p>
<h3 id="state和props"><a href="#state和props" class="headerlink" title="state和props"></a>state和props</h3><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>​		一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是 <code>state</code>，一般在 <code>constructor</code> 中初始化。当需要修改里面的值的状态需要通过调用 <code>setState</code> 来改变，从而达到更新组件内部数据的作用，并且重新调用组件 <code>render</code> 方法。</p>
<h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p>​		 <code>props</code> 是外部传入组件内部的数据。<code>react</code> 具有单向数据流的特性，所以他的主要作用是从父组件向子组件中传递数据。</p>
<h4 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h4><p>相同点：</p>
<ul>
<li>两者都是 JavaScript 对象</li>
<li>两者都是用于保存信息</li>
<li>props 和 state 都能触发渲染更新</li>
</ul>
<p>区别：</p>
<ul>
<li>props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化</li>
<li>props 在组件内部是不可修改的，但 state 在组件内部可以进行修改</li>
</ul>
<h3 id="super-与super-props"><a href="#super-与super-props" class="headerlink" title="super()与super(props)"></a>super()与super(props)</h3><h4 id="ES6类"><a href="#ES6类" class="headerlink" title="ES6类"></a>ES6类</h4><p>​		<code>super</code> 关键字实现调用父类，<code>super</code> 代替的是父类的构建函数，使用 <code>super(name)</code> 相当于调用 father.prototype.constructor.call(this,name)</p>
<p>​		如果在子类中不使用 <code>super</code>关键字，则会引发报错。报错的原因是<strong>子类是没有自己的 <code>this</code> 对象的</strong>，它只能继承父类的 <code>this</code> 对象，然后对其进行加工。而 <code>super()</code> 就是将父类中的 <code>this</code> 对象继承给子类的，没有 <code>super()</code> 子类就得不到 <code>this</code> 对象。如果先调用 <code>this</code>，再初始化 <code>super()</code>，同样是禁止的行为。</p>
<h4 id="super-与super-props-的区别"><a href="#super-与super-props-的区别" class="headerlink" title="super()与super(props)的区别"></a>super()与super(props)的区别</h4><p>​		在 <code>React</code> 中，类组件基于 <code>ES6</code>，所以在 <code>constructor</code> 中必须使用 <code>super</code>。在调用 <code>super</code> 过程，无论是否传入 <code>props</code>，<code>React</code> 内部都会将 <code>props</code> 赋值给组件实例 <code>props</code> 属性中。如果只调用了 <code>super()</code>，那么 <code>this.props</code> 在 <code>super()</code> 和构造函数结束之间仍是 <code>undefined</code>。</p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><h4 id="是什么？-3"><a href="#是什么？-3" class="headerlink" title="是什么？"></a>是什么？</h4><p>​	更改数据状态state里面的值需要通过调用setState来改变</p>
<h4 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h4><ul>
<li>对象式<ul>
<li>setState(stateChange, [callback])</li>
<li>stateChange为状态改变对象；callback是可选的回调函数，在状态更新完毕、界面也更新后才被调用</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">count</span>:count + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>函数式<ul>
<li>setState(updater, [callback])</li>
<li>updater为函数，可以接收state和props</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state,props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(state,props);</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.<span class="property">count</span> + <span class="number">1</span>&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用原则：如果新状态不依赖于原状态则使用对象式；如果新状态依赖于原状态则使用函数式；如果需要在setState执行后获取最新的状态数据，就需要在回调函数中读取。</li>
</ul>
<h4 id="更新类型"><a href="#更新类型" class="headerlink" title="更新类型"></a>更新类型</h4><p>​		setState是一个同步的方法，但是setState引起react后续更新状态的动作是异步的。</p>
<ul>
<li><p>异步更新：在组件生命周期或React合成事件中，也就是在React能管控的地方</p>
</li>
<li><p>同步更新：在setTimeout或者原生dom事件中</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步更新</span></span><br><span class="line"><span class="title function_">changeText</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&quot;你好啊&quot;</span></span><br><span class="line">  &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">message</span>); <span class="comment">// 你好啊</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步更新</span></span><br><span class="line"><span class="title function_">changeText</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;你好啊</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">    console.log(this.state.message); // 你好啊</span></span><br><span class="line"><span class="string">  &#125;, 0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span>) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 点击按钮触发事件，打印的都是 1，页面显示 count 的值为 2</span></span><br></pre></td></tr></table></figure>

<p>​		对同一个值进行多次 <code>setState</code>， <code>setState</code> 的批量更新策略会对其进行覆盖，取最后一次的执行结果。所谓<strong>异步批量</strong>是指在一次页面更新中如果涉及多次 state 修改时，会合并多次 state 修改的结果得到最终结果从而进行一次页面更新。</p>
<p>​		如果是下一个<code>state</code>依赖前一个<code>state</code>的话，推荐给<code>setState</code>一个参数传入一个<code>function</code>，如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: prevState.<span class="property">count</span> + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="react事件机制"><a href="#react事件机制" class="headerlink" title="react事件机制"></a>react事件机制</h3><h4 id="是什么？-4"><a href="#是什么？-4" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		<code>React</code>基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等。在<code>React</code>中这套事件机制被称之为合成事件。</p>
<h4 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h4><p>​		合成事件是 <code>React</code>模拟原生 <code>DOM</code>事件所有能力的一个事件对象，即<strong>浏览器原生事件的跨浏览器包装器</strong>。根据 <code>W3C</code>规范来定义合成事件，兼容所有浏览器，拥有与浏览器原生事件相同的接口。</p>
<p>​		react事件与原生事件非常相似，但也存在区别：</p>
<ul>
<li>事件名称命名方式不同</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生事件绑定方式：小写</span></span><br><span class="line">&lt;button onclick=<span class="string">&quot;handleClick()&quot;</span>&gt;按钮命名&lt;/button&gt;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// React 合成事件绑定方式：驼峰</span></span><br><span class="line"><span class="keyword">const</span> button = <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>按钮命名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>事件处理函数书写不同</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生事件 事件处理函数写法：带括号</span></span><br><span class="line">&lt;button onclick=<span class="string">&quot;handleClick()&quot;</span>&gt;按钮命名&lt;/button&gt;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// React 合成事件 事件处理函数写法：不带括号</span></span><br><span class="line"><span class="keyword">const</span> button = <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>按钮命名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>​		虽然<code>onClick</code>看似绑定到<code>DOM</code>元素上，但实际并不会把事件代理函数直接绑定到真实的节点上，而是把所有的事件绑定到结构的最外层，使用一个统一的事件去监听。</p>
<p>​		这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象。</p>
<p>​		当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升。</p>
<h4 id="合成事件与原生事件的执行顺序"><a href="#合成事件与原生事件的执行顺序" class="headerlink" title="合成事件与原生事件的执行顺序"></a>合成事件与原生事件的执行顺序</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  <span class="title class_">React</span>  <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parentRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">childRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;React componentDidMount！&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">parentRef</span>.<span class="property">current</span>?.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;原生事件：父元素 DOM 事件监听！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">childRef</span>.<span class="property">current</span>?.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;原生事件：子元素 DOM 事件监听！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;原生事件：document DOM 事件监听！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  parentClickFun = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;React 事件：父元素事件监听！&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  childClickFun = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;React 事件：子元素事件监听！&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.parentRef&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.parentClickFun&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.childRef&#125;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.childClickFun&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          分析事件执行顺序</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>输出顺序为：原生事件–&gt;合成事件–&gt;document挂载事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原生事件：子元素 DOM 事件监听！ </span><br><span class="line">原生事件：父元素 DOM 事件监听！ </span><br><span class="line">React 事件：子元素事件监听！ </span><br><span class="line">React 事件：父元素事件监听！ </span><br><span class="line">原生事件：document DOM 事件监听！</span><br></pre></td></tr></table></figure>

<p>可以得出以下结论：</p>
<ul>
<li>React <strong>所有事件</strong>都挂载在 <strong>document 对象</strong>上</li>
<li>当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件</li>
<li>所以会先执行原生事件，然后处理 React 事件</li>
<li>最后真正执行 document 上挂载的事件</li>
<li>React 自身实现了一套事件冒泡机制，想要阻止不同时间段的冒泡行为，对应使用不同的方法</li>
</ul>
<h3 id="类组件中事件绑定方式"><a href="#类组件中事件绑定方式" class="headerlink" title="类组件中事件绑定方式"></a>类组件中事件绑定方式</h3><p>​		render函数是被组件实例调用的,其中的this指向的就是<strong>当前的组件实例</strong>,但是如果赋值给点击事件了,this则改变了指向,由react内部直接调用onClick,此时的this则是<strong>undefined</strong>  (<strong>class内部开启局部的严格模式</strong>this不指向window)</p>
<h4 id="常见的绑定方式"><a href="#常见的绑定方式" class="headerlink" title="常见的绑定方式"></a>常见的绑定方式</h4><ul>
<li>render方法中使用bind</li>
<li>render方法中使用箭头函数</li>
<li>constructor中bind</li>
<li>定义阶段使用箭头函数绑定</li>
</ul>
<h5 id="render方法中使用bind"><a href="#render方法中使用bind" class="headerlink" title="render方法中使用bind"></a>render方法中使用bind</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这种方式在组件每次render时，都会重新进行bind的操作，影响性能</span></span><br></pre></td></tr></table></figure>

<h5 id="render方法中使用箭头函数"><a href="#render方法中使用箭头函数" class="headerlink" title="render方法中使用箭头函数"></a>render方法中使用箭头函数</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> this.handleClick(e)&#125;&gt;test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每一次render时都会生成新的方法，影响性能</span></span><br></pre></td></tr></table></figure>

<h5 id="constructor中bind"><a href="#constructor中bind" class="headerlink" title="constructor中bind"></a>constructor中bind</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在constructor中预先bind当前组件，可以避免在render操作中重复绑定</span></span><br></pre></td></tr></table></figure>

<h5 id="函数定义阶段使用箭头函数绑定"><a href="#函数定义阶段使用箭头函数绑定" class="headerlink" title="函数定义阶段使用箭头函数绑定"></a>函数定义阶段使用箭头函数绑定</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this &gt; &#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="react中组件的通信方式"><a href="#react中组件的通信方式" class="headerlink" title="react中组件的通信方式"></a>react中组件的通信方式</h3><p>分为：</p>
<ul>
<li><p>父组件向子组件传递：props</p>
</li>
<li><p>子组件向父组件传递：父组件向子组件传一个函数，然后通过这个函数的回调，拿到子组件传过来的值</p>
</li>
<li><p>兄弟组件之间的通信：父组件作为中间层来实现数据的互通，通过使用父组件传递</p>
</li>
<li><p>父组件向后代组件传递：使用<code>context</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PriceContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="string">&#x27;price&#x27;</span>)</span><br><span class="line"><span class="comment">//使用Provider创建数据源，通过value属性给后代组件传递数据</span></span><br><span class="line">&lt;<span class="title class_">PriceContext</span>.<span class="property">Provider</span> value=&#123;<span class="number">100</span>&#125;&gt;&lt;/<span class="title class_">PriceContext</span>.<span class="property">Provider</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="comment">//后代组件可以通过Consumer或者使用contextType属性接收数据</span></span><br><span class="line"><span class="comment">//contextType</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = <span class="title class_">PriceContext</span>;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> price = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">    <span class="comment">/* 基于这个值进行渲染工作 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Consumer</span></span><br><span class="line">&lt;<span class="title class_">PriceContext</span>.<span class="property">Consumer</span>&gt;</span><br><span class="line">    &#123; <span class="comment">/*这里是一个函数*/</span> &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="params">price</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>price：&#123;price&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&lt;/<span class="title class_">PriceContext</span>.<span class="property">Consumer</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非关系组件传递：使用<code>redux</code></p>
</li>
</ul>
<h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><h4 id="是什么？-5"><a href="#是什么？-5" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		refs允许我们访问 <code>DOM</code>节点或在 <code>render</code>方法中创建的 <code>React</code>组件。如果是渲染组件则返回的是组件实例，如果渲染<code>dom</code>则返回的是具体的<code>dom</code>节点。<strong>不能在函数组件上使用<code>ref</code>属性</strong>，因为他们并没有实例。</p>
<p>​		一般函数式组件都是用<code>React.forwardRef</code>包装一下然后返回出去的, 函数式组件本来就是一个<code>render</code>函数，不过在被<code>React.forwardRef</code>包装后就多了一个<code>ref</code>属性了。</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul>
<li><p>传入字符串，使用时通过 this.refs.传入的字符串的格式获取对应的元素</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;myref&quot;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">myref</span>.<span class="property">innerHTML</span> = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传入对象，对象是通过 React.createRef() 方式创建出来，使用时获取到创建的对象中存在 current 属性就是对应的元素</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line"><span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="property">myRef</span>.<span class="property">current</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传入函数，该函数会在 DOM 被挂载时进行回调，这个函数会传入一个元素对象，可以自己保存，使用时，直接拿到之前保存的元素对象即可</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;element</span> =&gt;</span> this.myref = element&#125; /&gt;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line"><span class="keyword">const</span> node = <span class="variable language_">this</span>.<span class="property">myref</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>传入hook，hook是通过 useRef() 方式创建，使用时通过生成hook对象的 current 属性就是对应的元素</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myref = <span class="title function_">useRef</span>()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;myref&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//访问</span></span><br><span class="line"><span class="keyword">const</span> node = myref.<span class="property">current</span>;</span><br></pre></td></tr></table></figure>

<h4 id="refs应用场景"><a href="#refs应用场景" class="headerlink" title="refs应用场景"></a>refs应用场景</h4><ul>
<li>对Dom元素的焦点控制、内容选择、控制</li>
<li>对Dom元素的内容设置及媒体播放</li>
<li>对Dom元素的操作和对组件实例的操作</li>
<li>集成第三方 DOM 库</li>
</ul>
<h3 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="headerlink" title="受控组件与非受控组件"></a>受控组件与非受控组件</h3><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><p>​		受控制的组件，组件的状态全程响应外部数据。受控组件一般需要初始状态和一个状态更新事件函数。</p>
<p>​		在HTML中，表单元素通常维护自己的value，并根据用户输入进行更新。而在React中，可变状态通常保存在组件的state属性中，并且只能通过使用setState()来更新。可以把两者结合起来，<strong>使React的state成为唯一数据源</strong>。渲染表单的React组件还控制着用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素叫做受控组件。如下为示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NameForm</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handleSubmit</span> = <span class="variable language_">this</span>.<span class="property">handleSubmit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">handleChange</span>(<span class="params">event</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">handleSubmit</span>(<span class="params">event</span>)&#123;</span><br><span class="line">        event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    name:</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		由于在表单元素上设置了<code>value</code>属性，因此显示的值始终为<code>this.state.value</code>，这使得React的state成为唯一数据源。对于受控组件来说，输入的值始终由React的state驱动。</p>
<h4 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h4><p>​		不受控制的组件。一般情况是在初始化的时候接受外部数据，然后自己在内部存储其自身状态。当需要时，可以使用<code>ref</code> 查询 <code>DOM</code>并查找其当前值。</p>
<p>​		非受控组件的数据将交由DOM节点来处理。要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，使用ref来从DOM节点中获取表单数据。如下所示为示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NameForm</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handleSubmit</span> = <span class="variable language_">this</span>.<span class="property">handleSubmit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">input</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">handleSubmit</span>(<span class="params">event</span>)&#123;    </span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;a name was submitted: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">current</span>.<span class="property">value</span>);</span><br><span class="line">        event.<span class="title function_">preventDefault</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    name:</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.input&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		非受控组件将真实数据存储在DOM节点中，所以在使用非受控组件时，有时候更容易同时集成React和非React代码。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>​		大部分时候推荐使用受控组件来实现表单，因为在受控组件中，表单数据由<code>React</code>组件负责处理。如果选择非受控组件的话，控制能力较弱，表单数据就由<code>DOM</code>本身处理，但更加方便快捷，代码量少。</p>
<h3 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h3><h4 id="是什么？-6"><a href="#是什么？-6" class="headerlink" title="是什么？"></a>是什么？</h4><p>接受一个或多个组件作为参数并且返回一个组件。本质上是一个装饰者设计模式。</p>
<h4 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (<span class="title class_">WrappedComponent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">EnhancedComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		把通用的逻辑放在高阶组件中，对组件实现一致的处理，从而实现代码的复用。所以，高阶组件的主要功能是<strong>封装并分离组件的通用逻辑</strong>，让通用逻辑在组件间更好地被复用。</p>
<p>​		如果向一个高阶组件添加<code>ref</code>引用，那么<code>ref</code> 指向的是最外层容器组件实例的，而不是被包裹的组件，如果需要传递<code>refs</code>的话，则使用<code>React.forwardRef</code>。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>​		高阶组件能够提高代码的复用性和灵活性，在实际应用中，常常用于与核心业务无关但又在多个模块使用的功能，如权限控制、日志记录、数据校验、异常处理、统计上报等。</p>
<p>​	如下实例，存在一个组件，需要从缓存中获取数据，然后渲染。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用高阶组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;data&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用高阶组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withPersistentData</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;data&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 通过&#123;...this.props&#125; 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponentWithPersistentData</span> = <span class="title function_">withPersistentData</span>(<span class="title class_">MyComponent2</span>)</span><br></pre></td></tr></table></figure>



<h3 id="react-hooks"><a href="#react-hooks" class="headerlink" title="react hooks"></a>react hooks</h3><h4 id="是什么？-7"><a href="#是什么？-7" class="headerlink" title="是什么？"></a>是什么？</h4><p>可以在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 <code>React</code> 特性。使用<strong>hooks重点解决的是状态相关的重用问题</strong>。</p>
<p>使用hooks的原因</p>
<ul>
<li>难以重用和共享组件中的与状态相关的逻辑</li>
<li>逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 local state 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面</li>
<li>类组件中的this增加学习成本，类组件在基于现有工具的优化上存在些许问题</li>
<li>由于业务变动，函数组件不得不改为类组件等等</li>
</ul>
<h4 id="常用hooks"><a href="#常用hooks" class="headerlink" title="常用hooks"></a>常用hooks</h4><ul>
<li>useState：在函数组件中通过<code>useState</code>实现函数内部维护<code>state</code>，参数为<code>state</code>默认的值，返回值是一个数组，第一个值为当前的<code>state</code>，第二个值为更新<code>state</code>的函数。</li>
<li>useEffect：可以在函数组件中进行一些带有副作用的操作。<code>useEffect</code>第一个参数接受一个回调函数，默认情况下，<code>useEffect</code>会在第一次渲染和更新之后都会执行，相当于在<code>componentDidMount</code>和<code>componentDidUpdate</code>两个生命周期函数中执行回调。如果某些特定值在两次重渲染之间没有发生变化，你可以跳过对 effect 的调用，这时候只需要传入第二个参数。回调函数中可以返回一个清除函数，这是<code>effect</code>可选的清除机制，相当于类组件中<code>componentwillUnmount</code>生命周期函数。**<code>useEffect</code>相当于<code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个生命周期函数的组合**。</li>
<li>useContext：父组件与后代组件通信</li>
<li>useRef：获取DOM结构</li>
<li>useMemo：类组件中性能优化的方法是shouldComponentUpdate和PureComponent，函数组件中性能优化的方法是useMemo。它接收两个参数，一个是在渲染过程中被调用的函数，另一个是变量。只有当这个变量被调用的时候，函数才会被执行。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useMemo</span>(<span class="function">()=&gt;</span>value, [m ,n])</span><br><span class="line"><span class="comment">// 若value是一个函数，则</span></span><br><span class="line"><span class="title function_">useMemo</span>(<span class="function">()=&gt;</span><span class="function">(<span class="params">x</span>)=&gt;</span>x, [m, n])</span><br><span class="line"><span class="comment">// 以上写法过于臃肿，useCallback是useMemo的语法糖</span></span><br><span class="line"><span class="title function_">useCallback</span>(<span class="function"><span class="params">x</span>=&gt;</span>x, [m, n])</span><br></pre></td></tr></table></figure>



<h5 id="useEffect第二个参数的执行规则"><a href="#useEffect第二个参数的执行规则" class="headerlink" title="useEffect第二个参数的执行规则"></a>useEffect第二个参数的执行规则</h5><ul>
<li>不传参数：每次 render 后都执行</li>
<li>空数组：传入第二个参数，每次 render 后比较数组的值没变化，不会在执行，等同于类组件中的 componentDidMount。故只会在第一次render的执行一次。</li>
<li>一个值的数组：比较该值有变化就执行</li>
<li>多个值的数组：会比较每一个值，有一个不相等就执行</li>
<li>传入的为数组&#x2F;函数&#x2F;对象：第一次渲染以及每次更新渲染后都执行。因为useEffect执行的是浅层比较（[…]&#x3D;&#x3D;&#x3D;[…] false）。</li>
</ul>
<h3 id="react中引入CSS的方式"><a href="#react中引入CSS的方式" class="headerlink" title="react中引入CSS的方式"></a>react中引入CSS的方式</h3><ul>
<li>在组件内直接使用</li>
<li>组件中引入 .css 文件</li>
<li>组件中引入 .module.css 文件</li>
<li>CSS in JS</li>
</ul>
<h4 id="在组件中直接使用"><a href="#在组件中直接使用" class="headerlink" title="在组件中直接使用"></a>在组件中直接使用</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> div1 = &#123;</span><br><span class="line">  <span class="attr">width</span>: <span class="string">&quot;300px&quot;</span>,</span><br><span class="line">  <span class="attr">margin</span>: <span class="string">&quot;30px auto&quot;</span>,</span><br><span class="line">  <span class="attr">backgroundColor</span>: <span class="string">&quot;#44014C&quot;</span>,  <span class="comment">//驼峰法</span></span><br><span class="line">  <span class="attr">minHeight</span>: <span class="string">&quot;200px&quot;</span>,</span><br><span class="line">  <span class="attr">boxSizing</span>: <span class="string">&quot;border-box&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;div1&#125;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;backgroundColor:</span>&quot;<span class="attr">red</span>&quot;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    );</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">export default Test;</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>内联样式, 样式之间不会有冲突</li>
<li>可以动态获取当前state中的状态</li>
</ul>
<p>缺点：</p>
<ul>
<li>写法上都需要使用驼峰标识</li>
<li>某些样式没有提示</li>
<li>大量的样式, 代码混乱</li>
<li>某些样式无法编写(比如伪类&#x2F;伪元素)</li>
</ul>
<h4 id="组件中引入CSS文件"><a href="#组件中引入CSS文件" class="headerlink" title="组件中引入CSS文件"></a>组件中引入CSS文件</h4><p>App.css</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.desc</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件中引入</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">PureComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">PureComponent</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span> <span class="attr">className</span>=<span class="string">&quot;title&quot;</span>&gt;</span>我是App的标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;desc&quot;</span>&gt;</span>我是App中的一段文字描述&lt;/p &gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    )</span></span><br><span class="line"><span class="language-xml">  &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>样式是全局生效，样式之间会互相影响</li>
</ul>
<h4 id="组件中引入-module-css文件"><a href="#组件中引入-module-css文件" class="headerlink" title="组件中引入.module.css文件"></a>组件中引入.module.css文件</h4><p>​		将<code>css</code>文件作为一个模块引入，这个模块中的所有<code>css</code>，只作用于当前组件，不会影响当前组件的后代组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">PureComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./Home&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.module.css&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>引用的类名，不能使用连接符(.xxx-xx)，在 JavaScript 中是不识别的</li>
<li>所有的 className 都必须<strong>使用 {style.className}</strong> 的形式来编写</li>
<li>不方便动态来修改某些样式，依然需要使用内联样式的方式；</li>
</ul>
<h4 id="CSS-in-JS"><a href="#CSS-in-JS" class="headerlink" title="CSS in JS"></a>CSS in JS</h4><p>​		CSS-in-JS， 是指一种模式，其中<code>CSS</code>由 <code>JavaScript</code>生成而不是在外部文件中定义。此功能并不是 React 的一部分，而是由第三方库提供，例如：</p>
<ul>
<li>styled-components</li>
<li>emotion</li>
<li>glamorous</li>
</ul>
<h5 id="styled-components基本使用"><a href="#styled-components基本使用" class="headerlink" title="styled-components基本使用"></a>styled-components基本使用</h5><p>本质是通过函数的调用，最终创建出一个组件：</p>
<ul>
<li>这个组件会被自动添加上一个不重复的class</li>
<li>styled-components会给该class添加相关的样式</li>
</ul>
<p>基本使用如下：</p>
<p>创建一个<code>style.js</code>文件用于存放样式组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SelfLink</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  height: 50px;</span></span><br><span class="line"><span class="string">  border: 1px solid red;</span></span><br><span class="line"><span class="string">  color: yellow;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SelfButton</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  height: 150px;</span></span><br><span class="line"><span class="string">  width: 150px;</span></span><br><span class="line"><span class="string">  color: <span class="subst">$&#123;props =&gt; props.color&#125;</span>;</span></span><br><span class="line"><span class="string">  background-image: url(<span class="subst">$&#123;props =&gt; props.src&#125;</span>);</span></span><br><span class="line"><span class="string">  background-size: 150px 150px;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>

<p>引入</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">SelfLink</span>, <span class="title class_">SelfButton</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./style&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">     <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">SelfLink</span> <span class="attr">title</span>=<span class="string">&quot;People&#x27;s Republic of China&quot;</span>&gt;</span>app.js<span class="tag">&lt;/<span class="name">SelfLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">SelfButton</span> <span class="attr">color</span>=<span class="string">&quot;palevioletred&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &quot;<span class="attr">pink</span>&quot; &#125;&#125; <span class="attr">src</span>=<span class="string">&#123;fist&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          SelfButton</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">SelfButton</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Test</span>;</span><br></pre></td></tr></table></figure>



<h3 id="react组件间过渡动画"><a href="#react组件间过渡动画" class="headerlink" title="react组件间过渡动画"></a>react组件间过渡动画</h3><h4 id="是什么？-8"><a href="#是什么？-8" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		当一个组件在显示与消失过程中存在过渡动画，可以很好的增加用户的体验。在<code>react</code>中实现过渡动画效果会有很多种选择，如<code>react-transition-group</code>，<code>react-motion</code>，<code>Animated</code>，以及原生的<code>CSS</code>都能完成切换动画。</p>
<h4 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h4><p>​		在<code>react</code>中，<code>react-transition-group</code>是一种很好的解决方案，其为元素添加<code>enter</code>，<code>enter-active</code>，<code>exit</code>，<code>exit-active</code>这一系列勾子。可以帮助我们方便的实现组件的入场和离场动画。</p>
<p>其主要提供了三个主要的组件：</p>
<ul>
<li>CSSTransition：在前端开发中，结合 CSS 来完成过渡动画效果</li>
<li>SwitchTransition：两个组件显示和隐藏切换时，使用该组件</li>
<li>TransitionGroup：将多个动画组件包裹在其中，一般用于列表中元素的动画</li>
</ul>
<h3 id="Redux工作原理"><a href="#Redux工作原理" class="headerlink" title="Redux工作原理"></a>Redux工作原理</h3><h4 id="是什么？-9"><a href="#是什么？-9" class="headerlink" title="是什么？"></a>是什么？</h4><p>​	将所有状态进行集中管理，当需要更新状态的时候，只需要对这个管理集中处理，而不用去关心状态是如何分发到每一个组件内部的。</p>
<h4 id="redux遵循的原则："><a href="#redux遵循的原则：" class="headerlink" title="redux遵循的原则："></a>redux遵循的原则：</h4><ul>
<li>单一数据源：state以单一对象存储在store对象中</li>
<li>state 是只读的：只有get，没有set</li>
<li>使用纯函数来执行修改：使用reducer执行state更新</li>
</ul>
<h4 id="redux工作流程"><a href="#redux工作流程" class="headerlink" title="redux工作流程"></a>redux工作流程</h4><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic5.png" alt="redux原理图" style="zoom:75%;">

<p>​		View在redux中会派发action方法；action通过store的dispatch方法会派发给store；store接收action，连同之前的state，一起传递给reducer；reducer返回新的数据给store；store去改变自己的state。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>创建store</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span> <span class="comment">// 引入一个第三方的方法</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer) <span class="comment">// 创建数据的公共存储区域</span></span><br><span class="line"><span class="comment">//派发action之后，可以通过store.subscribe监听store的变化</span></span><br><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="title function_">getState</span>());</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 修改store中的state</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;INCREMENT&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// console.log(store.getState());</span></span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;DECREMENT&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// console.log(store.getState());</span></span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;ADD_NUMBER&quot;</span>,</span><br><span class="line">  <span class="attr">number</span>: <span class="number">5</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>创建reducer，<code>reducer</code>本质就是一个函数，接收两个参数<code>state</code>，<code>action</code>，返回<code>state</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//reducer是一个纯函数，不需要直接修改state</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state = initialState, action</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;INCREMENT&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">counter</span>: state.<span class="property">counter</span> + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;DECREMENT&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">counter</span>: state.<span class="property">counter</span> - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;ADD_NUMBER&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;...state, <span class="attr">counter</span>: state.<span class="property">counter</span> + action.<span class="property">number</span>&#125;</span><br><span class="line">    <span class="attr">default</span>: </span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>store.getState()</code>可以来获取当前<code>state</code></p>
<h4 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h4><ul>
<li><p>一类特别的函数：只要是同样的输入，必定得到同样的输出</p>
</li>
<li><p>需要遵守的约束</p>
<ul>
<li>不得改写参数数据</li>
<li>不会产生任何副作用，例如网络请求，输入和输出设备</li>
<li>不能调用Date.now()或Math.random()等不纯的方法</li>
</ul>
</li>
<li><p>redux的reducer必须是一个纯函数</p>
</li>
</ul>
<h3 id="redux中间件"><a href="#redux中间件" class="headerlink" title="redux中间件"></a>redux中间件</h3><h4 id="是什么？-10"><a href="#是什么？-10" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		中间件（Middleware）是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。redux是JS库而不是react组件库。</p>
<p>​		<code>Redux</code>整个工作流程，当<code>action</code>发出之后，<code>reducer</code>立即算出<code>state</code>，整个过程是一个同步的操作。如果需要支持异步操作，或者支持错误处理、日志监控，这个过程就可以用上中间件。<code>Redux</code>中，<strong>中间件就是在<code>dispatch</code>过程</strong>，在分发<code>action</code>进行拦截处理。</p>
<p>​		中间件本质上是一个函数，对<code>store.dispatch</code>方法进行了改造，在发出 <code>Action</code>和执行 <code>Reducer</code>这两步之间，添加了其他功能。</p>
<h4 id="常见的中间件"><a href="#常见的中间件" class="headerlink" title="常见的中间件"></a>常见的中间件</h4><p>​		中间件需要通过<code>applyMiddlewares</code>进行注册，作用是将所有的中间件组成一个数组，依次执行，然后作为第二个参数传入到<code>createStore</code>中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(thunk, logger)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>常用中间件：</p>
<ul>
<li>redux-chunk：用于异步操作</li>
<li>redux-logger：用于日志记录</li>
</ul>
<h5 id="redux-chunk"><a href="#redux-chunk" class="headerlink" title="redux-chunk"></a>redux-chunk</h5><p>​		异步处理中间件</p>
<p>redux-chunk源码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createThunkMiddleware</span>(<span class="params">extraArgument</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">action</span>(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">next</span>(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> thunk = <span class="title function_">createThunkMiddleware</span>();</span><br><span class="line">thunk.<span class="property">withExtraArgument</span> = createThunkMiddleware;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk;</span><br></pre></td></tr></table></figure>

<p>翻译成ES5的写法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createThunkMiddleware</span>(<span class="params">extraArgument</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">&#123; dispatch, getState &#125;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">next</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">action</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_">action</span>(dispatch, getState, extraArgument);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">next</span>(action);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		redux-thunk最重要的思想，<strong>就是可以接受一个返回函数的action creator。</strong>如果这个action creator 返回的是一个函数，就执行它，如果不是，就按照原来的next(action)执行。</p>
<p>​		正因为这个action creator可以返回一个函数，那么就可以在这个函数中执行一些异步的操作。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">addCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">type</span>: <span class="variable constant_">ADD_COUNT</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">addCountAsync</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">           <span class="title function_">dispatch</span>(<span class="title function_">addCount</span>())</span><br><span class="line">        &#125;,<span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<code>addCountAsync</code>这个action creator就返回了一个函数，将dispatch作为函数的第一个参数传递进去，在函数内进行异步操作就可以了。</p>
<h5 id="redux-logger"><a href="#redux-logger" class="headerlink" title="redux-logger"></a>redux-logger</h5><p>实现日志记录</p>
<h3 id="在react项目中使用redux"><a href="#在react项目中使用redux" class="headerlink" title="在react项目中使用redux"></a>在react项目中使用redux</h3><h4 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h4><p>react-redux将组件分成：</p>
<ul>
<li>容器组件：存在逻辑处理</li>
<li>UI 组件：只负责现显示和交互，内部不处理逻辑，状态由外部控制</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>react-redux两大核心：</p>
<ul>
<li>Provider</li>
<li>connection</li>
</ul>
<h5 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h5><p>​		在<code>redux</code>中存在一个<code>store</code>用于存储<code>state</code>，如果将这个<code>store</code>存放在顶层元素中，其他组件都被包裹在顶层元素之上。那么所有的组件都能够受到<code>redux</code>的控制，都能够获取到<code>redux</code>中的数据。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Provider</span> store = &#123;store&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line">&lt;<span class="title class_">Provider</span>&gt;</span><br></pre></td></tr></table></figure>

<h5 id="connection"><a href="#connection" class="headerlink" title="connection"></a>connection</h5><p><code>connect</code>方法将<code>store</code>上的<code>getState</code>和 <code>dispatch</code>包装成组件的<code>props</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="comment">//用法</span></span><br><span class="line"><span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="title class_">MyComponent</span>)</span><br></pre></td></tr></table></figure>

<h5 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps"></a>mapStateToProps</h5><p>​		把<code>redux</code>中的数据映射到<code>react</code>中的<code>props</code>中去</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = (<span class="params">state</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// prop : state.xxx  | 意思是将state中的某个数据映射到props中</span></span><br><span class="line">        <span class="attr">foo</span>: state.<span class="property">bar</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组件中获取数据</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">         <span class="comment">// 这样子渲染的其实就是state.bar的数据了</span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>this.props.foo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span> = <span class="title function_">connect</span>()(<span class="title class_">Foo</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Foo</span></span><br></pre></td></tr></table></figure>

<h5 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps"></a>mapDispatchToProps</h5><p>​	将<code>redux</code>中分发action的函数映射到组件内部的<code>props</code>中</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapDispatchToProps</span> = (<span class="params">dispatch</span>) =&gt; &#123; <span class="comment">// 默认传递参数就是dispatch</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">dispatch</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;increatment&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在组件中获取方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">         </span><br><span class="line">             <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span> = <span class="string">&#123;this.props.onClick&#125;</span>&gt;</span>点击increase<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span> = <span class="title function_">connect</span>()(<span class="title class_">Foo</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Foo</span>;</span><br></pre></td></tr></table></figure>



<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><h4 id="按角色组织-MVC"><a href="#按角色组织-MVC" class="headerlink" title="按角色组织(MVC)"></a>按角色组织(MVC)</h4><p>角色如下：</p>
<ul>
<li>reducers</li>
<li>actions</li>
<li>components</li>
<li>containers</li>
</ul>
<h4 id="按功能组织"><a href="#按功能组织" class="headerlink" title="按功能组织"></a>按功能组织</h4><p>​		使用<code>redux</code>使用功能组织项目，也就是把完成同一应用功能的代码放在一个目录下，一个应用功能包含多个角色的代码</p>
<h3 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h3><h4 id="是什么？-11"><a href="#是什么？-11" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		用于实现无刷新的条件下切换显示不同的页面。路由的本质就是页面的<code>URL</code>发生改变时，页面的显示结果可以根据<code>URL</code>的变化而变化，但是页面不会刷新。</p>
<p>因此，可以通过前端路由可以实现单页(SPA)应用</p>
<p><code>react-router</code>主要分成了几个不同的包：</p>
<ul>
<li>react-router: 实现了路由的核心功能</li>
<li>react-router-dom： 基于 react-router，加入了在浏览器运行环境下的一些功能</li>
<li>react-router-native：基于 react-router，加入了 react-native 运行环境下的一些功能</li>
<li>react-router-config: 用于配置静态路由的工具库</li>
</ul>
<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><ul>
<li>BrowserRouter、HashRouter</li>
<li>Route</li>
<li>Link、NavLink</li>
<li>switch</li>
<li>redirect</li>
</ul>
<h5 id="BrowserRouter、HashRouter区别"><a href="#BrowserRouter、HashRouter区别" class="headerlink" title="BrowserRouter、HashRouter区别"></a>BrowserRouter、HashRouter区别</h5><ol>
<li>底层原理不一样<br> BrowserRouter使用的是H5的history API，不兼容IE9及以下版本<br> HashRouter使用的是URL的哈希值</li>
<li>path表现形式不一样<br> BrowserRouter的路径中没有#，e.g. localhost:3000&#x2F;demo&#x2F;test<br> HashRouter的路径中包含#, e.g. localhost:3000&#x2F;#&#x2F;demo&#x2F;test</li>
<li>刷新后对路由state参数的影响<br> BrowserRouter没有任何影响，因为state保存在history对象中<br> HashRouter刷新后会导致路由state参数的丢失，因为其没有使用history</li>
<li>备注：HashRouter可以用于解决一些路径错误相关的问题，例如样式丢失问题</li>
</ol>
<h5 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h5><p><code>Route</code>用于路径的匹配，然后进行组件的渲染，对应的属性如下：</p>
<ul>
<li>path 属性：用于设置匹配到的路径</li>
<li>component 属性：设置匹配到路径后，渲染的组件</li>
<li>render 属性：设置匹配到路径后，渲染的内容</li>
<li>exact 属性：开启精准匹配，只有精准匹配到完全一致的路径，才会渲染对应的组件</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/&quot;</span> render=&#123;<span class="function">() =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="Link、NavLink"><a href="#Link、NavLink" class="headerlink" title="Link、NavLink"></a>Link、NavLink</h5><p>Link和NavLink用于路径跳转，其中NavLink是在Link基础之上增加了一些样式属性，例如当组件被选中时，发生样式变化就可以使用NavLink设置：</p>
<ul>
<li>activeStyle：活跃时（匹配时）的样式</li>
<li>activeClassName：活跃时添加的class</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">NavLink</span> to=<span class="string">&quot;/&quot;</span> exact activeStyle=&#123;&#123;<span class="attr">color</span>: <span class="string">&quot;red&quot;</span>&#125;&#125;&gt;首页&lt;/<span class="title class_">NavLink</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">activeStyle</span>=<span class="string">&#123;&#123;color:</span> &quot;<span class="attr">red</span>&quot;&#125;&#125;&gt;</span>关于<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;/profile&quot;</span> <span class="attr">activeStyle</span>=<span class="string">&#123;&#123;color:</span> &quot;<span class="attr">red</span>&quot;&#125;&#125;&gt;</span>我的<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="redirect"><a href="#redirect" class="headerlink" title="redirect"></a>redirect</h5><p>路由重定向，当这个组件出现时，会执行跳转到对应的to路径中</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">About</span> = (<span class="params">&#123;</span></span><br><span class="line"><span class="params">  match: &#123;</span></span><br><span class="line"><span class="params">    params: &#123; name &#125;,</span></span><br><span class="line"><span class="params">  &#125;,</span></span><br><span class="line"><span class="params">&#125;</span>) =&gt; (</span><br><span class="line">  <span class="comment">// props.match.params.name</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;name !== &quot;tom&quot; ? <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span> /&gt;</span> : null&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>About &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">FakeText</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>重定向与link的区别在于，link可以用浏览器的回退按钮返回上一级，而重定向不可以</p>
<h5 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h5><p>当匹配到第一个组件的时候，后面的组件就不应该继续匹配</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/profile&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Profile&#125;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/:userid&quot;</span> <span class="attr">component</span>=<span class="string">&#123;User&#125;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">component</span>=<span class="string">&#123;NoMatch&#125;</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="react-router中的hooks"><a href="#react-router中的hooks" class="headerlink" title="react-router中的hooks"></a>react-router中的hooks</h4><ul>
<li>useHistory</li>
<li>useParams</li>
<li>useLocation</li>
</ul>
<h5 id="useHistory"><a href="#useHistory" class="headerlink" title="useHistory"></a>useHistory</h5><p><code>useHistory</code>可以让组件内部直接访问<code>history</code>，无须通过<code>props</code>获取</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useHistory &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Contact</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> history = <span class="title function_">useHistory</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> history.push(&quot;/&quot;)&#125;&gt;Go to home<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="useParams"><a href="#useParams" class="headerlink" title="useParams"></a>useParams</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">About</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = <span class="title function_">useParams</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// props.match.params.name</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;name !== &quot;John Doe&quot; ? <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span> /&gt;</span> : null&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>About &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Route</span> <span class="attr">component</span>=<span class="string">&#123;Contact&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="useLocation"><a href="#useLocation" class="headerlink" title="useLocation"></a>useLocation</h5><p><code>useLocation</code> 会返回当前 <code>URL</code>的 <code>location</code>对象</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useLocation &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Contact</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname &#125; = <span class="title function_">useLocation</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Current URL: &#123;pathname&#125;&lt;/p &gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  );</span></span><br><span class="line"><span class="language-xml">&#125;;</span></span><br></pre></td></tr></table></figure>

<h3 id="路由传递参数的形式"><a href="#路由传递参数的形式" class="headerlink" title="路由传递参数的形式"></a>路由传递参数的形式</h3><ul>
<li>params参数</li>
<li>search参数</li>
<li>state参数</li>
</ul>
<h4 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">路由链接(携带参数)：&lt;Link to=&#x27;/demo/test/tom/18&#x27;&gt;detail&lt;/Link&gt;</span><br><span class="line">注册路由(声明接收)：&lt;Route path=&#x27;/demo/test/:name/:age&#x27; component=&#123;Test&#125;&gt;&lt;/Route&gt;</span><br><span class="line">接收参数：const &#123;name, age&#125; = this.props.match.params</span><br></pre></td></tr></table></figure>

<h4 id="search参数"><a href="#search参数" class="headerlink" title="search参数"></a>search参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">路由链接(携带参数)：&lt;Link to=&#x27;/demo/test/?name=tom&amp;age=18&#x27;&gt;detail&lt;/Link&gt;</span><br><span class="line">注册路由(无需声明，正常注册即可)：&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;&gt;&lt;/Route&gt;</span><br><span class="line">接收参数：this.props.location.search</span><br><span class="line">备注：获取到的search是urlencoded编码字符串，需要借助querystring.parse解析</span><br></pre></td></tr></table></figure>

<h4 id="state参数"><a href="#state参数" class="headerlink" title="state参数"></a>state参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">路由链接(携带参数)：&lt;Link to=&#123;&#123;pathname: &#x27;/demo/test&#x27;, state:&#123;name: &#x27;tome&#x27;, age: 18&#125;&#125;&#125;&gt;&lt;/Link&gt;</span><br><span class="line">注册路由(无需声明，正常注册即可)：&lt;Route path=&quot;/demo/test&quot; component=&#123;Test&#125;&gt;&lt;/Route&gt;</span><br><span class="line">接收参数：this.props.location.state</span><br><span class="line">备注：刷新也可以保留参数</span><br></pre></td></tr></table></figure>

<h4 id="路由中的对象"><a href="#路由中的对象" class="headerlink" title="路由中的对象"></a>路由中的对象</h4><ul>
<li>history对象</li>
<li>match对象</li>
<li>location对象</li>
</ul>
<h5 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h5><p>​		包含了组件可以使用的各种路由系统的方法，常用的有push和replace，两者都是跳转页面，但是replace不会引起页面的刷新，仅仅改变url。</p>
<h5 id="match对象"><a href="#match对象" class="headerlink" title="match对象"></a>match对象</h5><p>​	包括了具体的URL信息，在params字段中可以获取到各个路由参数的值</p>
<h5 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h5><p>​	相当于URL的对象形式表示，通过search字段可以获取到url中的query信息</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic6.png" alt="路由对象" style="zoom:50%;">

<h4 id="HashRouter原理"><a href="#HashRouter原理" class="headerlink" title="HashRouter原理"></a>HashRouter原理</h4><p>​		<code>hash</code> 值改变，触发全局 <code>window</code> 对象上的 <code>hashchange</code> 事件。所以 <code>hash</code> 模式路由就是利用 <code>hashchange</code> 事件监听 <code>URL</code> 的变化，从而进行 <code>DOM</code> 操作来模拟页面跳转。</p>
<p>​		<code>HashRouter</code>包裹了整个应用，通过<code>window.addEventListener(&#39;hashChange&#39;,callback)</code>监听<code>hash</code>值的变化，并传递给其嵌套的组件然后通过<code>context</code>将<code>location</code>数据往后代组件传递。</p>
<h4 id="单页面应用路由实现原理"><a href="#单页面应用路由实现原理" class="headerlink" title="单页面应用路由实现原理"></a>单页面应用路由实现原理</h4><p>​		原理是切换URL，监听URL变化，从而渲染不同的页面。主要的方式有history模式和hash模式。</p>
<h5 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h5><ul>
<li>改变路由</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">pushState</span>(state, title, path)</span><br><span class="line"><span class="comment">// state：一个与指定网址相关的状态对象</span></span><br><span class="line"><span class="comment">// title：新页面的标题</span></span><br><span class="line"><span class="comment">// path：新网址</span></span><br><span class="line">history.<span class="title function_">replaceState</span>(state, title, path)</span><br></pre></td></tr></table></figure>

<ul>
<li>监听路由</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h5><ul>
<li>改变路由</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.location.hash</span><br></pre></td></tr></table></figure>

<ul>
<li>监听路由</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;hashchange&#x27;, function(e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Router与Route的区别"><a href="#Router与Route的区别" class="headerlink" title="Router与Route的区别"></a>Router与Route的区别</h4><p>​		Router接收location变化，派发更新流。也就是把props.history.location等路由信息传递下去。一个项目应该有一个根Router，来产生切换路由组件之前的更新作用。如果存在多个Router会造成路由切换页面不更新的情况。</p>
<p>​		Route匹配路径渲染组件。作为路由组件的容器，可以根据URL将实际的组件渲染出来。通过<code>RouterContext.Consumer</code>取出上一级的location,match等信息，并作为props传递给页面组件，使得可以在页面组件中的props中获取location,match等信息。</p>
<h3 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h3><h4 id="是什么？-12"><a href="#是什么？-12" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		指一旦创建，就不能再被更改的数据。对Immutable对象的任何修改、增加或删除操作都会返回一个新的Immutable对象。</p>
<p>​		Immutable实现的原理是Persistent Data Structure(持久化数据结构)：</p>
<ul>
<li>用一种数据结构来保存数据</li>
<li>当数据被修改时，会返回一个对象，但是新的对象会尽可能的利用之前的数据结构而不会对内存造成浪费</li>
</ul>
<p>​		也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变，同时为了避免 <code>deepCopy</code>把所有节点都复制一遍带来的性能损耗，<code>Immutable</code> 使用了 <code>Structural Sharing</code>（结构共享）。如果对象树中一个节点发生变化，<strong>只修改这个节点和受它影响的父节点</strong>，其它节点则进行共享。</p>
<p>​		内部提供了一套完整的 Persistent Data Structure，还有很多易用的数据类型，如<code>Collection</code>、<code>List</code>、<code>Map</code>、<code>Set</code>、<code>Record</code>、<code>Seq</code>，其中：</p>
<ul>
<li>List: 有序索引集，类似 JavaScript 中的 Array</li>
<li>Map: 无序索引集，类似 JavaScript 中的 Object</li>
<li>Set: 没有重复值的集合</li>
</ul>
<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>依赖于immutable.js库。</p>
<p>主要方法：</p>
<ul>
<li>fromJS：将一个js数据转换为Immutable类型的数据</li>
<li>toJS：将一个Immutable数据转换为JS类型的数据</li>
<li>is：对两个对象进行比较</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Map</span>, is &#125; <span class="keyword">from</span> <span class="string">&#x27;immutable&#x27;</span></span><br><span class="line"><span class="keyword">const</span> map1 = <span class="title class_">Map</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">1</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> map2 = <span class="title class_">Map</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">1</span> &#125;)</span><br><span class="line">map1 === map2   <span class="comment">//false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(map1, map2) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">is</span>(map1, map2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>get(key)：对数据或对象取值</li>
<li>getIn([])：对嵌套对象或数组取值，传参为数组，表示位置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let abs = Immutable.fromJS(&#123;a: &#123;b:2&#125;&#125;);</span><br><span class="line">abs.getIn([&#x27;a&#x27;, &#x27;b&#x27;]) // 2</span><br><span class="line">abs.getIn([&#x27;a&#x27;, &#x27;c&#x27;]) // 子级没有值</span><br><span class="line"></span><br><span class="line">let arr = Immutable.fromJS([1 ,2, 3, &#123;a: 5&#125;]);</span><br><span class="line">arr.getIn([3, &#x27;a&#x27;]); // 5</span><br><span class="line">arr.getIn([3, &#x27;c&#x27;]); // 子级没有值</span><br></pre></td></tr></table></figure>

<ul>
<li>setIn([], value)：赋值，数组表示位置，value为所赋的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Immutable from &#x27;immutable&#x27;;</span><br><span class="line">foo = Immutable.fromJS(&#123;a: &#123;b: 1&#125;&#125;);</span><br><span class="line">bar = foo.setIn([&#x27;a&#x27;, &#x27;b&#x27;], 2);   // 使用 setIn 赋值</span><br><span class="line">console.log(foo.getIn([&#x27;a&#x27;, &#x27;b&#x27;]));  //使用getIn 取值，打印 1</span><br><span class="line">console.log(foo === bar);  //  打印 false</span><br></pre></td></tr></table></figure>

<h4 id="Immutable在React中的应用"><a href="#Immutable在React中的应用" class="headerlink" title="Immutable在React中的应用"></a>Immutable在React中的应用</h4><p>​		使用 <code>Immutable</code>可以给 <code>React</code> 应用带来性能的优化，<strong>主要体现在减少渲染的次数</strong>。</p>
<ul>
<li><p>在做<code>react</code>性能优化的时候，为了避免重复渲染，我们会在<code>shouldComponentUpdate()</code>中做对比，当返回<code>true</code>执行<code>render</code>方法。<code>Immutable</code>通过<code>is</code>方法则可以完成对比，而无需通过深度比较的方式比较。</p>
</li>
<li><p>在使用<code>redux</code>过程中也可以结合<code>Immutable</code>，不使用<code>Immutable</code>前修改一个数据需要做一个深拷贝。</p>
</li>
</ul>
<h3 id="render触发时机"><a href="#render触发时机" class="headerlink" title="render触发时机"></a>render触发时机</h3><ul>
<li>setState</li>
<li>useState</li>
</ul>
<p>​		在<code>React</code> 中，类组件只要执行了 <code>setState</code> 方法，就一定会触发 <code>render</code> 函数执行，函数组件使用<code>useState</code>更改状态不一定导致重新<code>render</code>。</p>
<p>​		组件的<code>props</code> 改变了，不一定触发 <code>render</code> 函数的执行，但是如果 <code>props</code> 的值来自于父组件或者祖先组件的 <code>state</code>。在这种情况下，父组件或者祖先组件的 <code>state</code> 发生了改变，就会导致子组件的重新渲染。</p>
<p>​		<strong>所以，一旦执行了<code>setState</code>就会执行<code>render</code>方法，<code>useState</code> 会判断当前值有无发生改变确定是否执行<code>render</code>方法，一旦父组件发生渲染，子组件也会渲染。</strong></p>
<h3 id="提高组件渲染效率"><a href="#提高组件渲染效率" class="headerlink" title="提高组件渲染效率"></a>提高组件渲染效率</h3><p>​		效率低的两个场景：1. 类组件中只要调用setState方法就会导致渲染，而不论state是否发生变化；2. 父组件只要发生了渲染，不论子组件是否改变，子组件都会执行渲染。</p>
<p>​		提高效率的方式：</p>
<ul>
<li>shouldComponentUpdate</li>
<li>PureComponent</li>
<li>React.memo</li>
</ul>
<h4 id="shouldComponentUpdate-nextProps-nextState"><a href="#shouldComponentUpdate-nextProps-nextState" class="headerlink" title="shouldComponentUpdate(nextProps, nextState)"></a>shouldComponentUpdate(nextProps, nextState)</h4><p>​		通过<code>shouldComponentUpdate</code>生命周期函数来比对 <code>state</code>和 <code>props</code>，确定是否要重新渲染。默认情况下返回<code>true</code>表示重新渲染，如果不希望组件重新渲染，返回 <code>false</code> 即可。</p>
<h4 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h4><p>​		跟<code>shouldComponentUpdate</code>原理基本一致，通过对 <code>props</code> 和 <code>state</code>的<strong>浅比较结果</strong>来实现 <code>shouldComponentUpdate</code>。当对象包含复杂的数据结构时，对象深层的数据已改变却不会触发 <code>render</code>。</p>
<h4 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h4><p>​		<code>React.memo</code>用来缓存组件的渲染，避免不必要的更新，其实也<strong>是一个高阶组件</strong>，与 <code>PureComponent</code> 十分类似。但不同的是， <strong><code>React.memo</code> 只能用于函数组件。</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">// Component code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">Button</span>);</span><br></pre></td></tr></table></figure>

<p>通过给memo第二个参数传递比较函数，可以进行深层次的比较。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arePropsEqual</span>(<span class="params">prevProps, nextProps</span>) &#123;</span><br><span class="line">  <span class="comment">// your code</span></span><br><span class="line">  <span class="keyword">return</span> prevProps === nextProps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">memo</span>(<span class="title class_">Button</span>, arePropsEqual);</span><br></pre></td></tr></table></figure>

<p>​		react.memo的缺点：1.在最外层包装整个组件；2.需要手动写一个方法比较那些具体的props不相同才进行重新渲染。这些缺点导致无法实现如下场景：组件不需要整个重新渲染，而是只需要局部渲染。可以使用useMemo实现，只有当依赖项发生改变的时候才会重新触发渲染逻辑。</p>
<h3 id="react性能优化的方法"><a href="#react性能优化的方法" class="headerlink" title="react性能优化的方法"></a>react性能优化的方法</h3><p>主要是从<strong>代码层面、工程层面和框架机制层面</strong>进行优化：</p>
<ul>
<li>避免不必要的render，使用shouldComponentUpdate、PureComponent、React.memo</li>
<li>避免使用内联函数</li>
<li>使用React Fragments避免额外标记</li>
<li>使用Immutable</li>
<li>懒加载组件</li>
<li>事件绑定方式</li>
<li>服务端渲染</li>
</ul>
<h4 id="避免使用内联函数"><a href="#避免使用内联函数" class="headerlink" title="避免使用内联函数"></a>避免使用内联函数</h4><p>若使用内联函数，则每次调用<code>render</code>函数时都会创建一个新的函数实例</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用内联函数</span></span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">inputValue</span>: e.<span class="property">target</span>.<span class="property">value</span>&#125;) &#125;&#125; value=<span class="string">&quot;Click For Inline Function&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>应该在组件内部创建一个函数，并将事件绑定到该函数本身。这样每次调用 <code>render</code> 时就不会创建单独的函数实例。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">InlineFunctionComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  setNewStateData = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">inputValue</span>: e.<span class="property">target</span>.<span class="property">value</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome Guest<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.setNewStateData&#125;</span> <span class="attr">value</span>=<span class="string">&quot;Click For Inline Function&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用Fragments避免额外标签"><a href="#使用Fragments避免额外标签" class="headerlink" title="使用Fragments避免额外标签"></a>使用Fragments避免额外标签</h4><p>​		用户创建新组件时，每个组件需要有一个父标签。父级不能有两个标签，所以顶部要有一个公共标签，所以我们经常在组件顶部添加额外标签<code>div</code>。这个额外标签除了充当父标签之外，并没有其他作用，这时候则可以使用<code>fragement</code>。其不会向组件引入任何额外标记，但它可以作为父级标签的作用。</p>
<h4 id="事件绑定方式"><a href="#事件绑定方式" class="headerlink" title="事件绑定方式"></a>事件绑定方式</h4><p>​		从性能方面考虑，在<code>render</code>方法中使用<code>bind</code>和<code>render</code>方法中使用箭头函数这两种形式在每次组件<code>render</code>的时候都会生成新的方法实例，性能欠缺。</p>
<p>​		而<code>constructor</code>中<code>bind</code>事件与定义阶段使用箭头函数绑定这两种形式只会生成一个方法实例，性能方面会有所改善。</p>
<h4 id="使用Immutable"><a href="#使用Immutable" class="headerlink" title="使用Immutable"></a>使用Immutable</h4><p>​	使用Immutable能减少渲染次数。在做<code>react</code>性能优化的时候，为了避免重复渲染，我们会在<code>shouldComponentUpdate()</code>中做对比，当返回<code>true</code>执行<code>render</code>方法。<code>Immutable</code>通过<code>is</code>方法则可以完成对比，而无需像一样通过深度比较的方式比较。</p>
<h4 id="懒加载组件"><a href="#懒加载组件" class="headerlink" title="懒加载组件"></a>懒加载组件</h4><p>​		从工程方面考虑，<code>webpack</code>存在代码拆分能力，可以为应用创建多个包，并在运行时动态加载，减少初始包的大小。而在<code>react</code>中使用到了<code>Suspense</code>和 <code>lazy</code>组件实现代码拆分功能，基本使用如下。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> johanComponent = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="comment">/* webpackChunkName: &quot;johanComponent&quot; */</span> <span class="string">&#x27;./myAwesome.component&#x27;</span>));</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">johanAsyncComponent</span> = props =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">React.Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">Spinner</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">johanComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">React.Suspense</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h4><p>​		采用服务端渲染端方式，可以使用户更快的看到渲染完成的页面。服务端渲染，需要开启一个<code>node</code>服务，可以使用<code>express</code>、<code>koa</code>等，调用<code>react</code>的<code>renderToString</code>方法，将根组件渲染成字符串，再输出到响应中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">&quot;react-dom/server&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyPage</span> <span class="keyword">from</span> <span class="string">&quot;./MyPage&quot;</span>;</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">write</span>(<span class="string">&quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;</span>);</span><br><span class="line">  res.<span class="title function_">write</span>(<span class="string">&quot;&lt;div id=&#x27;content&#x27;&gt;&quot;</span>);  </span><br><span class="line">  res.<span class="title function_">write</span>(<span class="title function_">renderToString</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">MyPage</span>/&gt;</span></span>));</span><br><span class="line">  res.<span class="title function_">write</span>(<span class="string">&quot;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">  res.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyPage</span> <span class="keyword">from</span> <span class="string">&quot;./MyPage&quot;</span>;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">MyPage</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>));</span><br></pre></td></tr></table></figure>



<h3 id="react服务端渲染"><a href="#react服务端渲染" class="headerlink" title="react服务端渲染"></a>react服务端渲染</h3><h4 id="是什么？-13"><a href="#是什么？-13" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		SSR（Server-Side Rendering）服务端渲染。指由服务端完成页面的 <code>HTML</code> 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程。</p>
<p>​		能够解决两个问题：</p>
<ul>
<li>SEO，搜索引擎爬虫抓取工具可以直接查看完全渲染的页面</li>
<li>加速首屏加载，解决首屏白屏问题</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>手动搭建一个SSR框架</li>
<li>使用成熟的SSR框架，如Next.js</li>
</ul>
<h4 id="手动搭建"><a href="#手动搭建" class="headerlink" title="手动搭建"></a>手动搭建</h4><p>​		首先通过<code>express</code>启动一个<code>app.js</code>文件，用于监听3000端口的请求，当请求根目录时，返回<code>HTML</code>，如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req,res</span>) =&gt;</span> res.<span class="title function_">send</span>(<span class="string">`</span></span><br><span class="line"><span class="string">        &lt;html&gt;</span></span><br><span class="line"><span class="string">           &lt;head&gt;</span></span><br><span class="line"><span class="string">               &lt;title&gt;ssr demo&lt;/title&gt;</span></span><br><span class="line"><span class="string">           &lt;/head&gt;</span></span><br><span class="line"><span class="string">           &lt;body&gt;</span></span><br><span class="line"><span class="string">               Hello world</span></span><br><span class="line"><span class="string">           &lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span>))</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exampleapp listening on port 3000!&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>​		然后再服务器中编写<code>react</code>代码，在<code>app.js</code>中进行应引用</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Home</span> = (<span class="params"></span>) =&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>home<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Home</span></span><br></pre></td></tr></table></figure>

<p>​		为了让服务器能够识别<code>JSX</code>，这里需要使用<code>webpack</code>对项目进行打包转换，创建一个配置文件<code>webpack.server.js</code>并进行相关配置，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)    <span class="comment">//node的path模块</span></span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">&#x27;webpack-node-externals&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">target</span>:<span class="string">&#x27;node&#x27;</span>,</span><br><span class="line">    <span class="attr">mode</span>:<span class="string">&#x27;development&#x27;</span>,           <span class="comment">//开发模式</span></span><br><span class="line">    <span class="attr">entry</span>:<span class="string">&#x27;./app.js&#x27;</span>,             <span class="comment">//入口</span></span><br><span class="line">    <span class="attr">output</span>: &#123;                     <span class="comment">//打包出口</span></span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&#x27;bundle.js&#x27;</span>,     <span class="comment">//打包后的文件名</span></span><br><span class="line">        <span class="attr">path</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;build&#x27;</span>)    <span class="comment">//存放到根目录的build文件夹</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">externals</span>: [<span class="title function_">nodeExternals</span>()],  <span class="comment">//保持node中require的引用方式</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [&#123;                  <span class="comment">//打包规则</span></span><br><span class="line">           <span class="attr">test</span>:   <span class="regexp">/\.js?$/</span>,       <span class="comment">//对所有js文件进行打包</span></span><br><span class="line">           <span class="attr">loader</span>:<span class="string">&#x27;babel-loader&#x27;</span>,  <span class="comment">//使用babel-loader进行打包</span></span><br><span class="line">           <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,<span class="comment">//不打包node_modules中的js文件</span></span><br><span class="line">           <span class="attr">options</span>: &#123;</span><br><span class="line">               <span class="attr">presets</span>: [<span class="string">&#x27;react&#x27;</span>,<span class="string">&#x27;stage-0&#x27;</span>,[<span class="string">&#x27;env&#x27;</span>, &#123; </span><br><span class="line">                                  <span class="comment">//loader时额外的打包规则,对react,JSX，ES6进行转换</span></span><br><span class="line">                    <span class="attr">targets</span>: &#123;</span><br><span class="line">                        <span class="attr">browsers</span>: [<span class="string">&#x27;last 2versions&#x27;</span>]   <span class="comment">//对主流浏览器最近两个版本进行兼容</span></span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;]]</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		借助<code>react-dom</code>提供了服务端渲染的 <code>renderToString</code>方法，负责把<code>React</code>组件解析成<code>html</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span><span class="comment">//引入React以支持JSX的语法</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span><span class="comment">//引入renderToString方法</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span><span class="string">&#x27;./src/containers/Home&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app= <span class="title function_">express</span>()</span><br><span class="line"><span class="keyword">const</span> content = <span class="title function_">renderToString</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span>)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> res.<span class="title function_">send</span>(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">   &lt;head&gt;</span></span><br><span class="line"><span class="string">       &lt;title&gt;ssr demo&lt;/title&gt;</span></span><br><span class="line"><span class="string">   &lt;/head&gt;</span></span><br><span class="line"><span class="string">   &lt;body&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;content&#125;</span></span></span><br><span class="line"><span class="string">   &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span>))</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3001</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exampleapp listening on port 3001!&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>​		某些事件处理的方法，是无法在服务端完成，因此需要将组件代码在浏览器中再执行一遍，这种服务器端和客户端共用一套代码的方式就称之为<strong>同构</strong>。重构通俗讲就是一套React代码在服务器上运行一遍，到达浏览器又运行一遍：</p>
<ul>
<li>服务端渲染完成页面结构</li>
<li>浏览器端渲染完成事件绑定</li>
</ul>
<p>​		浏览器实现事件绑定的方式为让浏览器去拉取<code>JS</code>文件执行，让<code>JS</code>代码来控制，因此需要引入<code>script</code>标签。通过<code>script</code>标签为页面引入客户端执行的<code>react</code>代码，并通过<code>express</code>的<code>static</code>中间件为<code>js</code>文件配置路由。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span><span class="comment">//引入React以支持JSX的语法</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span><span class="string">&#x27;react-dom/server&#x27;</span><span class="comment">//引入renderToString方法</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./src/containers/Home&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>));</span><br><span class="line"><span class="comment">//使用express提供的static中间件,中间件会将所有静态文件的路由指向public文件夹</span></span><br><span class="line"><span class="keyword">const</span> content = <span class="title function_">renderToString</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Home</span>/&gt;</span></span>) </span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>res.<span class="title function_">send</span>(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">   &lt;head&gt;</span></span><br><span class="line"><span class="string">       &lt;title&gt;ssr demo&lt;/title&gt;</span></span><br><span class="line"><span class="string">   &lt;/head&gt;</span></span><br><span class="line"><span class="string">   &lt;body&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;content&#125;</span></span></span><br><span class="line"><span class="string">   &lt;script src=&quot;/index.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">   &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span>))</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3001</span>, <span class="function">() =&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Example app listening on port 3001!&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>在客户端执行以下<code>react</code>代码，新建<code>webpack.client.js</code>作为客户端React代码的<code>webpack</code>配置文件如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)                    <span class="comment">//node的path模块</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>:<span class="string">&#x27;development&#x27;</span>,                         <span class="comment">//开发模式</span></span><br><span class="line">    <span class="attr">entry</span>:<span class="string">&#x27;./src/client/index.js&#x27;</span>,              <span class="comment">//入口</span></span><br><span class="line">    <span class="attr">output</span>: &#123;                                   <span class="comment">//打包出口</span></span><br><span class="line">        <span class="attr">filename</span>:<span class="string">&#x27;index.js&#x27;</span>,                    <span class="comment">//打包后的文件名</span></span><br><span class="line">        <span class="attr">path</span>:path.<span class="title function_">resolve</span>(__dirname,<span class="string">&#x27;public&#x27;</span>)   <span class="comment">//存放到根目录的build文件夹</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [&#123;                               <span class="comment">//打包规则</span></span><br><span class="line">           <span class="attr">test</span>:   <span class="regexp">/\.js?$/</span>,                    <span class="comment">//对所有js文件进行打包</span></span><br><span class="line">           <span class="attr">loader</span>:<span class="string">&#x27;babel-loader&#x27;</span>,               <span class="comment">//使用babel-loader进行打包</span></span><br><span class="line">           <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,             <span class="comment">//不打包node_modules中的js文件</span></span><br><span class="line">           <span class="attr">options</span>: &#123;</span><br><span class="line">               <span class="attr">presets</span>: [<span class="string">&#x27;react&#x27;</span>,<span class="string">&#x27;stage-0&#x27;</span>,[<span class="string">&#x27;env&#x27;</span>, &#123;     </span><br><span class="line">                    <span class="comment">//loader时额外的打包规则,这里对react,JSX进行转换</span></span><br><span class="line">                    <span class="attr">targets</span>: &#123;</span><br><span class="line">                        <span class="attr">browsers</span>: [<span class="string">&#x27;last 2versions&#x27;</span>]   <span class="comment">//对主流浏览器最近两个版本进行兼容</span></span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;]]</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法就能够简单实现首页的<code>react</code>服务端渲染。</p>
<p>在做完初始渲染的时候，一个应用会存在路由的情况，配置信息如下Routers.js：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>                   <span class="comment">//引入React以支持JSX</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>    <span class="comment">//引入路由</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;./containers/Home&#x27;</span>        <span class="comment">//引入Home组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">exact</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>然后可以通过<code>index.js</code>引用路由信息，如下</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDom</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> &#125; <span class="keyword">from</span><span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span><span class="string">&#x27;../Routers&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span>= (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           &#123;Router&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDom</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>​		这时候控制台会存在报错信息，原因在于每个<code>Route</code>组件外面包裹着一层<code>div</code>，但服务端返回的代码中并没有这个<code>div</code>。解决方法只需要将路由信息在服务端执行一遍，使用<code>StaticRouter</code>来替代<code>BrowserRouter</code>，通过<code>context</code>进行参数传递。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">&#x27;express&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span><span class="comment">//引入React以支持JSX的语法</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span><span class="comment">//引入renderToString方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">StaticRouter</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span> <span class="string">&#x27;../Routers&#x27;</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;public&#x27;</span>));</span><br><span class="line"><span class="comment">//使用express提供的static中间件,中间件会将所有静态文件的路由指向public文件夹</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> content  = <span class="title function_">renderToString</span>((</span><br><span class="line">        <span class="comment">//传入当前path</span></span><br><span class="line">        <span class="comment">//context为必填参数,用于服务端渲染参数传递</span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">StaticRouter</span> <span class="attr">location</span>=<span class="string">&#123;req.path&#125;</span> <span class="attr">context</span>=<span class="string">&#123;&#123;&#125;&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           &#123;Router&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">StaticRouter</span>&gt;</span></span></span><br><span class="line">    ))</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">`</span></span><br><span class="line"><span class="string">   &lt;html&gt;</span></span><br><span class="line"><span class="string">       &lt;head&gt;</span></span><br><span class="line"><span class="string">           &lt;title&gt;ssr demo&lt;/title&gt;</span></span><br><span class="line"><span class="string">       &lt;/head&gt;</span></span><br><span class="line"><span class="string">       &lt;body&gt;</span></span><br><span class="line"><span class="string">       &lt;div id=&quot;root&quot;&gt;<span class="subst">$&#123;content&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string">       &lt;script src=&quot;/index.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">       &lt;/body&gt;</span></span><br><span class="line"><span class="string">   &lt;/html&gt;</span></span><br><span class="line"><span class="string">    `</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3001</span>, <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exampleapp listening on port 3001!&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="简化原理"><a href="#简化原理" class="headerlink" title="简化原理"></a>简化原理</h4><p>​		<code>node server</code> 接收客户端请求，得到当前的请求<code>url</code> 路径，然后在已有的路由表内查找到对应的组件，拿到需要请求的数据，将数据作为 <code>props</code>、<code>context</code>或者<code>store</code> 形式传入组件。</p>
<p>​		然后基于 <code>react</code> 内置的服务端渲染方法 <code>renderToString()</code>把组件渲染为 <code>html</code>字符串，再把最终的 <code>html</code>进行输出前需要将数据注入到浏览器端。</p>
<p>​		浏览器开始进行渲染和节点对比，然后执行完成组件内事件绑定和一些交互，浏览器重用了服务端输出的 <code>html</code> 节点，整个流程结束。</p>
<h3 id="Fiber架构"><a href="#Fiber架构" class="headerlink" title="Fiber架构"></a>Fiber架构</h3><h4 id="JS单线程的问题"><a href="#JS单线程的问题" class="headerlink" title="JS单线程的问题"></a>JS单线程的问题</h4><p>​		JS是单线程的，在浏览器的环境中，需要负责页面的JS解析、执行、绘制、事件处理、静态资源加载和处理等。JS引擎和页面渲染引擎处于同一个主线程，两者的执行是互斥的。单线程表明JS同时只能执行一个任务，如果有个任务长期霸占CPU，那么其他任务都无法执行，浏览器就会呈现卡死的状态，这样会降低用户的体验感。</p>
<p>对于前端框架来说，解决这个问题的三种途径：</p>
<ul>
<li>优化每个任务，让他有多快就多快，相当于是在挤压CPU的运算量。vue就是基于这种想法的，使用<code>模板</code>来对任务进行优化，并结合响应式机制让vue精确地进行节点更新。</li>
<li>快速响应用户，让用户觉得够快，不能阻塞用户的交互。react是基于此种思想的。</li>
<li>尝试worker多线程。这种方法需要保持状态和视图的一致性比较麻烦。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 多线程之间的通信实际上需要借助主线程，子线程A将消息发送给主线程，然后主线程将A线程发送的消息发送给B</span><br><span class="line">// index.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	var sendWorker = new Worker(&#x27;send.js&#x27;);</span><br><span class="line">	var receiveWorker = new Worker(&#x27;receive.js&#x27;);</span><br><span class="line">	sendWorker.onmessage = function(msg)&#123;</span><br><span class="line">		// 接收到消息之后马上发给接受线程</span><br><span class="line">		receiveWorker.postMessage(msg.data);</span><br><span class="line">	&#125;</span><br><span class="line">	function sendMessage()&#123;</span><br><span class="line">		sendWorker.postMessage(&quot;&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// send.js</span><br><span class="line">onmessage = function(msg)&#123;</span><br><span class="line">	postMessage(&#x27;message&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">// receive.js</span><br><span class="line">onmessage = function(msg)&#123;</span><br><span class="line">	console.log(msg.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic13.png" alt="web worker"></p>
<h4 id="reconcilation调和过程及为什么需要Fiber"><a href="#reconcilation调和过程及为什么需要Fiber" class="headerlink" title="reconcilation调和过程及为什么需要Fiber"></a>reconcilation调和过程及为什么需要Fiber</h4><p>​		react递归比对虚拟树，找出需要变动的节点，然后进行更新的过程称为调和过程。</p>
<p>​		在调和过程期间，react会霸占浏览器资源，可能导致用户触发的事件得不到响应或者导致掉帧，从而使用户感知到卡顿。调和过程是CPU密集型操作，相当于是长进程，不能让长进程长期霸占资源。</p>
<p>​		为了使浏览器合理分配CPU资源，提高用户响应速率，同时兼顾任务执行效率。react通过fiber架构，使reconcilation过程变成可中断的，适时让出CPU执行权。</p>
<h4 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h4><p>React Fiber 在React 16 版本发布</p>
<p>在<code>react</code>中，主要做了以下的操作：</p>
<ul>
<li>为每个任务增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li>
<li>增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li>
<li>dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li>
</ul>
<p>从架构角度来看，<code>Fiber</code> 是对 <code>React</code>核心算法（即调和过程）的重写</p>
<p>从编码角度来看，<code>Fiber</code>是 <code>React</code>内部所定义的一种数据结构，它是 <code>Fiber</code>树结构的节点单位，也就是 <code>React 16</code> 新架构下的虚拟<code>DOM</code></p>
<p>一个 <code>fiber</code>就是一个 <code>JavaScript</code>对象，包含了元素的信息、该元素的更新操作队列、类型。</p>
<h4 id="Fiber如何解决"><a href="#Fiber如何解决" class="headerlink" title="Fiber如何解决"></a>Fiber如何解决</h4><p>​		首先 React 中的渲染更新任务会被切割为多个子任务，对不同的任务赋予不同的优先级，分批完成。每次只做一小部分，做完看是否还有剩余时间，如果有就继续执行下一个任务；如果没有，挂起当前任务，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。</p>
<p>​		该实现过程是基于 <code>Fiber</code>节点实现。作为静态的数据结构来说，每个 <code>Fiber</code> 节点保存了该组件的类型（函数组件&#x2F;类组件&#x2F;原生组件等等）、对应的 DOM 节点等信息。作为动态的工作单元来说，每个 <code>Fiber</code> 节点保存了本次更新中该组件改变的状态、要执行的工作。</p>
<h4 id="需要明确的问题"><a href="#需要明确的问题" class="headerlink" title="需要明确的问题"></a>需要明确的问题</h4><h5 id="浏览器没有的抢占条件，react只能使用主动让出机制"><a href="#浏览器没有的抢占条件，react只能使用主动让出机制" class="headerlink" title="浏览器没有的抢占条件，react只能使用主动让出机制"></a>浏览器没有的抢占条件，react只能使用主动让出机制</h5><p>​		一是浏览器中没有类似进程的概念，’任务‘之间的界限很模糊，没有上下文，所以不具备中断&#x2F;恢复的条件。二是没有抢占的机制，无法中断一个正在执行的程序。所以只能进行合作式调度。由浏览器分配执行时间片(通过<code>requestIdleCallback</code>实现)，react按照约定在这个时间内执行任务，时间到则将控制权还给浏览器。</p>
<h5 id="requestIdleCallback-API"><a href="#requestIdleCallback-API" class="headerlink" title="requestIdleCallback API"></a>requestIdleCallback API</h5><p>​		确定一个合理的运行时长，然后在合适的检查点检测是否超时(比如每执行一个小任务)，如果超时就停止执行，将控制权交还给浏览器。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestIdleCallback</span>(</span><br><span class="line">  <span class="attr">callback</span>: <span class="function">(<span class="params">dealine: IdleDeadline</span>) =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">  option?: &#123;<span class="attr">timeout</span>: <span class="built_in">number</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>​		第一个参数表明，如果浏览器处理完用户输入事件、JS执行、requestAnimation调用、布局Layout、绘制Paint等任务之后，若还有多余时间，就会去调用requestIdleCallback的回调。但是在浏览器繁忙的时候，可能不会有盈余时间，这时候<code>requestIdleCallback</code>回调可能就不会被执行。 为了避免饿死，可以通过requestIdleCallback的第二个参数指定一个超时时间。</p>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h4 id="错误边界是什么？"><a href="#错误边界是什么？" class="headerlink" title="错误边界是什么？"></a>错误边界是什么？</h4><p>​		错误边界是一种react组件，这种组件可以捕获发生在其子组件树任何位置的<strong>JS错误</strong>，并打印这些错误，同时展示降级UI，而不会渲染那些发生崩溃的子组件树。</p>
<p>​		错误边界在<strong>渲染、生命周期方法和整个组件树的构造函数</strong>中捕获错误。</p>
<p>​		形成错误边界的两个条件：</p>
<ul>
<li>使用static getDerivedStateFromError()，抛出错误后，使用此方法渲染备用UI</li>
<li>使用componentDidCatch()，抛出错误后，使用此方法打印错误信息</li>
</ul>
<h4 id="错误边界使用"><a href="#错误边界使用" class="headerlink" title="错误边界使用"></a>错误边界使用</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, errorInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    <span class="title function_">logErrorToMyService</span>(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义降级后的 UI 并渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以把自身组件作为错误边界的子组件，如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ErrorBoundary</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyWidget</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">ErrorBoundary</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h4><p>错误边界无法捕获到下面这些情况的异常：</p>
<ul>
<li>事件处理</li>
<li>异步代码</li>
<li>服务端渲染</li>
<li>自身抛出来的错误</li>
</ul>
<p>对于错误边界无法捕获的异常，是因为其不会在渲染期间触发，并不会导致渲染出现问题，这种情况可以使用<code>js</code>的<code>try...catch...</code>语法。</p>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>react16以前，react是直接递归渲染vdom的，setState触发重新渲染后，对比渲染出的新旧vdom，对差异部分进行dom更新操作</p>
<p>react16以后，为了优化性能，会先把vdom转换成fiber，也就是从树结构转换成链表，然后再进行渲染。整体的渲染流程分成了两个阶段：</p>
<ul>
<li>render阶段：从vdom转换成fiber，并且对需要dom操作的节点打上effectTag标记</li>
<li>commit阶段：对有effectTag标记的fiber节点进行dom操作，并执行所有的effect副作用函数</li>
</ul>
<p>从 vdom 转成 fiber 的过程叫做 reconcile（调和），这个过程是可以打断的，由 scheduler 调度执行。</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic7.png" alt="调和" style="zoom:80%;">

<p>​		diff 算法作用在 reconcile 阶段：</p>
<p>​		第一次渲染不需要 diff，直接 vdom 转 fiber。再次渲染的时候，会产生新的 vdom，这时候要和之前的 fiber 做下对比，决定怎么产生新的 fiber，<strong>对可复用的节点打上修改的标记，剩余的旧节点打上删除标记，新节点打上新增标记</strong>。</p>
<p>​		diff 算法的<strong>目的就是对比两次渲染结果，找到可复用的部分</strong>，然后剩下的该删除删除，该新增新增。</p>
<h3 id="diff具体流程："><a href="#diff具体流程：" class="headerlink" title="diff具体流程："></a>diff具体流程：</h3><p>​		比如父节点下有 A、B、C、D 四个子节点，那渲染出的 vdom 就是这样的：</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic8.png" alt="vdom" style="zoom:80%;">

<p>​		经过 reconcile 之后，会变成这样的 fiber 结构：</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic9.png" alt="fiber" style="zoom:80%;">

<p>​		如果再次渲染的时候，渲染出了 A、C、B、E 的 vdom，这时候怎么处理呢？</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic10.png" alt="acbe" style="zoom:80%;">

<p>​		再次渲染出 vdom 的时候，也要进行 vdom 转 fiber 的 reconcile 阶段，但是要尽量能复用之前的节点。那怎么复用呢？一一对比下不就行了？先把之前的 fiber 节点放到一个 map 里，key 就是节点的 key：</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic11.png" alt="复用" style="zoom:80%;">

<p>​		然后每个新的 vdom 都去这个 map 里查找下有没有可以复用的，找到了的话就移动过来，打上更新的 effectTag：</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic12.png" alt="寻找可复用" style="zoom:80%;">

<p>​		这样遍历完 vdom 节点之后，map 里剩下一些，这些是不可复用的，那就删掉，打上删除的 effectTag；如果 vdom 中还有一些没找到复用节点的，就直接创建，打上新增的 effectTag。</p>
<p>​		这样就实现了更新时的 reconcile，也就是上面的 diff 算法。其实核心就是找到可复用的节点，剩下的旧节点删掉，新节点新增。</p>
<p>​		但有的时候可以再简化一下，比如上次渲染是 A、B、C、D，这次渲染也是 A、B、C、D，那直接顺序对比下就行，没必要建立 map 再找。</p>
<h4 id="diff算法的两次遍历"><a href="#diff算法的两次遍历" class="headerlink" title="diff算法的两次遍历"></a>diff算法的两次遍历</h4><p>​		第一轮遍历**(一一对比)**，一一对比 vdom 和老的 fiber，如果可以复用就处理下一个节点，否则就结束遍历。如果所有的新的 vdom 处理完了，那就把剩下的老 fiber 节点删掉就行。如果还有 vdom 没处理，那就进行第二次遍历：</p>
<p>​		第二轮遍历**(map)**，把剩下的老 fiber 放到 map 里，遍历剩下的 vdom，从 map 里查找，如果找到了，就移动过来。第二轮遍历完了之后，把剩余的老 fiber 删掉，剩余的 vdom 新增。</p>
<h3 id="找到可复用节点后，如何移动呢？"><a href="#找到可复用节点后，如何移动呢？" class="headerlink" title="找到可复用节点后，如何移动呢？"></a>找到可复用节点后，如何移动呢？</h3><p>​		新的 vnode 数组中记录的顺序就是目标的顺序。把对应的节点按照新 vnode 数组的顺序来移动就好了。</p>
<p>​		查找新的 vnode 在旧的 vnode 数组中的下标，如果找到了的话，说明对应的 dom 就是可以复用的，先 patch 一下，然后移动。</p>
<p>​		移动的话判断下标(当前下标)是否在 lastIndex(当前节点在老集合中的下标) 之后，如果本来就在后面，那就不用移动，更新下 lastIndex 就行。</p>
<p>​		如果下标在 lastIndex 之前，说明需要移动，移动到的位置前面分析过了，就是新 vnode 数组 i-1 的后面。这样，我们就完成了 dom 节点的复用和移动。</p>
<h3 id="双端diff-vue2-和-vue3采用的思想，react是单端diff"><a href="#双端diff-vue2-和-vue3采用的思想，react是单端diff" class="headerlink" title="双端diff(vue2 和 vue3采用的思想，react是单端diff)"></a>双端diff(vue2 和 vue3采用的思想，react是单端diff)</h3><p>​		双端 diff 是<strong>头尾指针向中间移动的同时，对比头头、尾尾、头尾、尾头是否可以复用</strong>，如果可以的话就移动对应的 dom 节点。</p>
<p>​		<strong>如果头尾没找到可复用节点就遍历 vnode 数组来查找</strong>，然后移动对应下标的节点到头部。最后还剩下旧的 vnode 就批量删除，剩下新的 vnode 就批量新增。</p>
<h3 id="为什么react不采用双端的思想呢？"><a href="#为什么react不采用双端的思想呢？" class="headerlink" title="为什么react不采用双端的思想呢？"></a>为什么react不采用双端的思想呢？</h3><p>​		因为react的fiber链表不是双向链表，难以进行从后往前的回溯。fiber的单链表使得每个节点容易知道它的父节点、第一个子元素节点和兄弟节点，但不知道它的前一个节点。</p>
<h3 id="react与vue的异同"><a href="#react与vue的异同" class="headerlink" title="react与vue的异同"></a>react与vue的异同</h3><ol>
<li>组件化</li>
</ol>
<h5 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h5><p>​		react和vue都推崇组件化，通过将页面拆分成一个一个小的可复用单元来提高代码的复用率和开发效率。在开发时react和vue有相同的套路，比如都有父子组件传参，都有数据状态管理，都有前端路由等。</p>
<h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><p>​		React推荐的做法是JSX + inline style, 也就是把 HTML 和 CSS 全都写进 JavaScript 中,即 all in js;</p>
<p>​		Vue 推荐的做法是 template 的单文件组件格式(简单易懂，从传统前端转过来易于理解),即 html,css,JS 写在同一个文件(vue也支持JSX写法)</p>
<ol start="2">
<li>虚拟DOM</li>
</ol>
<h5 id="相同点：-1"><a href="#相同点：-1" class="headerlink" title="相同点："></a>相同点：</h5><p>​		生成VDOM树，每次UI更新时，总会根据render重新生成最新的VNode，然后跟以前缓存起来老的VNode进行比对，再使用Diff算法（框架核心）去真正更新真实DOM。</p>
<h5 id="不同点：-1"><a href="#不同点：-1" class="headerlink" title="不同点："></a>不同点：</h5><p>​		react 会自顶向下全diff。vue会跟踪每一个组件的依赖关系,不需要重新渲染整个组件树。</p>
<p>​		react使用单指针比较，vue使用双指针比较。</p>
<ol start="3">
<li>数据驱动视图</li>
</ol>
<h5 id="不同点：-2"><a href="#不同点：-2" class="headerlink" title="不同点："></a>不同点：</h5><p>​		vue的数据驱动是通过MVVM框架实现的。MVVM框架主要包含3个部分:model、view和 viewModel。Model:指的是数据部分，对应到前端就是javascript对象。View:指的是视图部分，对应前端就是dom。ViewModel:就是连接视图与数据的中间件。ViewModel是实现数据驱动视图的核心，当数据变化的时候，ViewModel能够监听到这种变化，并及时的通知view做出修改。同样的，当页面有事件触发时，ViewModel也能够监听到事件，并通知model进行响应。ViewModel就相当于一个观察者，监控着双方的动作，并及时通知对方进行相应的操作。</p>
<p>​		React通过setState实现数据驱动视图，通过setState来引发一次组件的更新过程从而实现页面的重新渲染(除非shouldComponentUpdate返回false)。</p>
<h3 id="组件拆分"><a href="#组件拆分" class="headerlink" title="组件拆分"></a>组件拆分</h3><h4 id="视图组件"><a href="#视图组件" class="headerlink" title="视图组件"></a>视图组件</h4><p>​		主要功能是用于显示信息，并通过回调发送用户输入。</p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>将属性分发给子元素。</li>
<li>拥有将数据从子元素转发到父组件的回调。</li>
<li>通常是函数组件，但如果为了性能，它们需要绑定回调，则可能是类。</li>
<li>一般不使用生命周期方法，性能优化除外。</li>
<li><strong>不</strong>直接存储状态，除了以 UI 为中心的状态，例如动画状态。</li>
<li><strong>不</strong>使用 refs 或直接与 DOM 进行交互（因为 DOM 的改变意味着状态的改变）。</li>
<li><strong>不</strong>修改环境。它们不应该直接将动作发送给 redux 的 store 或者调用 API 等。</li>
<li><strong>不</strong>使用 React 上下文。</li>
</ul>
<h5 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h5><ul>
<li>有 DOM 标记或者样式。</li>
<li>有像列表项这样重复的部分。</li>
<li>有“看起来”像一个盒子或者区域的内容。</li>
<li>JSX 的一部分仅依赖于单个对象作为输入数据。</li>
<li>有一个具有不同区域的大型展示组件。</li>
</ul>
<h4 id="控制组件"><a href="#控制组件" class="headerlink" title="控制组件"></a>控制组件</h4><p>​		主要功能是存储与部分输入相关的状态</p>
<h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>可以存储状态（当与部分输入相关时）。</li>
<li>可以使用 refs 和与 DOM 进行交互。</li>
<li>可以使用生命周期方法。</li>
<li>通常没有任何样式，也没有 DOM 标记。</li>
</ul>
<h5 id="场景：-1"><a href="#场景：-1" class="headerlink" title="场景："></a>场景：</h5><ul>
<li>将部分输入存储在状态中。</li>
<li>通过 refs 与 DOM 进行交互。</li>
<li>某些部分看起来像原生控件 —— 按钮，表单域等。</li>
</ul>
<h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p>​		主要用于存放业务逻辑</p>
<h5 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>存储某个状态。</li>
<li>有改变那个状态的动作，并可能引起副作用。</li>
<li>可能有一些订阅状态变更的方法，而这些变更不是由动作直接造成的。</li>
<li>可以接受类似属性的配置，或者订阅某个全局控制器的状态。</li>
<li><strong>不</strong>依赖于任何 React API。</li>
<li><strong>不</strong>与 DOM 进行交互，也没有任何样式。</li>
</ul>
<h5 id="场景：-2"><a href="#场景：-2" class="headerlink" title="场景："></a>场景：</h5><ul>
<li>组件有很多与部分输入无关的状态。</li>
<li>状态用于存储从服务器接收到的信息。</li>
<li>引用全局状态，如拖放或导航的状态。</li>
</ul>
<h4 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h4><p>​		主要是将控制器连接到视图组件和控制组件的粘合剂</p>
<h5 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h5><ul>
<li>在组件状态中存储控制器实例。</li>
<li>通过展示组件和控制组件来渲染状态。</li>
<li>使用生命周期方法来订阅控制器状态的更新。</li>
<li><strong>不</strong>使用 DOM 标记或样式（可能出现的例外是一些无样式的 div）。</li>
<li>通常由像 Redux 的 <code>connect</code> 这样的高阶函数生成。 </li>
<li>可以通过上下文访问全局控制器（例如 Redux 的 store）。</li>
</ul>
<h5 id="场景：-3"><a href="#场景：-3" class="headerlink" title="场景："></a>场景：</h5><ul>
<li>一个 <code>App</code> 组件</li>
<li>由 Redux 的 <code>connect</code> 返回的组件。</li>
<li>由 MobX 的 <code>observer</code> 返回的组件。</li>
<li>react-router 的 <code>&lt;Link&gt;</code> 组件（因为它使用上下文并影响环境）。</li>
</ul>
<h3 id="package-json和package-lock-json的区别"><a href="#package-json和package-lock-json的区别" class="headerlink" title="package.json和package-lock.json的区别"></a>package.json和package-lock.json的区别</h3><p>package.json的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack-test&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack-cli&quot;: &quot;^3.3.2&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;^2.0.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>name：项目名，也就是在使用npm init 初始化时取的名字，但是如果使用的是npm init -y 快速初始化的话，那这里的名字就是默认存放这个文件的文件名；</li>
<li>version：版本号；</li>
<li>private：希不希望授权别人以任何形式使用私有包或未发布的；</li>
<li>scripts-serve：项目启动简写配置；</li>
<li>scripts-build：打包操作简写配置；</li>
<li>dependencies：指定了项目运行时所依赖的模块；</li>
<li>devDependencies：指定项目开发时所需要的模块，也就是在项目开发时才用得上，一旦项目打包上线了，就将移除这里的第三方模块；</li>
</ul>
<p>package-lock.json是在运行“npm install”时生成的一个文件，用于记录当前状态下项目中实际安装的各个package的版本号、模块下载地址、及这个模块又依赖了哪些依赖。</p>
<p><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/pic14.png" alt="package-lock"></p>
<p>区别：</p>
<p>​		package.json指定所要下载的库的大版本号，而package-lock.json会在保证下载的库是大版本号的前提下的最新版本。</p>
<p>为什么有package.json还需要package-lock.json呢？</p>
<p>​		当node_modules文件夹不存在或被删除时，需要用到npm install重新下载全部依赖，通过package-lock.json可以直接标明下载地址和相关依赖，相对下载速度也更快，也不容易报错。</p>
<h3 id="react与react-native的区别"><a href="#react与react-native的区别" class="headerlink" title="react与react native的区别"></a>react与react native的区别</h3><ol>
<li>框架作用的平台不同</li>
</ol>
<p>​		RN是react衍生出来的，两种框架都是用JSX语法开发的。但是RN主要是用来开发IOS和Android应用的，而React是将浏览器作为渲染平台的。</p>
<ol start="2">
<li>工作原理的区别</li>
</ol>
<p>​		React通过操作DOM来渲染页面，而RN通过调用java api来渲染安卓组件，调用object c api来渲染IOS组件。</p>
<ol start="3">
<li>创建组件</li>
</ol>
<p>​		编写react的时候，视图最终会被渲染为普通的HTML元素；而RN中的元素最终会被渲染为安卓或IOS中的组件。</p>
<h3 id="react父子组件的渲染执行顺序"><a href="#react父子组件的渲染执行顺序" class="headerlink" title="react父子组件的渲染执行顺序"></a>react父子组件的渲染执行顺序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">parent constructor</span><br><span class="line">parent componentwillmount</span><br><span class="line">parent render</span><br><span class="line">child constructor</span><br><span class="line">child componentwillmount</span><br><span class="line">child render </span><br><span class="line">child componentdidmount</span><br><span class="line">parent componentdidmount</span><br><span class="line">parent componentwillreceiveprops</span><br><span class="line">parent shouldcomponentupdate</span><br><span class="line">parent componentwillupdate</span><br><span class="line">parent render</span><br><span class="line">child componentwillreceiveprops</span><br><span class="line">child shouldcomponentupdate </span><br><span class="line">child componentwillupdate</span><br><span class="line">child render</span><br><span class="line">child componentdidupdate</span><br><span class="line">parent componentdidupdate</span><br></pre></td></tr></table></figure>



<h3 id="redux优缺点"><a href="#redux优缺点" class="headerlink" title="redux优缺点"></a>redux优缺点</h3><p>优点：</p>
<ul>
<li>写法固定，易于维护</li>
<li>reducer中每次return的都是不可变对象，操作相对容易</li>
</ul>
<p>缺点：</p>
<ul>
<li>实现一个小改动需要触碰很多文件才能完成，也就是模板代码太多，使用不太方便。</li>
<li>reducer是一个纯函数，无法执行异步操作，所以衍生出了例如redux-thunk、redux-sage等中间件，非常散乱。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://cheyennee.github.io">Cheyennee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://cheyennee.github.io/2021/07/18/react/">http://cheyennee.github.io/2021/07/18/react/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cheyennee.github.io" target="_blank">Cheyennee</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/react/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/01/%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98/"><img class="prev-cover" src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/theme/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">切换主题</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/06/HTTP/"><img class="next-cover" src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HTTP</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cheyennee</div><div class="author-info__description">生而为人，还请努力</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cheyennee"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">在路上</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9react%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">对react的理解？有哪些特性？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#react%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">react是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">组件的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">类组件与函数组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text">类组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">函数组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">类组件与函数组件的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E5%AE%9EDOM%E5%92%8C%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">5.</span> <span class="toc-text">真实DOM和虚拟DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.3.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-diff"><span class="toc-number">6.</span> <span class="toc-text">react diff</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-1"><span class="toc-number">6.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#tree%E5%B1%82%E7%BA%A7"><span class="toc-number">6.2.1.</span> <span class="toc-text">tree层级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#component%E5%B1%82%E7%BA%A7"><span class="toc-number">6.2.2.</span> <span class="toc-text">component层级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#element%E5%B1%82%E7%BA%A7"><span class="toc-number">6.2.3.</span> <span class="toc-text">element层级</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#key%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.3.</span> <span class="toc-text">key的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8index%E4%BD%9C%E4%B8%BAkey%E5%8F%AF%E8%83%BD%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.4.</span> <span class="toc-text">使用index作为key可能引发的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9key"><span class="toc-number">6.5.</span> <span class="toc-text">如何选择key</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSX%E8%BD%AC%E6%88%90%E7%9C%9F%E5%AE%9EDOM%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">JSX转成真实DOM的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-2"><span class="toc-number">7.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">7.3.</span> <span class="toc-text">流程总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">8.</span> <span class="toc-text">react生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text">旧生命周期流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B"><span class="toc-number">8.2.</span> <span class="toc-text">新生命周期流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B3%E5%B0%86%E5%BA%9F%E5%BC%83%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">即将废弃的生命周期函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BA%9F%E5%BC%83%E8%BF%99%E4%BA%9B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">8.4.</span> <span class="toc-text">为什么要废弃这些生命周期函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#state%E5%92%8Cprops"><span class="toc-number">9.</span> <span class="toc-text">state和props</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#state"><span class="toc-number">9.1.</span> <span class="toc-text">state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#props"><span class="toc-number">9.2.</span> <span class="toc-text">props</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="toc-number">9.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-%E4%B8%8Esuper-props"><span class="toc-number">10.</span> <span class="toc-text">super()与super(props)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6%E7%B1%BB"><span class="toc-number">10.1.</span> <span class="toc-text">ES6类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super-%E4%B8%8Esuper-props-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.2.</span> <span class="toc-text">super()与super(props)的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setState"><span class="toc-number">11.</span> <span class="toc-text">setState</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-3"><span class="toc-number">11.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.3.</span> <span class="toc-text">更新类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0"><span class="toc-number">11.4.</span> <span class="toc-text">批量更新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">12.</span> <span class="toc-text">react事件机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-4"><span class="toc-number">12.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6"><span class="toc-number">12.2.</span> <span class="toc-text">合成事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">12.3.</span> <span class="toc-text">合成事件与原生事件的执行顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">类组件中事件绑定方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F"><span class="toc-number">13.1.</span> <span class="toc-text">常见的绑定方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#render%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8bind"><span class="toc-number">13.1.1.</span> <span class="toc-text">render方法中使用bind</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#render%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">13.1.2.</span> <span class="toc-text">render方法中使用箭头函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#constructor%E4%B8%ADbind"><span class="toc-number">13.1.3.</span> <span class="toc-text">constructor中bind</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E9%98%B6%E6%AE%B5%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="toc-number">13.1.4.</span> <span class="toc-text">函数定义阶段使用箭头函数绑定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E4%B8%AD%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">14.</span> <span class="toc-text">react中组件的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#refs"><span class="toc-number">15.</span> <span class="toc-text">refs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-5"><span class="toc-number">15.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">15.2.</span> <span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#refs%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">15.3.</span> <span class="toc-text">refs应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">16.</span> <span class="toc-text">受控组件与非受控组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">16.1.</span> <span class="toc-text">受控组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">16.2.</span> <span class="toc-text">非受控组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">16.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">17.</span> <span class="toc-text">高阶组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-6"><span class="toc-number">17.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99"><span class="toc-number">17.2.</span> <span class="toc-text">编写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">17.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-hooks"><span class="toc-number">18.</span> <span class="toc-text">react hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-7"><span class="toc-number">18.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8hooks"><span class="toc-number">18.2.</span> <span class="toc-text">常用hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#useEffect%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E8%A7%84%E5%88%99"><span class="toc-number">18.2.1.</span> <span class="toc-text">useEffect第二个参数的执行规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E4%B8%AD%E5%BC%95%E5%85%A5CSS%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">19.</span> <span class="toc-text">react中引入CSS的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8"><span class="toc-number">19.1.</span> <span class="toc-text">在组件中直接使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%BC%95%E5%85%A5CSS%E6%96%87%E4%BB%B6"><span class="toc-number">19.2.</span> <span class="toc-text">组件中引入CSS文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%BC%95%E5%85%A5-module-css%E6%96%87%E4%BB%B6"><span class="toc-number">19.3.</span> <span class="toc-text">组件中引入.module.css文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-in-JS"><span class="toc-number">19.4.</span> <span class="toc-text">CSS in JS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#styled-components%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">19.4.1.</span> <span class="toc-text">styled-components基本使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E7%BB%84%E4%BB%B6%E9%97%B4%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB"><span class="toc-number">20.</span> <span class="toc-text">react组件间过渡动画</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-8"><span class="toc-number">20.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">20.2.</span> <span class="toc-text">如何实现？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redux%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">21.</span> <span class="toc-text">Redux工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-9"><span class="toc-number">21.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redux%E9%81%B5%E5%BE%AA%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="toc-number">21.2.</span> <span class="toc-text">redux遵循的原则：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redux%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">21.3.</span> <span class="toc-text">redux工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">21.4.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="toc-number">21.5.</span> <span class="toc-text">纯函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redux%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">22.</span> <span class="toc-text">redux中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-10"><span class="toc-number">22.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">22.2.</span> <span class="toc-text">常见的中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#redux-chunk"><span class="toc-number">22.2.1.</span> <span class="toc-text">redux-chunk</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redux-logger"><span class="toc-number">22.2.2.</span> <span class="toc-text">redux-logger</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8react%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8redux"><span class="toc-number">23.</span> <span class="toc-text">在react项目中使用redux</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#react-redux"><span class="toc-number">23.1.</span> <span class="toc-text">react-redux</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">23.2.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Provider"><span class="toc-number">23.2.1.</span> <span class="toc-text">Provider</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#connection"><span class="toc-number">23.2.2.</span> <span class="toc-text">connection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mapStateToProps"><span class="toc-number">23.2.3.</span> <span class="toc-text">mapStateToProps</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mapDispatchToProps"><span class="toc-number">23.2.4.</span> <span class="toc-text">mapDispatchToProps</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">24.</span> <span class="toc-text">项目结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E8%A7%92%E8%89%B2%E7%BB%84%E7%BB%87-MVC"><span class="toc-number">24.1.</span> <span class="toc-text">按角色组织(MVC)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%8A%9F%E8%83%BD%E7%BB%84%E7%BB%87"><span class="toc-number">24.2.</span> <span class="toc-text">按功能组织</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Router"><span class="toc-number">25.</span> <span class="toc-text">React Router</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-11"><span class="toc-number">25.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API"><span class="toc-number">25.2.</span> <span class="toc-text">常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BrowserRouter%E3%80%81HashRouter%E5%8C%BA%E5%88%AB"><span class="toc-number">25.2.1.</span> <span class="toc-text">BrowserRouter、HashRouter区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Route"><span class="toc-number">25.2.2.</span> <span class="toc-text">Route</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Link%E3%80%81NavLink"><span class="toc-number">25.2.3.</span> <span class="toc-text">Link、NavLink</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redirect"><span class="toc-number">25.2.4.</span> <span class="toc-text">redirect</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Switch"><span class="toc-number">25.2.5.</span> <span class="toc-text">Switch</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#react-router%E4%B8%AD%E7%9A%84hooks"><span class="toc-number">25.3.</span> <span class="toc-text">react-router中的hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#useHistory"><span class="toc-number">25.3.1.</span> <span class="toc-text">useHistory</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useParams"><span class="toc-number">25.3.2.</span> <span class="toc-text">useParams</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useLocation"><span class="toc-number">25.3.3.</span> <span class="toc-text">useLocation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">26.</span> <span class="toc-text">路由传递参数的形式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#params%E5%8F%82%E6%95%B0"><span class="toc-number">26.1.</span> <span class="toc-text">params参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#search%E5%8F%82%E6%95%B0"><span class="toc-number">26.2.</span> <span class="toc-text">search参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#state%E5%8F%82%E6%95%B0"><span class="toc-number">26.3.</span> <span class="toc-text">state参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">26.4.</span> <span class="toc-text">路由中的对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#history%E5%AF%B9%E8%B1%A1"><span class="toc-number">26.4.1.</span> <span class="toc-text">history对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#match%E5%AF%B9%E8%B1%A1"><span class="toc-number">26.4.2.</span> <span class="toc-text">match对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#location%E5%AF%B9%E8%B1%A1"><span class="toc-number">26.4.3.</span> <span class="toc-text">location对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashRouter%E5%8E%9F%E7%90%86"><span class="toc-number">26.5.</span> <span class="toc-text">HashRouter原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">26.6.</span> <span class="toc-text">单页面应用路由实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#history%E6%A8%A1%E5%BC%8F"><span class="toc-number">26.6.1.</span> <span class="toc-text">history模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#hash%E6%A8%A1%E5%BC%8F"><span class="toc-number">26.6.2.</span> <span class="toc-text">hash模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Router%E4%B8%8ERoute%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">26.7.</span> <span class="toc-text">Router与Route的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Immutable"><span class="toc-number">27.</span> <span class="toc-text">Immutable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-12"><span class="toc-number">27.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-number">27.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Immutable%E5%9C%A8React%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">27.3.</span> <span class="toc-text">Immutable在React中的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#render%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="toc-number">28.</span> <span class="toc-text">render触发时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%95%88%E7%8E%87"><span class="toc-number">29.</span> <span class="toc-text">提高组件渲染效率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shouldComponentUpdate-nextProps-nextState"><span class="toc-number">29.1.</span> <span class="toc-text">shouldComponentUpdate(nextProps, nextState)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PureComponent"><span class="toc-number">29.2.</span> <span class="toc-text">PureComponent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-memo"><span class="toc-number">29.3.</span> <span class="toc-text">React.memo</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">30.</span> <span class="toc-text">react性能优化的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">30.1.</span> <span class="toc-text">避免使用内联函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Fragments%E9%81%BF%E5%85%8D%E9%A2%9D%E5%A4%96%E6%A0%87%E7%AD%BE"><span class="toc-number">30.2.</span> <span class="toc-text">使用Fragments避免额外标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F"><span class="toc-number">30.3.</span> <span class="toc-text">事件绑定方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Immutable"><span class="toc-number">30.4.</span> <span class="toc-text">使用Immutable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6"><span class="toc-number">30.5.</span> <span class="toc-text">懒加载组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">30.6.</span> <span class="toc-text">服务端渲染</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93"><span class="toc-number">31.</span> <span class="toc-text">react服务端渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-13"><span class="toc-number">31.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">31.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BA"><span class="toc-number">31.3.</span> <span class="toc-text">手动搭建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-number">31.4.</span> <span class="toc-text">简化原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fiber%E6%9E%B6%E6%9E%84"><span class="toc-number">32.</span> <span class="toc-text">Fiber架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">32.1.</span> <span class="toc-text">JS单线程的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reconcilation%E8%B0%83%E5%92%8C%E8%BF%87%E7%A8%8B%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Fiber"><span class="toc-number">32.2.</span> <span class="toc-text">reconcilation调和过程及为什么需要Fiber</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fiber"><span class="toc-number">32.3.</span> <span class="toc-text">Fiber</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fiber%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">32.4.</span> <span class="toc-text">Fiber如何解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">32.5.</span> <span class="toc-text">需要明确的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B2%A1%E6%9C%89%E7%9A%84%E6%8A%A2%E5%8D%A0%E6%9D%A1%E4%BB%B6%EF%BC%8Creact%E5%8F%AA%E8%83%BD%E4%BD%BF%E7%94%A8%E4%B8%BB%E5%8A%A8%E8%AE%A9%E5%87%BA%E6%9C%BA%E5%88%B6"><span class="toc-number">32.5.1.</span> <span class="toc-text">浏览器没有的抢占条件，react只能使用主动让出机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#requestIdleCallback-API"><span class="toc-number">32.5.2.</span> <span class="toc-text">requestIdleCallback API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">33.</span> <span class="toc-text">捕获异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">33.1.</span> <span class="toc-text">错误边界是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">33.2.</span> <span class="toc-text">错误边界使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch"><span class="toc-number">33.3.</span> <span class="toc-text">try catch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diff"><span class="toc-number">34.</span> <span class="toc-text">diff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diff%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">35.</span> <span class="toc-text">diff具体流程：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#diff%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">35.1.</span> <span class="toc-text">diff算法的两次遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E5%8F%AF%E5%A4%8D%E7%94%A8%E8%8A%82%E7%82%B9%E5%90%8E%EF%BC%8C%E5%A6%82%E4%BD%95%E7%A7%BB%E5%8A%A8%E5%91%A2%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">找到可复用节点后，如何移动呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AFdiff-vue2-%E5%92%8C-vue3%E9%87%87%E7%94%A8%E7%9A%84%E6%80%9D%E6%83%B3%EF%BC%8Creact%E6%98%AF%E5%8D%95%E7%AB%AFdiff"><span class="toc-number">37.</span> <span class="toc-text">双端diff(vue2 和 vue3采用的思想，react是单端diff)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88react%E4%B8%8D%E9%87%87%E7%94%A8%E5%8F%8C%E7%AB%AF%E7%9A%84%E6%80%9D%E6%83%B3%E5%91%A2%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">为什么react不采用双端的思想呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E4%B8%8Evue%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">39.</span> <span class="toc-text">react与vue的异同</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">39.0.1.</span> <span class="toc-text">相同点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">39.0.2.</span> <span class="toc-text">不同点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9%EF%BC%9A-1"><span class="toc-number">39.0.3.</span> <span class="toc-text">相同点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A-1"><span class="toc-number">39.0.4.</span> <span class="toc-text">不同点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A-2"><span class="toc-number">39.0.5.</span> <span class="toc-text">不同点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%8B%86%E5%88%86"><span class="toc-number">40.</span> <span class="toc-text">组件拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E7%BB%84%E4%BB%B6"><span class="toc-number">40.1.</span> <span class="toc-text">视图组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">40.1.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">40.1.2.</span> <span class="toc-text">场景：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">40.2.</span> <span class="toc-text">控制组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-number">40.2.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%EF%BC%9A-1"><span class="toc-number">40.2.2.</span> <span class="toc-text">场景：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">40.3.</span> <span class="toc-text">控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-number">40.3.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%EF%BC%9A-2"><span class="toc-number">40.3.2.</span> <span class="toc-text">场景：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6"><span class="toc-number">40.4.</span> <span class="toc-text">容器组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-3"><span class="toc-number">40.4.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%EF%BC%9A-3"><span class="toc-number">40.4.2.</span> <span class="toc-text">场景：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#package-json%E5%92%8Cpackage-lock-json%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">41.</span> <span class="toc-text">package.json和package-lock.json的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E4%B8%8Ereact-native%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">42.</span> <span class="toc-text">react与react native的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">43.</span> <span class="toc-text">react父子组件的渲染执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redux%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">44.</span> <span class="toc-text">redux优缺点</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/01/playwright/" title="playwright"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/linux/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="playwright"/></a><div class="content"><a class="title" href="/2023/05/01/playwright/" title="playwright">playwright</a><time datetime="2023-04-30T23:25:56.000Z" title="发表于 2023-05-01 07:25:56">2023-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/27/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" title="前端安全"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/interview/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端安全"/></a><div class="content"><a class="title" href="/2023/03/27/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/" title="前端安全">前端安全</a><time datetime="2023-03-27T05:15:38.000Z" title="发表于 2023-03-27 13:15:38">2023-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/12/leetcode-for-js/" title="leetcode for js"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/handwrite/pic4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="leetcode for js"/></a><div class="content"><a class="title" href="/2023/03/12/leetcode-for-js/" title="leetcode for js">leetcode for js</a><time datetime="2023-03-12T03:49:47.000Z" title="发表于 2023-03-12 11:49:47">2023-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/18/chrome-debug/" title="chrome debug"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/flatlist/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="chrome debug"/></a><div class="content"><a class="title" href="/2023/02/18/chrome-debug/" title="chrome debug">chrome debug</a><time datetime="2023-02-18T14:58:36.000Z" title="发表于 2023-02-18 22:58:36">2023-02-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/30/angular/" title="angular"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/flex/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="angular"/></a><div class="content"><a class="title" href="/2023/01/30/angular/" title="angular">angular</a><time datetime="2023-01-30T01:14:25.000Z" title="发表于 2023-01-30 09:14:25">2023-01-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Cheyennee</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>