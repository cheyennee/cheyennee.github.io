<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JS | Cheyennee</title><meta name="keywords" content="blog"><meta name="author" content="Cheyennee,714851125@qq.com"><meta name="copyright" content="Cheyennee"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录JS知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="JS">
<meta property="og:url" content="http://cheyennee.github.io/2021/03/12/JS/index.html">
<meta property="og:site_name" content="Cheyennee">
<meta property="og:description" content="记录JS知识点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/cover.jpg">
<meta property="article:published_time" content="2021-03-12T12:27:05.000Z">
<meta property="article:modified_time" content="2023-09-07T14:47:34.579Z">
<meta property="article:author" content="Cheyennee">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/cover.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://cheyennee.github.io/2021/03/12/JS/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JS',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-07 22:47:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cheyennee</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-12T12:27:05.000Z" title="发表于 2021-03-12 20:27:05">2021-03-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-07T14:47:34.579Z" title="更新于 2023-09-07 22:47:34">2023-09-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JS/">JS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JS"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/why.png" alt="js"></p>
<h4 id="JS组成部分"><a href="#JS组成部分" class="headerlink" title="JS组成部分"></a>JS组成部分</h4><ul>
<li>ECMAscript：基本语法</li>
<li>DOM：操作HTML</li>
<li>BOM：操作浏览器</li>
</ul>
<h4 id="JS代码引入方式"><a href="#JS代码引入方式" class="headerlink" title="JS代码引入方式"></a>JS代码引入方式</h4><ul>
<li>内联式：标签里写JS代码</li>
<li>嵌入式：script标签里写</li>
<li>外部式：script标签里src引入</li>
</ul>
<h4 id="访问JS对象"><a href="#访问JS对象" class="headerlink" title="访问JS对象"></a>访问JS对象</h4><ul>
<li>方式：点号和中括号</li>
<li>区别：一是中括号可以操作特殊的属性名。二是中括号里面的属性名可以是一个变量，点号不支持变量。</li>
<li>判断属性是否在对象里：in操作符。语法：’属性名’**(一定要带引号)**&#x2F;变量 in 对象</li>
</ul>
<h4 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h4><ul>
<li><p>块作用域(let\const)</p>
</li>
<li><p>类</p>
</li>
<li><p>箭头函数</p>
</li>
<li><p>模板字符串</p>
</li>
<li><p>对象字面量属性赋值简写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="comment">// __proto__</span></span><br><span class="line">    <span class="attr">__proto__</span>: theProtoObj,</span><br><span class="line">    <span class="comment">// Shorthand for ‘handler: handler’</span></span><br><span class="line">    handler,</span><br><span class="line">    <span class="comment">// Method definitions</span></span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Super calls</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;d &quot;</span> + <span class="variable language_">super</span>.<span class="title function_">toString</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Computed (dynamic) property names</span></span><br><span class="line">    [ <span class="string">&#x27;prop_&#x27;</span> + (<span class="function">() =&gt;</span> <span class="number">42</span>)() ]: <span class="number">42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象解构</p>
</li>
<li><p>Promise</p>
</li>
<li><p>Symbol</p>
</li>
<li><p>代理(proxy)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数：</span></span><br><span class="line"><span class="comment">	target(要使用 Proxy 包装的目标对象)</span></span><br><span class="line"><span class="comment">	handler(一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params">obj, prop</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;prop&#125;</span>!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"><span class="title function_">console</span>(p.<span class="property">c</span>); <span class="comment">//Hello, c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    可监听的操作： get、set、has、deleteProperty、apply、construct、getOwnPropertyDescriptor、defineProperty、getPrototypeOf、setPrototypeOf、enumerate、ownKeys、preventExtensions、isExtensible。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数默认参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Default</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findArtist</span>(<span class="params">name=<span class="string">&#x27;lu&#x27;</span>, age=<span class="string">&#x27;26&#x27;</span></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Rest</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, ...y</span>) &#123;</span><br><span class="line">  <span class="comment">// y is an Array</span></span><br><span class="line">  <span class="keyword">return</span> x * y.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">3</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>) == <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Spread</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Pass each elem of array as argument</span></span><br><span class="line"><span class="title function_">f</span>(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) == <span class="number">6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>rest</p>
</li>
<li><p>Map + Set + WeakMap + WeakSet</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">WeakMap</span>、<span class="title class_">WeakSet</span>作为属性键的对象如果没有别的变量在引用它们，则会被回收释放掉。</span><br><span class="line"></span><br><span class="line"><span class="title class_">Map</span>原型中的方法有：get、has、keys、set、values</span><br><span class="line">- get：返回key对应的value</span><br><span class="line">- has：返回布尔值判断key是否在map中</span><br><span class="line">- keys：返回迭代器，iter.<span class="title function_">next</span>().<span class="property">value</span>获取下一个key</span><br><span class="line">- values：返回迭代器，iter.<span class="title function_">next</span>().<span class="property">value</span>获取下一个value</span><br><span class="line">- set：添加键值对</span><br><span class="line"></span><br><span class="line"><span class="title class_">Set</span>原型中的方法有：add、has、keys、values</span><br><span class="line">- has：返回布尔值判断对应的值是否在set中</span><br><span class="line">- keys：values方法的别名</span><br><span class="line">- values：返回迭代器，iter.<span class="title function_">next</span>().<span class="property">value</span>获取下一个value</span><br></pre></td></tr></table></figure>
</li>
<li><p>iterators+for of</p>
</li>
<li><p>内置功能模块</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).具有<span class="title class_">CommonJS</span>的精简语法、唯一导出出口(single <span class="built_in">exports</span>)和循环依赖(cyclic dependencies)的特点。</span><br><span class="line">(<span class="number">2</span>).类似<span class="variable constant_">AMD</span>，支持异步加载和可配置的模块加载。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Math + Number + String + Array + Object APIs</p>
</li>
<li><p>TypedArray、DataView。ArrayBuffer对象作为内存区域可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，称为视图。ArrayBuffer中有两种类型的视图，一种是类型化数组视图(TypedArray)，另一种是数据视图(DataView)。类型化数组视图的数组成员都是同一个数据类型，而数据视图的数组成员可以是不同的数据类型。</p>
</li>
</ul>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><ul>
<li>使用：在script标签或函数开头加上’use strict’;</li>
<li>必须用var声明变量；禁止自定义的函数中的this指向window；创建eval作用域；对象中的属性不能重名；</li>
</ul>
<h4 id="数据类型（八种）"><a href="#数据类型（八种）" class="headerlink" title="数据类型（八种）"></a>数据类型（八种）</h4><p>基础数据类型：Boolean、Null、Undefined、Number、BigInt、String、Symbol</p>
<p>引用数据类型：Object</p>
<h4 id="Bigint和Number的区别"><a href="#Bigint和Number的区别" class="headerlink" title="Bigint和Number的区别"></a>Bigint和Number的区别</h4><p>BigInt和Number两者必须转换为同一种类型才能进行运算，不能混合运算。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">BigInt</th>
<th align="center">Number</th>
</tr>
</thead>
<tbody><tr>
<td align="center">表示范围</td>
<td align="center">可以表示任意大的整数</td>
<td align="center">±2^53 - 1</td>
</tr>
<tr>
<td align="center">使用Math对象中的方法</td>
<td align="center">不可以</td>
<td align="center">可以</td>
</tr>
<tr>
<td align="center">互相转化</td>
<td align="center">BigInt转Number时可能会丢失精度</td>
<td align="center">无需担心精度</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> big1 = <span class="number">9007199254740991n</span>;</span><br><span class="line"><span class="keyword">const</span> big2 = <span class="title class_">BigInt</span>(<span class="number">9007199254740991</span>)</span><br></pre></td></tr></table></figure>

<h4 id="基础数据类型与引用数据类型的区别"><a href="#基础数据类型与引用数据类型的区别" class="headerlink" title="基础数据类型与引用数据类型的区别"></a>基础数据类型与引用数据类型的区别</h4><ul>
<li><code>拷贝:</code>基本数据类型，设原值为a，拷贝后的值为b。则无论是单独修改a还是b，都不会改变另一个值。而引用数据类型，例如对象，设原对象为a，拷贝后的对象为b，则拷贝后修改a或b，另一个对象也会同时改变。</li>
<li><code>比较:</code>基本数据类型在比较的时候是比较值，而引用数据类型在比较的时候是比较地址。</li>
</ul>
<h4 id="为什么引用值存放在堆中，原始值存放在栈中呢？"><a href="#为什么引用值存放在堆中，原始值存放在栈中呢？" class="headerlink" title="为什么引用值存放在堆中，原始值存放在栈中呢？"></a>为什么引用值存放在堆中，原始值存放在栈中呢？</h4><p>​		栈是特殊线性表，存取数据的原则是先进后出。而堆的数据结构通常是一个完全二叉树，每个节点存储一个值，整棵树都是经过排序的。</p>
<p>​		栈的每一块内层空间都是固定大小的，存储能力有限。而堆的内存空间可以动态增长。对象是复杂的结构，它可以自由扩展，比较适合存放在内存空间能够动态增长的地方；而原始值占用的空间相对固定，适合存放在栈中。</p>
<p>​		还存在一个查找效率的问题。不将原始值放在堆中是因为通过引用到堆中查找实际值是要花费时间的，不如直接通过栈查找原始值快。且将引用值放入堆中通过二叉树查找的搜索效率高于将引用值放在栈中。</p>
<h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic.png" alt="pic" style="zoom:50%;">

<ul>
<li>typeof null &#x3D; ‘object’</li>
<li>typeof NaN &#x3D; ‘number’</li>
<li>typeof Object &#x3D; ‘function’</li>
</ul>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><p>概念：检测<strong>构造函数</strong>的 <code>prototype </code>属性是否出现在某个实例对象的原型链上</p>
<p>注意点：<code>instanceof</code>不能直接用于判断基本数据类型，但是可以直接判断引用数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(2 instanceof Number);     // false</span><br><span class="line">console.log(true instanceof Boolean); // false</span><br><span class="line">console.log(&#x27;str&#x27; instanceof String); // false </span><br><span class="line">console.log([] instanceof Array);     // true</span><br></pre></td></tr></table></figure>

<h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- Date()：返回当日的日期和时间</span><br><span class="line">- Date.now()：返回时间戳，是一个number类型</span><br><span class="line">- getDate()：从Date对象中返回一个月的某一天</span><br><span class="line">- getDay()：返回一周中的某一天</span><br><span class="line">- getYear()：返回年份</span><br><span class="line">- getTime()：返回1970年1月1日至今的毫秒数</span><br></pre></td></tr></table></figure>

<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>内置对象</li>
<li>有length，可以被遍历</li>
<li>是伪数组，无pop()、push()等数组方法</li>
<li>可以结合扩展运算符生成数组：[…arguments]</li>
<li>如果实参个数多于形参个数，则按照形参的个数进行匹配；如果实参个数小于形参个数，则多余的形参会是undefined，打印出来是NaN。</li>
</ul>
<h4 id="this绑定规则"><a href="#this绑定规则" class="headerlink" title="this绑定规则"></a>this绑定规则</h4><ul>
<li>默认绑定。非严格模式下，this指向window; 严格模式下，函数内部this指向undefined，函数外部不受影响。默认情况下，立即执行函数的this指向window。</li>
</ul>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic1.png" alt="默认绑定" style="zoom:50%;">

<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic6.png" alt="默认绑定" style="zoom:50%;">

<ul>
<li>隐式绑定。函数调用是在某个对象上触发的，即调用位置存在上下文对象。类似于xxx.func()这种调用模式。如果存在xxx.yyy.zzz.func，此时this永远指向最后调用它的对象。</li>
</ul>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic2.png" alt="隐式绑定" style="zoom:50%;">

<ul>
<li>隐式绑定丢失。常见的两种丢失：a.使用另一个变量作为函数别名，之后使用别名执行函数；b.将函数作为参数传递时会被隐式赋值。此时，this的指向会启用默认绑定。如下输出2，1.</li>
</ul>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic3.png" alt="隐式绑定丢失" style="zoom:50%;">

<ul>
<li><p>显式绑定。使用call\apply\bind强行改变this指向。Call和apply函数会立即执行；bind函数会返回新函数，不会立即执行函数；call和apply在于call接收若干参数，而apply接收数组。或者说bind只是改变了this指向，但是不会调用函数。</p>
</li>
<li><p>new绑定。以下输出zc 18。</p>
</li>
</ul>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic4.png" alt="new绑定" style="zoom:38%;">

<ul>
<li>箭头函数。箭头函数没有自己的this，它的this<strong>指向外层作用域</strong>的this，且<strong>指向函数定义时的this</strong>而非执行时。</li>
</ul>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic5.png" alt="箭头函数" style="zoom:50%;">

<h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><ol>
<li>原型对象</li>
</ol>
<p>​		每创建一个函数，解析器就会向函数中添加一个属性prototype。<strong>也就是说prototype只有函数对象上有。</strong>这个属性对应着一个对象，这个对象就是原型对象。如果函数以普通函数形式调用prototype则没有任何作用。当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，可以通过<code>__proto__</code>来访问该属性。</p>
<ol start="2">
<li>原型对象的特点</li>
</ol>
<p>​		原型对象就相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象，可以将对象中共有的内容，统一设置到原型对象中。</p>
<p>​		当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。</p>
<p>​    	使用in检查对象中是否存在某个属性时，如果对象中没有但是原型中有，也会返回true.可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性。Object对象的原型没有原型为null。</p>
<ol start="3">
<li><code>__proto__</code>、prototype、constructor</li>
</ol>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic8.png" alt="原型" style="zoom:50%;">

<ol start="4">
<li>获得原型的方法</li>
</ol>
<ul>
<li><code>f1.__proto__</code></li>
<li>Foo.prototype</li>
<li>f1.constructor.prototype</li>
<li>Object.getPrototypeOf(f1)</li>
</ul>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic7.png" alt="箭头函数" style="zoom:50%;">

<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><ol>
<li>模块化的目的</li>
</ol>
<ul>
<li>解决命名冲突</li>
<li>提高复用性</li>
<li>提高代码可维护性</li>
</ul>
<ol start="2">
<li>整体理解</li>
</ol>
<p>模块是实现一个特定功能的一组方法</p>
<ol start="3">
<li>模块的几种形式</li>
</ol>
<ul>
<li>将函数作为模块。由于函数具有独立作用域，故可将函数作为模块。几个函数作为一个模块，但这种方式容易导致全局变量的污染，并且模块之间没有关系。</li>
<li>对象的写法。可以解决将函数作为模块的某些缺陷，但是这种方法会暴露所有的模块成员，外部代码可以修改内部属性的值。</li>
<li>立即执行的匿名函数。利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</li>
</ul>
<ol start="4">
<li>模块规范</li>
</ol>
<ul>
<li>commonJS。通过require来引入模块，通过module.exports定义模块的输出接口。这种模块加载方案是<strong>服务器端</strong>的解决方案，以<strong>同步的方式来引入模块的</strong>。在服务器端，文件都存储在本地磁盘，读取比较快，以同步的方式加载没有问题。在浏览器端，模块加载需要使用网络请求，故使用异步加载方式更合适。导出值是可以被修改的。</li>
<li>AMD。<strong>异步加载模块</strong>。AMD在<strong>模块加载完成后就会执行该模块</strong>，等所有模块加载完成后就会进入require的回调函数。模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等加载完成后再执行回调函数。<strong>require.js实现了AMD规范。</strong></li>
<li>CMD。<strong>异步加载模块。sea.js实现了CMD规范。</strong>它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</li>
<li>ES6方案。import 和export导入导出模块。不能动态加载模块，只能在该文件的最顶部声明要导入的文件。导出值都是可读的，不能修改。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在浏览器中使用es module的方法</span><br><span class="line">index.html</span><br><span class="line">&lt;script scr=&quot;a.js&quot; type=&quot;module&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">a.js</span><br><span class="line">export const name = &quot;alice&quot;;</span><br><span class="line">export const age = 18;</span><br><span class="line"></span><br><span class="line">b.js</span><br><span class="line">import &#123;name, age&#125; from &#x27;./a.js&#x27;;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>export</li>
</ol>
<ul>
<li>默认导出：export default Person</li>
<li>按需导出：export {age, name, sex}</li>
<li>混合导出：export default和export可以同时使用不影响</li>
<li>默认导入：import Person from ‘person’</li>
<li>按需导入：import {age, sex, name} from ‘person’</li>
<li>混合导入：必须先导入默认导出的，再导入单个导入值</li>
</ul>
<ol start="6">
<li>AMD和CMD的区别</li>
</ol>
<ul>
<li><strong>模块定义时对依赖的处理不同。</strong>AMD依赖前置，在定义模块的时候就要声明其依赖的模块。而CMD就近依赖，只有在用到某个模块的时候再去require。</li>
<li><strong>对依赖模块的执行时机不同。</strong>AMD和CMD都是异步加载。但是AMD在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和书写顺序不一定一致。而CMD在依赖模块加载完成后并不执行，等到所有的依赖模块都加载好之后，进入回调函数逻辑，遇到require语句的时候才执行对应的模块。模块的执行顺序和书写顺序一致。</li>
</ul>
<ol start="7">
<li>CommonJS和ES6 模块的区别</li>
</ol>
<ul>
<li>CommonJS输出的是值拷贝，ES6输出的值引用</li>
<li>CommonJS模块是运行时加载，ES6是编译时加载</li>
<li>CommonJS是动态语法可以写在判断里，ES6是静态语法只能写在顶层</li>
</ul>
<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><ul>
<li><p>概念：是一组键&#x2F;值对的集合，其中的<strong>键是弱引用</strong>。其<strong>键必须是对象</strong>，而值可以是任意的。一个对象如果被弱引用所引用，则被认为是不可访问的，并在任何时刻都能被回收。</p>
</li>
<li><p>强引用与弱引用：默认创建的为强引用，只有手动置为null才会被垃圾回收机制进行回收。而弱引用则会被垃圾回收机制自动回收。</p>
</li>
</ul>
<h4 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async &#x2F; await"></a>async &#x2F; await</h4><ul>
<li>async函数返回<strong>Promise对象</strong>，必须等到内部所有的await命令的Promise对象执行完，才会发生状态改变。</li>
<li>await表达式：await在等待一个表达式的计算结果。如果await表达式的运算结果不是一个Promise对象，那么这个值就是它最终的运算结果。如果await表达式的运算结果是promise对象，那么它会阻塞后面的代码，等到这个promise对象resolve，得到resolve的值作为表达式的运算结果。await右侧的表达式一般为promise对象，但也可以是其他值。如果表达式是promise对象，await返回的是promise<strong>成功</strong>的值。如果表达式是其他值，直接将此值作为await的返回值。</li>
<li>当async函数中有一个await出现rejectd状态时，后面的await都不会执行。可以通过添加try&#x2F;catch。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doIt</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">time</span>(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line"> <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line"> <span class="keyword">const</span> time2 = <span class="keyword">await</span> <span class="title function_">step1</span>(time1);</span><br><span class="line"> <span class="keyword">const</span> time3 = <span class="keyword">await</span> <span class="title function_">step2</span>(time1, time2);</span><br><span class="line"> <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">step3</span>(time1, time2, time3);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">timeEnd</span>(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doIt</span>();</span><br></pre></td></tr></table></figure>

<h4 id="undefined、undeclared、null"><a href="#undefined、undeclared、null" class="headerlink" title="undefined、undeclared、null"></a>undefined、undeclared、null</h4><ul>
<li>undefined表示已在作用域中声明但还没有赋值的变量</li>
<li>undeclared表示未在作用域中声明的变量</li>
<li>null主要赋值给一些可能会返回对象的变量，作为初始化</li>
</ul>
<h4 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h4><ol>
<li>作用域</li>
</ol>
<ul>
<li>概念：作用域是定义变量的区域，它有一套访问变量的规则，这套规则用来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量进行变量查找。</li>
<li>分类：ES6之前只有<strong>全局作用域</strong>和<strong>函数作用域</strong>，ES6之后新增<strong>块级作用域</strong>(let\const)。</li>
</ul>
<ol start="2">
<li>作用域链</li>
</ol>
<ul>
<li>概念：在作用域的多层嵌套中查找自由变量的过程是作用域链的访问机制。层层嵌套的作用域，通过访问自由变量形成的关系叫做作用域链。查找一个变量的时候，JS会尝试在当前作用域下寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。如果全局作用域仍然找不到，则报错。</li>
<li>本质：指向变量对象的指针列表。变量对象是一个包含执行环境中所有变量和函数的对象。作用域链的前端始终是当前执行上下文的变量对象，全局执行上下文的变量对象始终是作用域链的最后一个对象。</li>
</ul>
<ol start="3">
<li>词法作用域</li>
</ol>
<p>​		词法作用域又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说写好代码时变量的作用域就确定了，JS遵循的就是词法作用域。</p>
<h4 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h4><p><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic22.png" alt="执行上下文"></p>
<h4 id="String的原生方法"><a href="#String的原生方法" class="headerlink" title="String的原生方法"></a>String的原生方法</h4><p><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic9.png" alt="string"></p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><ol>
<li>边界</li>
</ol>
<table>
<thead>
<tr>
<th>^</th>
<th>开头</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>结尾</td>
</tr>
<tr>
<td>\b</td>
<td>边界</td>
</tr>
<tr>
<td>\B</td>
<td>与\b相反</td>
</tr>
<tr>
<td>(?&#x3D;p)</td>
<td>符合p子模式前面的那个位置</td>
</tr>
<tr>
<td>(?!p)</td>
<td>(?&#x3D;p)匹配到的位置之外的位置都是属于(?!p)</td>
</tr>
<tr>
<td>(?&lt;&#x3D;p)</td>
<td>符合p后面的那个位置</td>
</tr>
<tr>
<td>(?&lt;!p)</td>
<td>(?&lt;&#x3D;p)之外的所有位置</td>
</tr>
</tbody></table>
<ol start="2">
<li>量词</li>
</ol>
<table>
<thead>
<tr>
<th>{m,}</th>
<th>至少出现m次</th>
</tr>
</thead>
<tbody><tr>
<td>{m}</td>
<td>出现m次</td>
</tr>
<tr>
<td>?</td>
<td>出现0次或者1次</td>
</tr>
<tr>
<td>+</td>
<td>至少出现1次</td>
</tr>
<tr>
<td>*</td>
<td>出现0次或多次</td>
</tr>
</tbody></table>
<ol start="3">
<li>常用</li>
</ol>
<table>
<thead>
<tr>
<th>\w</th>
<th>字符</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>数字</td>
</tr>
</tbody></table>
<ol start="4">
<li>修饰符</li>
</ol>
<p><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic13.png" alt="修饰符"></p>
<h4 id="JS延迟加载的方式"><a href="#JS延迟加载的方式" class="headerlink" title="JS延迟加载的方式"></a>JS延迟加载的方式</h4><ul>
<li>JS加载、解析和执行都会阻塞页面渲染</li>
</ul>
<ol>
<li>将JS脚本放在文档的底部，来使JS脚本尽可能的在最后来加载执行</li>
<li>给JS脚本添加defer属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞了。多个设置了defer属性的脚本按规范来说最后是顺序执行的。</li>
<li>给JS脚本添加async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行JS脚本，如果这个时候文档没有解析完成的话同样会阻塞。多个async属性的脚本的执行顺序不可预测。</li>
<li>动态创建DOM标签的方式。可以对文档的加载事件进行监听，当文档加载完成后再动态的创建script标签来引入JS脚本。</li>
</ol>
<h4 id="JS运行机制"><a href="#JS运行机制" class="headerlink" title="JS运行机制"></a>JS运行机制</h4><ol>
<li>JS单线程</li>
</ol>
<ul>
<li>概念：同一时间只能做一件事。js单线程主要与它的用途有关。它主要用途是与用户交互，以及操作DOM。使用单线程能够消除同步问题。</li>
</ul>
<ol start="2">
<li>JS事件循环</li>
</ol>
<ul>
<li>任务分类：同步任务、异步任务</li>
</ul>
<p><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic10.png" alt="任务执行流程"></p>
<p><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic11.png" alt="步骤"></p>
<h4 id="宏队列与微队列"><a href="#宏队列与微队列" class="headerlink" title="宏队列与微队列"></a>宏队列与微队列</h4><ul>
<li>概念：JS中用来存储执行回调函数的队列</li>
<li>宏队列：用来保存待执行的宏任务（回调），比如：定时器回调&#x2F;DOM事件回调&#x2F;AJAX回调</li>
<li>微队列：用来保存待执行的微任务（回调），比如：promise的回调&#x2F;MutationObserver的回调</li>
</ul>
<h4 id="var-let-const区别"><a href="#var-let-const区别" class="headerlink" title="var \ let \ const区别"></a>var \ let \ const区别</h4><ul>
<li>var变量会挂载到window上，而let和const不会</li>
<li>var声明变量存在变量提升，而let和const不会</li>
<li>let和const形成块级作用域</li>
<li>同一作用域下let和const不能声明同名变量，而var可以</li>
<li>let和const存在暂存死区，也就是在声明变量之前，该变量是不可用的。</li>
</ul>
<h4 id="为什么var可以重复声明"><a href="#为什么var可以重复声明" class="headerlink" title="为什么var可以重复声明"></a>为什么var可以重复声明</h4><p>​		因为编辑器会判断是否已经声明过同名变量，如果声明过就忽略var，直接赋值。</p>
<h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><ul>
<li>概念：在目标对象之前架设一层拦截，外界对该对象的访问，都必须先通过这层拦截。也就是提供了一种机制，可以对外界的访问进行过滤和改写。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">obj, prop, value</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prop===<span class="string">&#x27;age&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(value))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;The age is not an integer&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(value&gt;<span class="number">200</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;The age is invalid&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        obj[prop] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line">person.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line">person.<span class="property">age</span> = <span class="string">&#x27;young&#x27;</span>;<span class="comment">//TypeError</span></span><br><span class="line">person.<span class="property">age</span> = <span class="number">300</span>;<span class="comment">//RangeError</span></span><br></pre></td></tr></table></figure>

<h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><ul>
<li><p>概念：通过yield关键字，将函数的执行流挂起，通过next()方法可以切换到下一个状态，为改变执行流程提供了可能，从而为异步编程提供解决方案。</p>
</li>
<li><p>规则：yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没明白</span></span><br><span class="line"><span class="keyword">function</span> *<span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">foo</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="异步编程方式"><a href="#异步编程方式" class="headerlink" title="异步编程方式"></a>异步编程方式</h4><ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布 &#x2F; 订阅</li>
<li>Promise</li>
</ul>
<h4 id="setTimeout-setInterval"><a href="#setTimeout-setInterval" class="headerlink" title="setTimeout \ setInterval"></a>setTimeout \ setInterval</h4><p>​		定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以<strong>真正何时执行代码的时间是不能保证的</strong>，取决于何时被主线程的事件循环取到，并执行。<strong>每个setTimeout产生的任务会直接push到任务队列中；而setInterval在每次把任务push到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)。</strong></p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><ol>
<li>概念</li>
</ol>
<p>​		闭包就是能够读取其他函数内部变量的函数。例如在JS中，只有函数内部的子函数才能读取局部变量，所以闭包可以看成是一个函数内部的函数。本质上，闭包是将函数内部和函数外部连接起来的桥梁。闭包的特点：1.在函数外部操作读取了函数内部的值 2.闭包对应的函数中的变量是<strong>常驻内存</strong>的。闭包的条件：1.函数嵌套 2.子函数要使用函数内部的变量。</p>
<ol start="2">
<li>应用</li>
</ol>
<ul>
<li>作为缓存，第二次使用对象时候，可以不用新建对象。单例模式的实现等。</li>
<li>实现封装，对访问内容添加权限，实现类似private\protect\public的效果</li>
</ul>
<ol start="3">
<li>缺点</li>
</ol>
<p>​		闭包中的变量是常驻内存的，故其会造成内存泄漏。解决的方案：将外部调用闭包函数的变量最终赋值为null。</p>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li><p>创建私有变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Counter</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">changeBy</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">changeBy</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</li>
<li><p>延长变量的生命周期</p>
<p>计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期</p>
</li>
<li><p>柯里化函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个求长方形面积的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">width, height</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> width * height</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果我们碰到的长方形的宽老是10</span></span><br><span class="line"><span class="keyword">const</span> area1 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">const</span> area2 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> area3 = <span class="title function_">getArea</span>(<span class="number">10</span>, <span class="number">40</span>)</span><br><span class="line"><span class="comment">// 我们可以使用闭包柯里化这个计算面积的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">width</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">height</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getTenWidthArea = <span class="title function_">getArea</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 之后碰到宽度为10的长方形就可以这样计算面积</span></span><br><span class="line"><span class="keyword">const</span> area1 = <span class="title function_">getTenWidthArea</span>(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// 而且如果遇到宽度偶尔变化也可以轻松复用</span></span><br><span class="line"><span class="keyword">const</span> getTwentyWidthArea = <span class="title function_">getArea</span>(<span class="number">20</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="call-apply"><a href="#call-apply" class="headerlink" title="call \ apply"></a>call \ apply</h4><ul>
<li>call和apply方法都能执行函数，用法：函数名.call()或函数名.apply();</li>
<li>call和apply的区别在于，call给函数传递值时是依次传递的，而apply给函数传递值时需要通过一个数组。</li>
</ul>
<h4 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h4><ol>
<li>防抖</li>
</ol>
<ul>
<li>概念：一个会频繁触发的函数，在规定的时间内，<strong>只让最后一次生效</strong>，前面的不生效。在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</li>
<li>作用：防止用户重复操作</li>
<li>适用场景：用户点击事件</li>
<li>如果一直点击的话就不会被执行</li>
</ul>
<ol start="2">
<li>节流</li>
</ol>
<ul>
<li>概念：一个函数执行一次后，只有大于设定的执行周期后，才会执行第二次。</li>
<li>作用：性能优化。比如有个需要频繁触发的函数，出于优化性能角度，在规定时间内，只让函数触发的第一次生效，后面不生效。通过节流函数，可以极大的减少函数执行的次数，从而节约性能。</li>
<li>常见的函数节流应用：oninput、onkeypress、onscroll、onresize等</li>
</ul>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><ol>
<li>作用</li>
</ol>
<p>​		将异步操作以同步流程表达，避免回调地狱问题。Promise本质是状态机，通过设定不同的状态来执行不同的操作。</p>
<ol start="2">
<li>三个状态</li>
</ol>
<p>​		初始化状态[pending]、成功状态[resolved]、失败状态[rejected]。状态只能改变一次，再次改变无效。</p>
<ol start="3">
<li>promise.then()返回的新promise的结果状态由什么决定？</li>
</ol>
<ul>
<li>简单表达：由then()指定的回调函数执行的结果决定</li>
<li>详细表达：a.如果抛出异常，新promise变为rejected，reason为抛出的异常；b.如果返回的是非promise的任意值，新promise变为resolved，value为返回的值；c.如果返回的是另一个新promise，此promise的结果就会成为新promise的结果。</li>
</ul>
<ol start="4">
<li>promise串联多个操作任务</li>
</ol>
<ul>
<li>通过then的链式调用串联多个同步&#x2F;异步任务</li>
<li>异步任务需要返回Promise对象，而同步任务可以直接返回</li>
</ul>
<ol start="5">
<li>promise异常穿透</li>
</ol>
<ul>
<li>当使用promise的then链式调用时，可以在最后指定失败的回调</li>
<li>前面任何操作出了异常，都会传到最后失败的回调处理</li>
</ul>
<ol start="6">
<li>中断promise链</li>
</ol>
<ul>
<li>当使用promise的then链式调用时，在中间中断，不再调用后面的回调函数</li>
<li>方法：在回调函数返回一个pending状态的promise对象</li>
</ul>
<ol start="7">
<li>回调地狱</li>
</ol>
<ul>
<li><p><strong>回调函数获取异步操作的返回值的原理？</strong>回调函数作为实参传递给异步函数的形参，所以回调函数是在异步函数之内执行的，那么回调函数就可以获取异步操作的返回值。</p>
</li>
<li><p><strong>什么是回调地狱？</strong>回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数执行的条件。</p>
</li>
<li><p><strong>回调地狱的缺点？</strong>不便于阅读&#x2F;不便于异常处理。</p>
</li>
</ul>
<ol start="8">
<li>promise的缺点</li>
</ol>
<ul>
<li>一旦新建了就会立即执行，中途无法取消</li>
<li>如果不设置回调函数，promise内部抛出的错误不会反应到外部</li>
<li>当promise处于Pending状态时，无法得知目前进展到哪一个阶段</li>
</ul>
<h4 id="x3D-x3D-与-x3D-x3D-x3D"><a href="#x3D-x3D-与-x3D-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;</h4><p><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic12.png" alt="=="></p>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><ul>
<li>symbol 类型的值可以作为<strong>对象的属性标识符</strong>使用</li>
<li>创建一个 symbol 的值需要使用 Symbol() 函数，<strong>但不能使用 new 命令。</strong></li>
<li>Symbol() 方法每次都会创建一个新的值，且不会注册到全局。Symbol.for() 方法则会先查找命名参数是否在全局中注册过，如果注册过的就不会创建新的值，而是会直接返回，所以我们可以使用到相同的 symbol 值。</li>
<li>Symbol.keyFor() 方法表示获取一个 symbol 的值在全局中注册的命名参数 key，只有使用 Symbol.for() 创建的值才会有注册的命名参数，使用 Symbol() 生成的值则没有。</li>
<li>Symbol值作为对象属性名时，<strong>不能使用点运算符</strong>。因为点运算符后面总是字符串，所以不会读取Symbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。</li>
</ul>
<h4 id="JSON-stringfy"><a href="#JSON-stringfy" class="headerlink" title="JSON.stringfy()"></a>JSON.stringfy()</h4><table>
<thead>
<tr>
<th>原值</th>
<th align="left">转换后的值</th>
</tr>
</thead>
<tbody><tr>
<td>NaN</td>
<td align="left">null</td>
</tr>
<tr>
<td>Infinity</td>
<td align="left">null</td>
</tr>
<tr>
<td>undefined</td>
<td align="left">undefined</td>
</tr>
<tr>
<td>任意函数</td>
<td align="left">undefined</td>
</tr>
<tr>
<td>symbol</td>
<td align="left">undefined</td>
</tr>
<tr>
<td>对象</td>
<td align="left">字符串</td>
</tr>
<tr>
<td>布尔值、数字、字符串</td>
<td align="left">原始值对应的字符串</td>
</tr>
</tbody></table>
<h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><ol>
<li>splice</li>
</ol>
<p>用于删除、添加数组元素，原数组会被修改，并且返回修改后的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];  <span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">splice</span>(<span class="number">2</span>);  <span class="comment">//从第三个元素开始执行删除</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//[3, 4, 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//[1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有删除元素，则返回空数组</span></span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">0</span>);  <span class="comment">//不执行删除操作</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">constructor</span> == <span class="title class_">Array</span>);  <span class="comment">//返回true，说明是一个空数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果第一个参数大于数组长度，则认为在数组尾部执行添加操作</span></span><br><span class="line"><span class="comment">//参数一为起始位置，参数二为删除/增加的元素数量，参数三…为新增的元素个数</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];  <span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">splice</span>(<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">//起始值大于length属性值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">//返回[1,2,3,4,5,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数可以取负值</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];   <span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">splice</span>(-<span class="number">2</span>,-<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">//第一、二个参数都为负值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">//返回[1,2,3,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>slice</li>
</ol>
<p>能够截取数组中指定区段的元素，并返回这个子数组,不会修改原数组。该方法包含两个参数，分别指定截取子数组的起始和结束位置的下标。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果仅指定一个参数，则表示从该参数值指定的下标位置开始，截取到数组的尾部所有元素。</span></span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">slice</span>(<span class="number">2</span>);  <span class="comment">//截取数组中第三个元素，以及后面所有元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);   <span class="comment">//返回[3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数为负数时，起始下标必须小于或等于结束下标</span></span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">slice</span>(-<span class="number">4</span>,-<span class="number">2</span>);  <span class="comment">//截取倒数第四个元素到倒数第二个元素前的元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);   <span class="comment">//返回[2,3]</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>push</li>
<li>pop</li>
<li>shift</li>
<li>unshift</li>
<li>sort</li>
<li>concat</li>
<li>reduce</li>
</ol>
<p>用于累加数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Arr</span>.<span class="title function_">reduce</span>(callback, [initialValue])</span><br><span class="line"></span><br><span class="line"><span class="comment">//详细参数</span></span><br><span class="line"><span class="attr">callback</span>:函数中包含四个参数</span><br><span class="line">- previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））</span><br><span class="line">- currentValue （数组中当前被处理的元素）</span><br><span class="line">- index （当前元素在数组中的索引)</span><br><span class="line">- array （调用的数组）</span><br><span class="line">initialValue （作为第一次调用 callback 的第一个参数。）</span><br><span class="line"></span><br><span class="line"><span class="comment">//基础用法</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> sum = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre + item</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<h4 id="JS全局函数"><a href="#JS全局函数" class="headerlink" title="JS全局函数"></a>JS全局函数</h4><p><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic14.png" alt="全局函数"></p>
<h3 id="类型转换机制"><a href="#类型转换机制" class="headerlink" title="类型转换机制"></a>类型转换机制</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		变量的数据类型在编译阶段无法获取，只能等程序运行时才知道。各种运算符对数据类型是有要求的，如果参与运算的操作数的类型与预期不符，那么会触发类型转换机制。</p>
<p>​		常见的类型转换机制：</p>
<ul>
<li>强制类型转换（显示转换）</li>
<li>自动类型转换（隐式转换）</li>
</ul>
<h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><p>​		可以清楚的知道发生了类型转换，常见的方法有：</p>
<ul>
<li>Number()</li>
<li>parseInt()</li>
<li>String()</li>
<li>Boolean()</li>
</ul>
<p>Number()：将任意类型的值转化为数值。只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code>。</p>
<p>parseInt()：逐个解析字符，遇到不能转换的字符就停下来</p>
<p>String()：将任意类型的值转化成字符串</p>
<p>Boolean()：将任意类型的值转为布尔值</p>
<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>​		常见的两种发生隐式转换的场景：</p>
<ul>
<li><p>比较运算（&#x3D;&#x3D;、!&#x3D;、&gt;、&lt;）、if、while需要布尔值的地方</p>
</li>
<li><p>算数运算（+、-、*、&#x2F;、%）</p>
</li>
<li><p>运算符两边的操作数不是同一类型的</p>
</li>
</ul>
<h5 id="自动转换为布尔值"><a href="#自动转换为布尔值" class="headerlink" title="自动转换为布尔值"></a>自动转换为布尔值</h5><p>​		在需要布尔值的地方，就会将非布尔值的参数自动转为布尔值，系统内部会调用<code>Boolean</code>函数。</p>
<p>​		可以得出个小结：undefined、null、false、+0、-0、NaN、”” 会被转化成<code>false</code>，其他都换被转化成<code>true</code>。</p>
<h5 id="自动转换为字符串"><a href="#自动转换为字符串" class="headerlink" title="自动转换为字符串"></a>自动转换为字符串</h5><p>​		遇到预期为字符串的地方，就会将非字符串的值自动转为字符串。具体规则是：先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。常发生在<code>+</code>运算中，一旦存在字符串，则会进行字符串拼接操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;5&#x27; + &#123;&#125; // &quot;5[object Object]&quot;</span><br></pre></td></tr></table></figure>

<h5 id="自动转换成数值"><a href="#自动转换成数值" class="headerlink" title="自动转换成数值"></a>自动转换成数值</h5><p>​		除了<code>+</code>有可能把操作数转为字符串，其他运算符都会把操作数自动转成数值</p>
<h3 id="x3D-x3D-与-x3D-x3D-x3D-1"><a href="#x3D-x3D-与-x3D-x3D-x3D-1" class="headerlink" title="&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;</h3><h4 id="等于操作符-x3D-x3D"><a href="#等于操作符-x3D-x3D" class="headerlink" title="等于操作符&#x3D;&#x3D;"></a>等于操作符&#x3D;&#x3D;</h4><p>​		等于操作符在比较中会先进行类型转换，再确定操作数是否相等。</p>
<p>​		遵循的规则：</p>
<ul>
<li>两个都为简单类型，字符串和布尔值都会转换成数值，再比较</li>
<li>简单类型与引用类型比较，对象使用valueOf()转化成其原始类型的值，再比较</li>
<li>两个都为引用类型，则比较它们是否指向同一个对象</li>
<li>null 和 undefined 相等</li>
<li>存在 NaN 则返回 false</li>
</ul>
<h4 id="全等操作符-x3D-x3D-x3D"><a href="#全等操作符-x3D-x3D-x3D" class="headerlink" title="全等操作符&#x3D;&#x3D;&#x3D;"></a>全等操作符&#x3D;&#x3D;&#x3D;</h4><p>​		全等操作符只有两个操作数在不转换的前提下相等才返回true。需要操作数的类型和值都相同。</p>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>​		在比较<code>null</code>的情况的时候，我们一般使用相等操作符<code>==</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span>(obj.<span class="property">x</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;1&quot;</span>);  <span class="comment">//执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">if</span>(obj.<span class="property">x</span> === <span class="literal">null</span> || obj.<span class="property">x</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		除了在比较对象属性为<code>null</code>或者<code>undefined</code>的情况下，我们可以使用相等操作符（&#x3D;&#x3D;），其他情况建议一律使用全等操作符（&#x3D;&#x3D;&#x3D;）。</p>
<h3 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h3><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic15.png" alt="浅拷贝" style="zoom:80%;">

<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic16.png" alt="深拷贝" style="zoom:80%;">

<h4 id="浅拷贝的方法"><a href="#浅拷贝的方法" class="headerlink" title="浅拷贝的方法"></a>浅拷贝的方法</h4><ul>
<li>Object.assign</li>
<li>Array.prototype.slice(begin, end)：返回一个新的数组对象，这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括<code>end</code>）。原始数组不会被改变。end如果不写则到数组末尾。</li>
<li>Array.prototype.concat()</li>
<li>扩展运算符</li>
</ul>
<h3 id="执行上下文与执行栈"><a href="#执行上下文与执行栈" class="headerlink" title="执行上下文与执行栈"></a>执行上下文与执行栈</h3><h4 id="执行上下文-1"><a href="#执行上下文-1" class="headerlink" title="执行上下文"></a>执行上下文</h4><p>​		执行上下文是一种对<code>Javascript</code>代码执行环境的抽象概念。</p>
<p>​		执行上下文的类型分为三种：</p>
<ul>
<li>全局执行上下文：只有一个，浏览器中的全局对象就是 <code>window</code>对象，<code>this</code> 指向这个全局对象</li>
<li>函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文</li>
<li>Eval 函数执行上下文： 指的是运行在 <code>eval</code> 函数中的代码，很少用而且不建议使用</li>
</ul>
<h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>​		执行栈用于存储在代码执行期间创建的所有执行上下文。当<code>Javascript</code>引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中。每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中。引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文。</p>
<h3 id="ajax原理"><a href="#ajax原理" class="headerlink" title="ajax原理"></a>ajax原理</h3><h4 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页。<code>Ajax</code>的原理简单来说通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>JavaScript</code>来操作<code>DOM</code>而更新页面。</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>实现 <code>Ajax</code>异步交互需要服务器逻辑进行配合，需要完成以下步骤：</p>
<ul>
<li>创建 <code>Ajax</code>的核心对象 <code>XMLHttpRequest</code>对象</li>
<li>通过 <code>XMLHttpRequest</code> 对象的 <code>open()</code> 方法与服务端建立连接</li>
<li>构建请求所需的数据内容，并通过<code>XMLHttpRequest</code> 对象的 <code>send()</code> 方法发送给服务器端</li>
<li>通过 <code>XMLHttpRequest</code> 对象提供的 <code>onreadystatechange</code> 事件监听服务器端的通信状态</li>
<li>接受并处理服务端向客户端响应的数据结果</li>
<li>将处理结果更新到 <code>HTML</code>页面中</li>
</ul>
<h3 id="正则表达式-1"><a href="#正则表达式-1" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="是什么？-2"><a href="#是什么？-2" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		定义规则来匹配字符串。正则表达式是对象。</p>
<p>有两种创建方式：</p>
<ul>
<li>字面量创建，其由包含在斜杠之间的模式组成</li>
<li>调用<code>RegExp</code>对象的构造函数</li>
</ul>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>贪婪模式：在匹配过程中，尝试可能的顺序是从多往少的方向去尝试。</p>
<p>懒惰模式：惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配。</p>
<p>分组：分组主要是用过<code>()</code>进行实现，比如<code>beyond&#123;3&#125;</code>，是匹配<code>d</code>字母3次。而<code>(beyond)&#123;3&#125;</code>是匹配<code>beyond</code>三次</p>
<h4 id="匹配方法"><a href="#匹配方法" class="headerlink" title="匹配方法"></a>匹配方法</h4><p>分为两类：</p>
<ul>
<li>字符串（str）方法：<code>match</code>、<code>matchAll</code>、<code>search</code>、<code>replace</code>、<code>split</code></li>
<li>正则对象下（regexp）的方法：<code>test</code>、<code>exec</code></li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">exec</td>
<td align="center">一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。</td>
</tr>
<tr>
<td align="center">test</td>
<td align="center">一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。</td>
</tr>
<tr>
<td align="center">match</td>
<td align="center">一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。</td>
</tr>
<tr>
<td align="center">matchAll</td>
<td align="center">一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。</td>
</tr>
<tr>
<td align="center">search</td>
<td align="center">一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。</td>
</tr>
<tr>
<td align="center">replace</td>
<td align="center">一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。</td>
</tr>
<tr>
<td align="center">split</td>
<td align="center">一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 <code>String</code> 方法。</td>
</tr>
</tbody></table>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>校验手机号</li>
<li>校验密码</li>
<li>解析url参数</li>
</ul>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h4 id="是什么？-3"><a href="#是什么？-3" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		JS是一门单线程的语言，意味着同一时间内只能做一件事，实现单线程非阻塞的方法就是事件循环。</p>
<p>​		在<code>JavaScript</code>中，所有的任务都可以分为</p>
<ul>
<li>同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行</li>
<li>异步任务：异步执行的任务，比如<code>ajax</code>网络请求，<code>setTimeout</code>定时函数等</li>
</ul>
<p>​		<strong>同步任务</strong>进入<strong>主线程</strong>，即主执行栈，<strong>异步任务</strong>进入<strong>任务队列</strong>，主线程内的任务执行完毕为空，会去任务队列读取对应的任务，推入主线程执行。上述过程的不断重复就是事件循环。</p>
<h4 id="微任务（JS引擎发起）"><a href="#微任务（JS引擎发起）" class="headerlink" title="微任务（JS引擎发起）"></a>微任务（JS引擎发起）</h4><p>​		一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p>
<p>常见的微任务有：</p>
<ul>
<li>Promise.then</li>
<li>MutaionObserver</li>
<li>Object.observe（已废弃；Proxy 对象替代）</li>
<li>process.nextTick（Node.js）</li>
</ul>
<h4 id="宏任务（浏览器、node发起）"><a href="#宏任务（浏览器、node发起）" class="headerlink" title="宏任务（浏览器、node发起）"></a>宏任务（浏览器、node发起）</h4><p>​		宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合。</p>
<p>常见的宏任务有：</p>
<ul>
<li>script (可以理解为外层同步代码)</li>
<li>setTimeout&#x2F;setInterval</li>
<li>UI rendering&#x2F;UI事件</li>
<li>postMessage、MessageChannel</li>
<li>setImmediate、I&#x2F;O（Node.js）</li>
</ul>
<p>加入宏任务和微任务后，事件循环变成如下：</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic17.png" alt="事件循环" style="zoom:80%;">

<ul>
<li>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中</li>
<li>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</li>
</ul>
<h3 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h3><h4 id="是什么？-4"><a href="#是什么？-4" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		提供与浏览器窗口进行交互的对象。</p>
<h4 id="DOM与BOM的区别"><a href="#DOM与BOM的区别" class="headerlink" title="DOM与BOM的区别"></a>DOM与BOM的区别</h4><table>
<thead>
<tr>
<th>DOM</th>
<th>BOM</th>
</tr>
</thead>
<tbody><tr>
<td>文档对象模型</td>
<td>浏览器对象模型</td>
</tr>
<tr>
<td>把文档当作一个对象</td>
<td>把浏览器当作一个对象</td>
</tr>
<tr>
<td>顶级对象是document</td>
<td>顶级对象是window</td>
</tr>
<tr>
<td>操作页面元素</td>
<td>与浏览器进行交互</td>
</tr>
<tr>
<td>W3C规范</td>
<td>浏览器厂商定义</td>
</tr>
</tbody></table>
<h4 id="常见的BOM对象"><a href="#常见的BOM对象" class="headerlink" title="常见的BOM对象"></a>常见的BOM对象</h4><h5 id="window"><a href="#window" class="headerlink" title="window"></a>window</h5><p>​		<code>Bom</code>的核心对象是<code>window</code>，它表示浏览器的一个实例。在浏览器中，<code>window</code>对象有双重角色，即<strong>是浏览器窗口的一个接口，又是全局对象</strong>。因此<strong>所有在全局作用域中声明的变量、函数都会变成<code>window</code>对象的属性和方法</strong>。</p>
<p>​		常用的窗口控制方法有：window.moveBy(x, y)、window.moveTo(x, y)、window.resizeBy(w, h)、window.scrollTo(x, y)。</p>
<p>​		<code>window.open()</code> 既可以导航到一个特定的<code>url</code>，也可以打开一个新的浏览器窗口。</p>
<h5 id="location"><a href="#location" class="headerlink" title="location"></a>location</h5><p>​		location常用的属性有：hash、host、hostname、href、pathname、port、protocol、search。</p>
<p>​		<code>location.reload()</code>，此方法可以重新刷新当前页面。这个方法会根据最有效的方式刷新页面，如果页面自上一次请求以来没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器中重新加载，传递一个参数<code>true</code>即可。</p>
<h5 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h5><p>​		<code>navigator</code> 对象主要用来获取浏览器的属性，<strong>区分浏览器类型</strong>。属性较多，且兼容性比较复杂。</p>
<h5 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h5><p>​		保存客户端显示器信息，如像素宽度和像素高度。</p>
<h5 id="history"><a href="#history" class="headerlink" title="history"></a>history</h5><p>​		<code>history</code>对象主要用来操作浏览器<code>URL</code>的历史记录，可以通过参数向前，向后，或者向指定<code>URL</code>跳转。</p>
<p>​		常用的属性有：history.go()、history.forward()、history.back()、history.length[获取历史记录数]</p>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>​		递归函数：一个函数在内部调用自身本身，这个函数就是递归函数。其核心思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p>
<p>​		尾递归，即在函数尾位置调用自身（或是一个尾调用本身的其他函数等等）。尾递归也是递归的一种特殊情形。尾递归是一种特殊的尾调用，即在尾部直接调用自身的递归函数。</p>
<p>​		在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢出。这时候，我们就可以使用尾递归，即一个函数中所有递归形式的调用都出现在函数的末尾，<strong>对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误。</strong></p>
<h3 id="JS中内存管理"><a href="#JS中内存管理" class="headerlink" title="JS中内存管理"></a>JS中内存管理</h3><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>​		由于疏忽或错误造成程序未能释放已经不再使用的内存。并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致<strong>在释放该段内存之前就失去了对该段内存的控制</strong>，从而造成了内存的浪费。</p>
<h4 id="JS垃圾回收机制"><a href="#JS垃圾回收机制" class="headerlink" title="JS垃圾回收机制"></a>JS垃圾回收机制</h4><p>​		自动垃圾回收机制。原理：垃圾收集器会定期（周期性）找出那些不再继续使用的变量，然后释放其内存。</p>
<p>通常情况下有两种实现方式：</p>
<ul>
<li>标记清除</li>
<li>引用计数</li>
</ul>
<h5 id="标记清除-清除存在上下文中的变量以及被上下文变量所引用的变量的标记"><a href="#标记清除-清除存在上下文中的变量以及被上下文变量所引用的变量的标记" class="headerlink" title="标记清除(清除存在上下文中的变量以及被上下文变量所引用的变量的标记)"></a>标记清除(清除存在上下文中的变量以及被上下文变量所引用的变量的标记)</h5><p>​		<code>JavaScript</code>最常用的垃圾收回机制。</p>
<p>​		当变量进入执行环境时，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“。</p>
<p>​		垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。</p>
<p>​		在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p>
<p>​		标记清除方案的<strong>缺点</strong>：在清除之后，剩余对象的内存位置是不变的，导致空闲内存空间是不连续的，也就是出现了内存碎片。内存碎片会给新建对象分配内存带来问题。解决方案：标记整理。标记整理与标记清除算法相同，只是标记结束后，标记整理算法会将活着的对象向内存的一端移动，最终清理掉边界的内存。</p>
<h5 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h5><p>​		语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是<code>0</code>，就表示这个值不再用到了，因此可以将这块内存释放。如果一个值不再需要了，引用数却不为<code>0</code>，垃圾回收机制无法释放这块内存，从而导致内存泄漏。</p>
<p>​		虽然JS有自动垃圾回收机制，但不代表不用关注内存泄露。那些很占空间的值，一旦不再用到，需要检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。</p>
<p>​		引用计数的<strong>缺点</strong>：需要计数器，会占用空间；无法解决循环引用问题；</p>
<h3 id="常见的内存泄露情况"><a href="#常见的内存泄露情况" class="headerlink" title="常见的内存泄露情况"></a>常见的内存泄露情况</h3><h4 id="意外的全局变量"><a href="#意外的全局变量" class="headerlink" title="意外的全局变量"></a>意外的全局变量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    bar = <span class="string">&quot;this is a hidden global variable&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">variable</span> = <span class="string">&quot;potential accidental global&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 调用自己，this 指向了全局对象（window）</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someResource = <span class="title function_">getData</span>();</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;Node&#x27;</span>);</span><br><span class="line">    <span class="comment">//当node从DOM中移除时，定时器仍然存在</span></span><br><span class="line">    <span class="keyword">if</span>(node) &#123;</span><br><span class="line">        <span class="comment">// 处理 node 和 someResource</span></span><br><span class="line">        node.<span class="property">innerHTML</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindEvent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;XXX&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> unused = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj, <span class="string">&#x27;闭包内引用obj obj不会被释放&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  obj = <span class="literal">null</span>; <span class="comment">// 解决方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="没有及时清理DOM元素引用"><a href="#没有及时清理DOM元素引用" class="headerlink" title="没有及时清理DOM元素引用"></a>没有及时清理DOM元素引用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refA = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;refA&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(refA); <span class="comment">// dom删除了</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(refA, <span class="string">&#x27;refA&#x27;</span>); <span class="comment">// 但是还存在引用能console出整个div 没有被回收</span></span><br><span class="line">refA = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(refA, <span class="string">&#x27;refA&#x27;</span>); <span class="comment">// 解除引用</span></span><br></pre></td></tr></table></figure>



<h3 id="JS本地存储方式"><a href="#JS本地存储方式" class="headerlink" title="JS本地存储方式"></a>JS本地存储方式</h3><p><code>javaScript</code>本地缓存的方法我们主要讲述以下四种：</p>
<ul>
<li>cookie</li>
<li>sessionStorage</li>
<li>localStorage</li>
<li>indexedDB</li>
</ul>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>​		HTTP协议具有无状态的特点，对于事件处理没有记忆，每次都是独立请求，无法保持客户端与服务端的会话状态。无法根据之前的请求状态进行本次的请求处理。</p>
<p>​		<code>Cookie</code>是某些网站为了辨别用户身份而储存在用户本地终端上的数据，是为了解决 <code>HTTP</code><strong>无状态</strong>导致的问题。</p>
<p>​		一般不超过 4KB 的小型文本数据，它由一个名称（Name）、一个值（Value）和其它几个用于控制 <code>cookie</code>有效期、安全性、使用范围的可选属性组成。</p>
<p>​		<code>cookie</code><strong>在每次请求中都会被发送</strong>，如果不使用 <code>HTTPS</code>并对其加密，其保存的信息很容易被窃取，导致安全风险。举个例子，在一些使用 <code>cookie</code>保持登录态的网站上，如果 <code>cookie</code>被窃取，他人很容易利用你的 <code>cookie</code>来假扮成你登录网站。</p>
<h5 id="cookie常用属性"><a href="#cookie常用属性" class="headerlink" title="cookie常用属性"></a>cookie常用属性</h5><ul>
<li>Expires 用于设置 Cookie 的过期时间</li>
<li>Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比<code>Expires</code>高）</li>
<li><code>Domain</code>指定了 <code>Cookie</code> 可以送达的主机名。<code>Domain</code> 属性**指定了哪些主机可以接受 <code>Cookie</code>**，如果不指定，默认为 <code>Origin</code>，但不包含子域名。当多个子域名需要共享 <code>Cookie</code> 信息的时候，就必须要指定 <code>Domain</code> 属性值为一级域名，指定 <code>Path</code> 属性值为根路径。</li>
<li><code>Path</code>指定了一个 <code>URL</code>路径，这个路径必须出现在要请求的资源的路径中才可以发送 <code>Cookie</code> 首部。**<code>Path</code> 属性指定了主机下的哪些路径可以接受 <code>Cookie</code>，子路径也可以被匹配。**</li>
<li>标记为 <code>Secure</code>的 <code>Cookie</code>只应通过被<code>HTTPS</code>协议加密过的请求发送给服务端</li>
</ul>
<h5 id="localstorage"><a href="#localstorage" class="headerlink" title="localstorage"></a>localstorage</h5><p>特点：</p>
<ul>
<li>生命周期：持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的</li>
<li>存储的信息<strong>在同一域中是共享的</strong></li>
<li>当本页操作（新增、修改、删除）了<code>localStorage</code>的时候，本页面不会触发<code>storage</code>事件,但是别的页面会触发<code>storage</code>事件。</li>
<li>大小：5M（跟浏览器厂商有关系）</li>
<li><code>localStorage</code>本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li>
<li><strong>受同源策略的限制</strong></li>
<li>无法像<code>Cookie</code>一样设置过期时间</li>
<li>只能存入字符串，无法直接存对象</li>
</ul>
<p>常用方法：setItem、getItem、removeItem</p>
<h5 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h5><p>​		<code>sessionStorage</code>和 <code>localStorage</code>使用方法基本一致，唯一不同的是生命周期，一旦页面（会话）关闭，<code>sessionStorage</code> 将会删除数据</p>
<h5 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h5><ul>
<li>是存储大量结构化数据的数据库</li>
<li>储存量理论上没有上限</li>
<li>所有操作都是异步的，相比 <code>LocalStorage</code> 同步操作性能更高，尤其是数据量较大时</li>
<li>原生支持储存<code>JS</code>的对象</li>
<li>是个正经的数据库，意味着数据库能干的事它都能干</li>
</ul>
<h4 id="cookie、localStorage、sessionStorage的区别"><a href="#cookie、localStorage、sessionStorage的区别" class="headerlink" title="cookie、localStorage、sessionStorage的区别"></a>cookie、localStorage、sessionStorage的区别</h4><ul>
<li>存储大小：<code>cookie</code>数据大小不能超过<code>4k</code>，<code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到5M或更大</li>
<li>有效时间：<code>localStorage</code>存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； <code>sessionStorage</code>数据在当前浏览器窗口关闭后自动删除；<code>cookie</code>设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li>
<li>数据与服务器之间的交互方式，<code>cookie</code>的数据会自动的传递到服务器，服务器端也可以写<code>cookie</code>到客户端； <code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li>
</ul>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h4 id="是什么？-5"><a href="#是什么？-5" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而非设计一个复杂的执行过程。</p>
<p>​		函数式编程旨在尽可能的提高代码的<strong>无状态性和不变性</strong>。要做到这一点，就要学会使用无副作用的函数，也就是纯函数。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况</li>
<li>更简单的复用：固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响</li>
<li>更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性</li>
<li>隐性好处。减少代码量，提高维护性</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销</li>
<li>资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式</li>
<li>递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作</li>
</ul>
<h3 id="JS中实现函数缓存"><a href="#JS中实现函数缓存" class="headerlink" title="JS中实现函数缓存"></a>JS中实现函数缓存</h3><h4 id="是什么？-6"><a href="#是什么？-6" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		函数缓存，就是将函数运算过的结果进行缓存。本质上就是用空间（缓存存储）换时间（计算过程）。常用于缓存数据计算结果和缓存对象。</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>​		闭包、柯里化、高阶函数</p>
<h3 id="数字精度丢失"><a href="#数字精度丢失" class="headerlink" title="数字精度丢失"></a>数字精度丢失</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>​		计算机存储双精度浮点数需要先把十进制数转换为二进制的科学记数法的形式，然后计算机以自己的规则{符号位+(指数位+指数偏移量的二进制)+小数部分}存储二进制的科学记数法。</p>
<p>​		因为存储时有位数限制（64位），并且某些十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0舍1入)，当再转换为十进制时就造成了计算误差。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>​		理论上无法解决，只能处理数据得到期望的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">strip</span>(<span class="params">num, precision = <span class="number">12</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> +<span class="built_in">parseFloat</span>(num.<span class="title function_">toPrecision</span>(precision));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="防抖与节流的应用场景"><a href="#防抖与节流的应用场景" class="headerlink" title="防抖与节流的应用场景"></a>防抖与节流的应用场景</h3><p>防抖在连续的事件，只需触发一次回调的场景有：</p>
<ul>
<li>搜索框搜索输入。只需用户最后一次输入完，再发送请求</li>
<li>手机号、邮箱验证输入检测</li>
<li>窗口大小<code>resize</code>。只需窗口调整完成后，计算窗口大小。防止重复渲染。</li>
</ul>
<p>节流在间隔一段时间执行一次回调的场景有：</p>
<ul>
<li>滚动加载，加载更多或滚到底部监听</li>
<li>搜索框，搜索联想功能</li>
</ul>
<h3 id="判断元素是否在可视区"><a href="#判断元素是否在可视区" class="headerlink" title="判断元素是否在可视区"></a>判断元素是否在可视区</h3><h4 id="是什么？-7"><a href="#是什么？-7" class="headerlink" title="是什么？"></a>是什么？</h4><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic18.png" alt="可视区" style="zoom:50%;">

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li>offsetTop、scrollTop</li>
<li>getBoundingClientRect</li>
<li>Intersection Observer</li>
</ul>
<h5 id="offsetTop、scrollTop"><a href="#offsetTop、scrollTop" class="headerlink" title="offsetTop、scrollTop"></a>offsetTop、scrollTop</h5><p>offsetTop:当前元素<strong>顶端</strong>距离<strong>父元素顶端距离</strong>,鼠标滚轮不会影响其数值.</p>
<p>scrollTop:当前元素<strong>顶端</strong>距离<strong>窗口顶端距离</strong>,鼠标滚轮会影响其数值.外层元素的高度值是200px,内层元素的高度值是300px。很明显，“外层元素中的内容”高过了“外层元素”本身.当向下拖动滚动条时，有部分内容会隐没在“外层元素的上边界”之外，<code>scrollTop</code>就等于这部分“不可见的内容”的高度。</p>
<p>clientHeight与clientWidth如图所示</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic19.png" alt="clientHeight" style="zoom:80%;">

<p><strong>判断：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 精简代码</span></span><br><span class="line">el.<span class="property">offsetTop</span> - <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> &lt;= viewPortHeight</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h5><p>返回值是一个 <code>DOMRect</code>对象，拥有<code>left</code>, <code>top</code>, <code>right</code>, <code>bottom</code>, <code>x</code>, <code>y</code>, <code>width</code>, 和 <code>height</code>属性</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic20.png" alt="getBoundingClientRect" style="zoom:50%;">

<p>如果一个元素在视窗之内的话，那么它一定满足下面四个条件：</p>
<ul>
<li>top 大于等于 0</li>
<li>left 大于等于 0</li>
<li>bottom 小于等于视窗高度</li>
<li>right 小于等于视窗宽度</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isInViewPort</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> viewWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">  <span class="keyword">const</span> viewHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    top,</span><br><span class="line">    right,</span><br><span class="line">    bottom,</span><br><span class="line">    left,</span><br><span class="line">  &#125; = element.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    top &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    left &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">    right &lt;= viewWidth &amp;&amp;</span><br><span class="line">    bottom &lt;= viewHeight</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Intersection-Observer"><a href="#Intersection-Observer" class="headerlink" title="Intersection Observer"></a>Intersection Observer</h5><p><code>Intersection Observer</code> 即重叠观察者，<strong>用于判断两个元素是否重叠</strong>，因为不用进行事件的监听，性能方面相比<code>getBoundingClientRect</code>会好很多</p>
<p>使用步骤主要分为两步：创建观察者和传入被观察者</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建观察者</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="comment">// 表示重叠面积占被观察者的比例，从 0 - 1 取值，</span></span><br><span class="line">  <span class="comment">// 1 表示完全被包含</span></span><br><span class="line">  <span class="attr">threshold</span>: <span class="number">1.0</span>, </span><br><span class="line">  <span class="attr">root</span>:<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#scrollArea&#x27;</span>) <span class="comment">// 必须是目标元素的父级元素</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params">entries, observer</span>) =&gt; &#123; ....&#125;</span><br><span class="line"><span class="comment">// 传入的参数 callback 在重叠比例超过 threshold 时会被执行</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入被观察者</span></span><br><span class="line"><span class="keyword">const</span> target = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.target&#x27;</span>);</span><br><span class="line">observer.<span class="title function_">observe</span>(target);</span><br></pre></td></tr></table></figure>

<h5 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h5><p>实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色</p>
<ul>
<li>使用getBoundingClientRect</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.container &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">&#125;</span><br><span class="line">.target &#123;</span><br><span class="line">    margin: 5px;</span><br><span class="line">    width: 20px;</span><br><span class="line">    height: 20px;</span><br><span class="line">    background: red;</span><br><span class="line">&#125;</span><br><span class="line">const $container = $(&quot;.container&quot;);</span><br><span class="line"></span><br><span class="line">// 插入 100000 个 <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;target&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">function createTargets() &#123;</span><br><span class="line">  const htmlString = new Array(100000)</span><br><span class="line">    .fill(&#x27;<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;target&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#x27;)</span><br><span class="line">    .join(&quot;&quot;);</span><br><span class="line">  $container.html(htmlString);</span><br><span class="line">&#125;</span><br><span class="line">function isInViewPort(element) &#123;</span><br><span class="line">    const viewWidth = window.innerWidth || document.documentElement.clientWidth;</span><br><span class="line">    const viewHeight =</span><br><span class="line">          window.innerHeight || document.documentElement.clientHeight;</span><br><span class="line">    const &#123; top, right, bottom, left &#125; = element.getBoundingClientRect();</span><br><span class="line"></span><br><span class="line">    return top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight;</span><br><span class="line">&#125;</span><br><span class="line">$(window).on(&quot;scroll&quot;, () =&gt; &#123;</span><br><span class="line">    console.log(&quot;scroll !&quot;);</span><br><span class="line">    $targets.each((index, element) =&gt; &#123;</span><br><span class="line">        if (isInViewPort(element)) &#123;</span><br><span class="line">            $(element).css(&quot;background-color&quot;, &quot;yellow&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Intersection Observer</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(getYellow, &#123; <span class="attr">threshold</span>: <span class="number">1.0</span> &#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getYellow</span>(<span class="params">entries, observer</span>) &#123;</span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">        $(entry.<span class="property">target</span>).<span class="title function_">css</span>(<span class="string">&quot;background-color&quot;</span>, <span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">$targets.<span class="title function_">each</span>(<span class="function">(<span class="params">index, element</span>) =&gt;</span> &#123;</span><br><span class="line">    observer.<span class="title function_">observe</span>(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="大文件上传时断点续传"><a href="#大文件上传时断点续传" class="headerlink" title="大文件上传时断点续传"></a>大文件上传时断点续传</h3><h4 id="是什么？-8"><a href="#是什么？-8" class="headerlink" title="是什么？"></a>是什么？</h4><h5 id="分片上传"><a href="#分片上传" class="headerlink" title="分片上传"></a>分片上传</h5><ul>
<li>概念：将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传。上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件。</li>
<li>大致流程</li>
</ul>
<ol>
<li>将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；</li>
<li>初始化一个分片上传任务，返回本次分片上传唯一标识；</li>
<li>按照一定的策略（串行或并行）发送各个分片数据块；</li>
<li>发送完成后，服务端判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件</li>
</ol>
<h5 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h5><p>​		断点续传文件数据块采用线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度。</p>
<p>​		一般实现方式有两种：</p>
<ul>
<li>服务器端返回，告知从哪开始</li>
<li>浏览器端自行处理</li>
</ul>
<p>​		上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可。</p>
<p>​		如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可。</p>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>​		整体思路：拿到文件，保存文件唯一性标识(最简单的是md5)，切割文件，分段上传，每上传一段，就根据唯一性标识判断文件上传进度，直到文件的全部片段上传完毕。</p>
<img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/pic21.png" alt="分片上传" style="zoom:50%;">

<p>伪代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> file = <span class="variable language_">this</span>.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用md5实现文件的唯一性</span></span><br><span class="line"><span class="keyword">const</span> md5code = <span class="title function_">md5</span>(file);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对文件进行分割</span></span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">reader.<span class="title function_">readAsArrayBuffer</span>(file);</span><br><span class="line">reader.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">//每10M切割一段,这里只做一个切割演示，实际切割需要循环切割，</span></span><br><span class="line">    <span class="keyword">var</span> slice = e.<span class="property">target</span>.<span class="property">result</span>.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// h5上传一个（一片）</span></span><br><span class="line"><span class="keyword">const</span> formdata = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">formdata.<span class="title function_">append</span>(<span class="string">&#x27;0&#x27;</span>, slice);</span><br><span class="line"><span class="comment">//这里是有一个坑的，部分设备无法获取文件名称，和文件类型，这个在最后给出解决方案</span></span><br><span class="line">formdata.<span class="title function_">append</span>(<span class="string">&#x27;filename&#x27;</span>, file.<span class="property">filename</span>);</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//xhr.responseText</span></span><br><span class="line">&#125;);</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">xhr.<span class="title function_">send</span>(formdata);</span><br><span class="line">xhr.<span class="title function_">addEventListener</span>(<span class="string">&#x27;progress&#x27;</span>, updateProgress);</span><br><span class="line">xhr.<span class="property">upload</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;progress&#x27;</span>, updateProgress);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateProgress</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">        <span class="comment">//进度条</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见的图片和视频的文件类型判断</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkFileType</span>(<span class="params">type, file, back</span>) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* type png jpg mp4 ...</span></span><br><span class="line"><span class="comment">* file input.change=&gt; this.files[0]</span></span><br><span class="line"><span class="comment">* back callback(boolean)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="title function_">back</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> type = args[<span class="number">0</span>]; <span class="comment">// type = &#x27;(png|jpg)&#x27; , &#x27;png&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> file = args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> back = <span class="keyword">typeof</span> args[<span class="number">2</span>] == <span class="string">&#x27;function&#x27;</span> ? args[<span class="number">2</span>] : <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="property">type</span> == <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果系统无法获取文件类型，则读取二进制流，对二进制进行解析文件类型</span></span><br><span class="line">        <span class="keyword">var</span> imgType = [</span><br><span class="line">            <span class="string">&#x27;ff d8 ff&#x27;</span>, <span class="comment">//jpg</span></span><br><span class="line">            <span class="string">&#x27;89 50 4e&#x27;</span>, <span class="comment">//png</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;0 0 0 14 66 74 79 70 69 73 6F 6D&#x27;</span>, <span class="comment">//mp4</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 18 66 74 79 70 33 67 70 35&#x27;</span>, <span class="comment">//mp4</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 0 66 74 79 70 33 67 70 35&#x27;</span>, <span class="comment">//mp4</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 0 66 74 79 70 4D 53 4E 56&#x27;</span>, <span class="comment">//mp4</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 0 66 74 79 70 69 73 6F 6D&#x27;</span>, <span class="comment">//mp4</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;0 0 0 18 66 74 79 70 6D 70 34 32&#x27;</span>, <span class="comment">//m4v</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 0 66 74 79 70 6D 70 34 32&#x27;</span>, <span class="comment">//m4v</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;0 0 0 14 66 74 79 70 71 74 20 20&#x27;</span>, <span class="comment">//mov</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 0 66 74 79 70 71 74 20 20&#x27;</span>, <span class="comment">//mov</span></span><br><span class="line">            <span class="string">&#x27;0 0 0 0 6D 6F 6F 76&#x27;</span>, <span class="comment">//mov</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;4F 67 67 53 0 02&#x27;</span>, <span class="comment">//ogg</span></span><br><span class="line">            <span class="string">&#x27;1A 45 DF A3&#x27;</span>, <span class="comment">//ogg</span></span><br><span class="line"></span><br><span class="line">            <span class="string">&#x27;52 49 46 46 x x x x 41 56 49 20&#x27;</span>, <span class="comment">//avi (RIFF fileSize fileType LIST)(52 49 46 46,DC 6C 57 09,41 56 49 20,4C 49 53 54)</span></span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">var</span> typeName = [</span><br><span class="line">            <span class="string">&#x27;jpg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;png&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mp4&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mp4&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mp4&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mp4&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mp4&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;m4v&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;m4v&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mov&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mov&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mov&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;ogg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;ogg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;avi&#x27;</span>,</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">var</span> sliceSize = <span class="regexp">/png|jpg|jpeg/</span>.<span class="title function_">test</span>(type) ? <span class="number">3</span> : <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">        reader.<span class="title function_">readAsArrayBuffer</span>(file);</span><br><span class="line">        reader.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> slice = e.<span class="property">target</span>.<span class="property">result</span>.<span class="title function_">slice</span>(<span class="number">0</span>, sliceSize);</span><br><span class="line">            reader = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (slice &amp;&amp; slice.<span class="property">byteLength</span> == sliceSize) &#123;</span><br><span class="line">                <span class="keyword">var</span> view = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(slice);</span><br><span class="line">                <span class="keyword">var</span> arr = [];</span><br><span class="line">                view.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">v</span>) &#123;</span><br><span class="line">                    arr.<span class="title function_">push</span>(v.<span class="title function_">toString</span>(<span class="number">16</span>));</span><br><span class="line">                &#125;);</span><br><span class="line">                view = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">var</span> idx = arr.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">indexOf</span>(imgType);</span><br><span class="line">                <span class="keyword">if</span> (idx &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="title function_">back</span>(typeName[idx]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    arr = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">v</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">3</span> &amp;&amp; i &lt; <span class="number">8</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> v;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">var</span> idx = arr.<span class="title function_">join</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">indexOf</span>(imgType);</span><br><span class="line">                    <span class="keyword">if</span> (idx &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="title function_">back</span>(typeName[idx]);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="title function_">back</span>(<span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">back</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> type = file.<span class="property">name</span>.<span class="title function_">match</span>(<span class="regexp">/\.(\w+)$/</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="title function_">back</span>(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="title function_">checkFileType</span>(<span class="string">&#x27;(mov|mp4|avi)&#x27;</span>,file,<span class="keyword">function</span>(<span class="params">fileType</span>)&#123;</span><br><span class="line">    <span class="comment">// fileType = mp4,</span></span><br><span class="line">    <span class="comment">// 如果file的类型不在枚举之列，则返回false</span></span><br><span class="line">&#125;);</span><br><span class="line">formdata.<span class="title function_">append</span>(<span class="string">&#x27;filename&#x27;</span>, md5code+<span class="string">&#x27;.&#x27;</span>+fileType);</span><br></pre></td></tr></table></figure>

<p>后端主要做的内容为：根据前端传给后台的<code>md5</code>值，到服务器磁盘查找是否有之前未完成的文件合并信息（也就是未完成的半成品文件切片），取到之后根据上传切片的数量，返回数据告诉前端开始从第几节上传</p>
<p>如果想要暂停切片的上传，可以使用<code>XMLHttpRequest</code>的 <code>abort</code>方法</p>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>大文件加速上传：当文件大小超过预期大小时，使用分片上传可实现并行上传多个 Part， 以加快上传速度</li>
<li>网络环境较差：建议使用分片上传。当出现上传失败的时候，仅需重传失败的Part</li>
<li>流式上传：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在视频监控等行业应用中比较常见</li>
</ul>
<h3 id="实现上拉加载，下拉刷新"><a href="#实现上拉加载，下拉刷新" class="headerlink" title="实现上拉加载，下拉刷新"></a>实现上拉加载，下拉刷新</h3><h4 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h4><p>上拉加载的本质是页面触底，或者快要触底时的动作</p>
<p>判断页面触底需要先了解下面几个属性</p>
<ul>
<li><code>scrollTop</code>：滚动视窗的高度距离<code>window</code>顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值</li>
<li><code>clientHeight</code>:它是一个定值，表示<strong>屏幕可视区域的高度</strong>；</li>
<li><code>scrollHeight</code>：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。<strong>scrollHeight表示<code>body</code>所有元素的总长度(包括body元素自身的padding)</strong></li>
</ul>
<p>综上得出一个触底公式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scrollTop + clientHeight &gt;= scrollHeight</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单实现</span></span><br><span class="line"><span class="keyword">let</span> clientHeight  = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>; <span class="comment">//浏览器高度</span></span><br><span class="line"><span class="keyword">let</span> scrollHeight = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollHeight</span>;</span><br><span class="line"><span class="keyword">let</span> scrollTop = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>;</span><br><span class="line"><span class="keyword">let</span> distance = <span class="number">50</span>;  <span class="comment">//距离视窗还用50的时候，开始触发；</span></span><br><span class="line"><span class="keyword">if</span> ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;开始加载数据&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h4><p>关于下拉刷新的原生实现，主要分成三步：</p>
<ul>
<li>监听原生<code>touchstart</code>事件，记录其初始位置的值，<code>e.touches[0].pageY</code>；</li>
<li>监听原生<code>touchmove</code>事件，记录并计算当前滑动的位置值与初始位置值的差值，大于<code>0</code>表示向下拉动，并借助CSS3的<code>translateY</code>属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值；</li>
<li>监听原生<code>touchend</code>事件，若此时元素滑动达到最大值，则触发<code>callback</code>，同时将<code>translateY</code>重设为<code>0</code>，元素回到初始位置</li>
</ul>
<h3 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h3><h4 id="是什么？-9"><a href="#是什么？-9" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		<code>系统A</code> 和 <code>系统B</code> 都属于某公司下的两个不同的应用系统，当用户登录 <code>系统A</code> 后，再打开 <code>系统B</code> ，系统便会自动帮用户登录 <code>系统B</code> ，这种现象就属于单点登录。</p>
<p>​		单点登录SSO：在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
<p>SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过<code>passport</code>，子系统本身将不参与登录操作。当一个系统成功登录以后，<code>passport</code>将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被<code>passport</code>授权以后，会建立一个局部会话，在一定时间内可以无需再次向<code>passport</code>发起认证。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>同域名下的单点登录：cookie domain</li>
<li>不同域名下的单点登录：token、localstorage</li>
</ul>
<h5 id="同域名下：cookie-domain"><a href="#同域名下：cookie-domain" class="headerlink" title="同域名下：cookie domain"></a>同域名下：cookie domain</h5><p>​		<code>cookie</code>的<code>domain</code>属性设置为当前域的父域，并且父域的<code>cookie</code>会被子域所共享。<code>path</code>属性默认为<code>web</code>应用的上下文路径。</p>
<p>​		利用 <code>Cookie</code> 的这个特点，没错，我们只需要将<code>Cookie</code>的<code>domain</code>属性设置为父域的域名（主域名），同时将 <code>Cookie</code>的<code>path</code>属性设置为根路径，将 <code>Session ID</code>（或 <code>Token</code>）保存到父域中。这样所有的子域应用就都可以访问到这个<code>Cookie</code>。</p>
<p>​		当多个子域名需要共享 <code>Cookie</code> 信息的时候，就必须要指定 <code>Domain</code> 属性值为一级域名，指定 <code>Path</code> 属性值为根路径。</p>
<h5 id="不同域名下：token"><a href="#不同域名下：token" class="headerlink" title="不同域名下：token"></a>不同域名下：token</h5><p>如果是不同域的情况下，<code>Cookie</code>是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的 <code>Web</code>服务</p>
<p>用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 <code>token</code> 写入 <code>Cookie</code>（注意这个 <code>Cookie</code>是认证中心的，应用系统是访问不到的）</p>
<p>应用系统检查当前请求有没有 <code>Token</code>，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心</p>
<p>由于这个操作会将认证中心的 <code>Cookie</code> 自动带过去，因此，认证中心能够根据 <code>Cookie</code> 知道用户是否已经登录过了</p>
<p>如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录</p>
<p>如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 <code>URL</code>，并在跳转前生成一个 <code>Token</code>，拼接在目标<code>URL</code> 的后面，回传给目标应用系统</p>
<p>应用系统拿到 <code>Token</code>之后，还需要向认证中心确认下 <code>Token</code> 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 <code>Token</code>写入<code>Cookie</code>，然后给本次访问放行。（注意这个 <code>Cookie</code> 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 <code>Token</code>，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了</p>
<p>​		用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数。sso认证中心发现用户未登录，将用户引导至登录页面。用户输入用户名密码提交登录申请。sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌。sso认证中心带着令牌跳转回最初的请求地址（系统1）。系统1拿到令牌，去sso认证中心校验令牌是否有效。sso认证中心校验令牌，返回有效，注册系统1。系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源。用户访问系统2的受保护资源。系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数。sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌。系统2拿到令牌，去sso认证中心校验令牌是否有效。sso认证中心校验令牌，返回有效，注册系统2。系统2使用该令牌创建与用户的局部会话，返回受保护资源。</p>
<h5 id="不同域名下：localstorage"><a href="#不同域名下：localstorage" class="headerlink" title="不同域名下：localstorage"></a>不同域名下：localstorage</h5><p>可以选择将 <code>Session ID</code> （或 <code>Token</code> ）保存到浏览器的 <code>LocalStorage</code> 中，让前端在每次向后端发送请求时，主动将<code>LocalStorage</code>的数据传递给服务端。</p>
<p>这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 <code>Session ID</code>（或 <code>Token</code>）放在响应体中传递给前端。</p>
<p>单点登录完全可以在前端实现。前端拿到 <code>Session ID</code>（或 <code>Token</code> ）后，除了将它写入自己的 <code>LocalStorage</code> 中之外，还可以通过特殊手段将它写入多个其他域下的 <code>LocalStorage</code> 中。</p>
<p>前端通过 <code>iframe</code>+<code>postMessage()</code> 方式，将同一份 <code>Token</code> 写入到了多个域下的 <code>LocalStorage</code> 中，前端每次在向后端发送请求之前，都会主动从 <code>LocalStorage</code> 中读取<code>Token</code>并在请求中携带，这样就实现了同一份<code>Token</code> 被多个域所共享。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 token</span></span><br><span class="line"><span class="keyword">var</span> token = result.<span class="property">data</span>.<span class="property">token</span>;</span><br><span class="line"><span class="comment">// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML</span></span><br><span class="line"><span class="comment">// 子页面</span></span><br><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line">iframe.<span class="property">src</span> = <span class="string">&quot;http://app1.com/localstorage.html&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">append</span>(iframe);</span><br><span class="line"><span class="comment">// 使用postMessage()方法将token传递给iframe</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从广义上讲，一个窗口可以获得对另一个窗口的引用（比如 targetWindow = window.opener），然后在窗口上调用 targetWindow.postMessage() 方法分发一个 MessageEvent 消息。接收消息的窗口可以根据需要自由处理此事件 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 父页面</span></span><br><span class="line">    iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(token, <span class="string">&quot;http://app1.com&quot;</span>);</span><br><span class="line">&#125;, <span class="number">4000</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    iframe.<span class="title function_">remove</span>();</span><br><span class="line">&#125;, <span class="number">6000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;token&#x27;</span>, event.<span class="property">data</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h3 id="CSS放头部，JS放尾部"><a href="#CSS放头部，JS放尾部" class="headerlink" title="CSS放头部，JS放尾部"></a>CSS放头部，JS放尾部</h3><p>​		css放头部，可以给用户带来更好的体验感，渲染引擎会尝试尽快在屏幕上显示内容。这样做不会等到所有HTML元素解析之后才开始构建和布局DOM树。浏览器能够渲染不完整的DOM树和CSSOM，尽快减少白屏时间。</p>
<p>​		JS放尾部，是因为JS的下载和运行会阻塞DOM的解析，从而影响DOM树的绘制。此外，JS可能会改变DOM树的结构，所以需要一个稳定的DOM树。</p>
<h3 id="web常见的攻击方式及防御方法"><a href="#web常见的攻击方式及防御方法" class="headerlink" title="web常见的攻击方式及防御方法"></a>web常见的攻击方式及防御方法</h3><h4 id="常见的攻击方式"><a href="#常见的攻击方式" class="headerlink" title="常见的攻击方式"></a>常见的攻击方式</h4><ul>
<li>XSS（跨站脚本攻击）</li>
<li>CSRF（跨站请求伪造）</li>
<li>SQL注入攻击</li>
</ul>
<h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><h5 id="是什么？-10"><a href="#是什么？-10" class="headerlink" title="是什么？"></a>是什么？</h5><p>​		跨站脚本攻击允许攻击者将恶意代码植入到页面中。在这个过程中，涉及三方：攻击者、客户端与web应用。攻击的目的是获取客户端的cookie或者其他服务器用于识别客户端身份的信息。一旦获取，攻击者就可以假冒用户与服务器进行交互。</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li>存储型</li>
<li>反射型</li>
<li>DOM型</li>
</ul>
<h5 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h5><p>攻击<strong>步骤</strong>：</p>
<ol>
<li>攻击者将恶意代码提交到目标网站的数据库中</li>
<li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>
</ol>
<p><strong>场景</strong>：这种攻击常见于带有用户<strong>保存数据</strong>的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<h5 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h5><p>攻击<strong>步骤</strong>：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码</li>
<li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器</li>
<li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>
</ol>
<p><strong>场景</strong>：反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>
<p>反射型 XSS 跟存储型 XSS 的<strong>区别</strong>是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p>
<h5 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h5><p>攻击<strong>步骤</strong>：</p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码</li>
<li>用户打开带有恶意代码的 URL</li>
<li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作</li>
</ol>
<p>DOM 型 XSS 跟前两种 XSS 的<strong>区别</strong>：DOM 型 XSS 攻击中，取出和执行恶意代码由<strong>浏览器端</strong>完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于<strong>服务端</strong>的安全漏洞</p>
<h5 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h5><p>XSS攻击的两大要素</p>
<ul>
<li>攻击者提交恶意代码</li>
<li>浏览器执行恶意代码</li>
</ul>
<p>针对提交恶意代码的防御（过滤）</p>
<ul>
<li>在用户输入的过程中，过滤用户输入的恶意代码</li>
<li>在后端写入数据库前，对输入进行过滤，然后将内容传给前端。但是这种方法可能会导致输入内容在不同的地方有不同的展示形式。</li>
</ul>
<p>防止执行恶意代码</p>
<ul>
<li>使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等</li>
<li>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</li>
</ul>
<h4 id="CSRF（跨站请求伪造）"><a href="#CSRF（跨站请求伪造）" class="headerlink" title="CSRF（跨站请求伪造）"></a>CSRF（跨站请求伪造）</h4><h5 id="是什么？-11"><a href="#是什么？-11" class="headerlink" title="是什么？"></a>是什么？</h5><p>​		攻击者诱导受害者进入第三方网站，在第三方网站中向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台用户验证，达到冒充用户对被攻击网站执行操作的目的。</p>
<h5 id="典型流程"><a href="#典型流程" class="headerlink" title="典型流程"></a>典型流程</h5><ul>
<li>受害者登录a.com，并保留了登录凭证（Cookie）</li>
<li>攻击者引诱受害者访问了b.com</li>
<li>b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx。浏览器会默认携带a.com的Cookie</li>
<li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求</li>
<li>a.com以受害者的名义执行了act&#x3D;xx</li>
<li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作</li>
</ul>
<h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p>​		可以通过<code>get</code>请求、通过设置自动提交表单发送<code>post</code>请求、<code>a</code>标签</p>
<h5 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h5><ul>
<li>验证HTTP Referer字段。HTTP请求头中Referer字段用于记录HTTP请求的来源地址。由于CSRF是通过第三方网站向目标网站进行请求的，故Referer将指向恶意的第三方网站。目标网站只需验证Referer值是否是来自网站自己的请求。当然Referer字段可能会被攻击者篡改。</li>
<li>在请求地址中添加token。CSRF无法直接窃取用户信息，而是直接让用户利用自己的cookie来通过服务器验证的。要抵御 CSRF，关键在于在请求中放攻击者所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</li>
</ul>
<h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><h5 id="是什么？-12"><a href="#是什么？-12" class="headerlink" title="是什么？"></a>是什么？</h5><p>​		通过将恶意的 <code>Sql</code>查询或添加语句插入到应用的输入参数中，再在后台 <code>Sql</code>服务器上解析执行进行的攻击。</p>
<h5 id="典型流程-1"><a href="#典型流程-1" class="headerlink" title="典型流程"></a>典型流程</h5><ul>
<li>找出SQL漏洞的注入点</li>
<li>判断数据库的类型以及版本</li>
<li>猜解用户名和密码</li>
<li>利用工具查找Web后台管理入口</li>
<li>入侵和破坏</li>
</ul>
<h5 id="预防-1"><a href="#预防-1" class="headerlink" title="预防"></a>预防</h5><ul>
<li>严格检查输入变量的类型和格式</li>
<li>过滤和转义特殊字符</li>
<li>对访问数据库的Web应用程序采用Web应用防火墙</li>
</ul>
<h3 id="获取元素宽高"><a href="#获取元素宽高" class="headerlink" title="获取元素宽高"></a>获取元素宽高</h3><ol>
<li>获取内联样式宽高：el.style.width&#x2F;height</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;documentLabel&#x27;</span>);</span><br><span class="line">el.<span class="property">style</span>.<span class="property">width</span>;</span><br><span class="line">el.<span class="property">style</span>.<span class="property">height</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>el.getBoundingClientRect().width&#x2F;height</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;documentLabel&#x27;</span>);</span><br><span class="line">el.<span class="title function_">getBoundingClientRect</span>().<span class="property">width</span>;</span><br><span class="line">el.<span class="title function_">getBoundingClientRect</span>().<span class="property">height</span>;</span><br></pre></td></tr></table></figure>



<h3 id="与宽高相关的属性"><a href="#与宽高相关的属性" class="headerlink" title="与宽高相关的属性"></a>与宽高相关的属性</h3><h4 id="元素属性"><a href="#元素属性" class="headerlink" title="元素属性"></a>元素属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">el.<span class="property">clientWidth</span>; <span class="comment">//可见区域宽</span></span><br><span class="line">el.<span class="property">clientHeight</span>; <span class="comment">//可见区域高</span></span><br><span class="line">el.<span class="property">offsetWidth</span>; <span class="comment">//可见区域宽+边线宽</span></span><br><span class="line">el.<span class="property">offsetHeight</span>; <span class="comment">//可见区域高+边线高</span></span><br><span class="line">el.<span class="property">scrollWidth</span>; <span class="comment">//正文全文宽</span></span><br><span class="line">el.<span class="property">scrollHeight</span>; <span class="comment">//正文全文高</span></span><br><span class="line">el.<span class="property">scrollTop</span>; <span class="comment">//滑动的高</span></span><br><span class="line">el.<span class="property">scrollLeft</span>; <span class="comment">//滑动的左</span></span><br></pre></td></tr></table></figure>

<h4 id="浏览器属性"><a href="#浏览器属性" class="headerlink" title="浏览器属性"></a>浏览器属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">screenTop</span>; <span class="comment">//从屏幕上边到由window对象表示的页面可见区域的距离</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">screenLeft</span>; <span class="comment">//从屏幕左边到由window对象表示的页面可见区域的距离</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">height</span>; <span class="comment">//屏幕分辨率高</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">width</span>; <span class="comment">//屏幕分辨率宽</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">availHeight</span>; <span class="comment">//屏幕可用工作区高:屏幕分辨率高减掉顶部工具栏和底部工具栏的高度</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">availWidth</span>; <span class="comment">//屏幕可用工作区宽</span></span><br></pre></td></tr></table></figure>

<h4 id="获取浏览器窗口的宽高"><a href="#获取浏览器窗口的宽高" class="headerlink" title="获取浏览器窗口的宽高"></a>获取浏览器窗口的宽高</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w = <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line"><span class="keyword">var</span> h = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> || <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span>;</span><br></pre></td></tr></table></figure>



<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="是什么？-13"><a href="#是什么？-13" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		从一个数据集合中按照一定的顺序，不断取出数据的过程。迭代强调的是依次取数据，并不保证取多少，也不保证所有的数据都要取完。遍历则是把所有数据依次全部取出。</p>
<h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>​		如果一个对象具有next()，并且该方法能够返回一个对象{value: 值，done(是否迭代完成)}，则认为该对象是一个迭代器。</p>
<p>​		迭代器就是执行next()方法来获取一个result对象，result对象内部有属性value：本次运行获得的值，done：是否可继续迭代 （done的值由代码可知，当i的值大于或等于数组的的长度，说明已经遍历到最后一个数字了，那么done就为true）。然后i自增，等到下次运行的next方法返回的对象中value就为数组的第二个值，done会继续判断是否为false。</p>
<p>​		ES6中规定， 如果对象具有知名符号 <code>symbol.iterator</code>并且属性值是一个迭代器创建函数，则该对象是可以进行迭代的。</p>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><h4 id="是什么？-14"><a href="#是什么？-14" class="headerlink" title="是什么？"></a>是什么？</h4><p>​		ES6新增的一种函数控制、使用的方案，可以更加灵活的控制函数什么时候继续执行、暂停执行等。生成器实际上是一种特殊的迭代器。生成器函数是函数。</p>
<ul>
<li>生成器函数需要在function的后面添加符号*</li>
<li>生成器函数可以通过yield关键字控制函数的执行流程</li>
<li>生成器函数的返回值是一个Generator</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li><p>调用next获取返回对象{value: 100, done: false}</p>
</li>
<li><p>调用next函数的时候，可以传入参数，这个参数会作为上一个yield的返回值</p>
</li>
</ul>
<h3 id="for…in-x2F-for…of"><a href="#for…in-x2F-for…of" class="headerlink" title="for…in &#x2F; for…of"></a>for…in &#x2F; for…of</h3><ul>
<li>for…of不能遍历对象，for…in可以遍历对象</li>
<li>for…in遍历数组的时候会存在一些问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 索引为字符串型数字，不能直接进行几何计算</span><br><span class="line">- 遍历顺序可能不按照实际数组的内部顺序</span><br><span class="line">- 会遍历数组所有的可枚举属性，包括原型上的属性。如果不想被遍历，则需要使用hasOwnProperty()方法去判断某属性是否是该对象的实例属性</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> a)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="comment">// &#x27;a&#x27; &#x27;b&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> a)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    <span class="comment">// Uncaught TypeError: a is not iterable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">b.<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">b.<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> b)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="comment">// [&#x27;a&#x27;, 1]</span></span><br><span class="line">    <span class="comment">// [&#x27;b&#x27;, 2]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> b)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Object与Map"><a href="#Object与Map" class="headerlink" title="Object与Map"></a>Object与Map</h3><ul>
<li>对于object，它的键只能是字符串、数字或者symbol；对于map而言，它的键可以是任何类型。</li>
<li>map中的元素会保持其插入时的顺序，而object则不会完全保持插入时的顺序。</li>
<li>读取map的长度可以通过.size()方法；而读取object长度则需要通过：Object.keys(obj).length</li>
<li>Map是可迭代对象，可以通过for…of或者forEach方法来迭代；而object默认是不可迭代的，只能通过for…in循环来访问</li>
<li>创建和使用方式不同。object可以通过字面量、构造函数的方式创建；而map只能通过构造函数的方式创建。map新增&#x2F;读取&#x2F;删除元素时只能通过内置方法，object可以通过中括号或者点号。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://cheyennee.github.io">Cheyennee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://cheyennee.github.io/2021/03/12/JS/">http://cheyennee.github.io/2021/03/12/JS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cheyennee.github.io" target="_blank">Cheyennee</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/06/HTML/"><img class="prev-cover" src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/html/pic3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HTML</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/15/random/"><img class="next-cover" src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/random/cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">零碎知识点</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cheyennee</div><div class="author-info__description">生而为人，还请努力</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cheyennee"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">在路上</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">JS组成部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E4%BB%A3%E7%A0%81%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">JS代码引入方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEJS%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">访问JS对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES6%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">ES6新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">严格模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%85%AB%E7%A7%8D%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">数据类型（八种）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bigint%E5%92%8CNumber%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">Bigint和Number的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text">基础数据类型与引用数据类型的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E7%94%A8%E5%80%BC%E5%AD%98%E6%94%BE%E5%9C%A8%E5%A0%86%E4%B8%AD%EF%BC%8C%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%AD%98%E6%94%BE%E5%9C%A8%E6%A0%88%E4%B8%AD%E5%91%A2%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">为什么引用值存放在堆中，原始值存放在栈中呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof"><span class="toc-number">10.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof"><span class="toc-number">11.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4"><span class="toc-number">12.</span> <span class="toc-text">日期和时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arguments"><span class="toc-number">13.</span> <span class="toc-text">arguments</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">13.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E7%BB%91%E5%AE%9A%E8%A7%84%E5%88%99"><span class="toc-number">14.</span> <span class="toc-text">this绑定规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prototype"><span class="toc-number">15.</span> <span class="toc-text">prototype</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">16.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">17.</span> <span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WeakMap"><span class="toc-number">18.</span> <span class="toc-text">WeakMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#async-x2F-await"><span class="toc-number">19.</span> <span class="toc-text">async &#x2F; await</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined%E3%80%81undeclared%E3%80%81null"><span class="toc-number">20.</span> <span class="toc-text">undefined、undeclared、null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">21.</span> <span class="toc-text">作用域和作用域链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">22.</span> <span class="toc-text">执行上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%9A%84%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95"><span class="toc-number">23.</span> <span class="toc-text">String的原生方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">24.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">25.</span> <span class="toc-text">JS延迟加载的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">26.</span> <span class="toc-text">JS运行机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E9%98%9F%E5%88%97%E4%B8%8E%E5%BE%AE%E9%98%9F%E5%88%97"><span class="toc-number">27.</span> <span class="toc-text">宏队列与微队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#var-let-const%E5%8C%BA%E5%88%AB"><span class="toc-number">28.</span> <span class="toc-text">var \ let \ const区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88var%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E"><span class="toc-number">29.</span> <span class="toc-text">为什么var可以重复声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proxy"><span class="toc-number">30.</span> <span class="toc-text">Proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Generator"><span class="toc-number">31.</span> <span class="toc-text">Generator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F"><span class="toc-number">32.</span> <span class="toc-text">异步编程方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setTimeout-setInterval"><span class="toc-number">33.</span> <span class="toc-text">setTimeout \ setInterval</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">34.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">34.1.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call-apply"><span class="toc-number">35.</span> <span class="toc-text">call \ apply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81"><span class="toc-number">36.</span> <span class="toc-text">防抖与节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise"><span class="toc-number">37.</span> <span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E4%B8%8E-x3D-x3D-x3D"><span class="toc-number">38.</span> <span class="toc-text">&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol"><span class="toc-number">39.</span> <span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON-stringfy"><span class="toc-number">40.</span> <span class="toc-text">JSON.stringfy()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">41.</span> <span class="toc-text">数组方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-number">42.</span> <span class="toc-text">JS全局函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">类型转换机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.</span> <span class="toc-text">显示转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">隐式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-number">3.1.</span> <span class="toc-text">自动转换为布尔值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.2.</span> <span class="toc-text">自动转换为字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E5%80%BC"><span class="toc-number">3.3.</span> <span class="toc-text">自动转换成数值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-x3D-%E4%B8%8E-x3D-x3D-x3D-1"><span class="toc-number"></span> <span class="toc-text">&#x3D;&#x3D;与&#x3D;&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BA%8E%E6%93%8D%E4%BD%9C%E7%AC%A6-x3D-x3D"><span class="toc-number">1.</span> <span class="toc-text">等于操作符&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6-x3D-x3D-x3D"><span class="toc-number">2.</span> <span class="toc-text">全等操作符&#x3D;&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">3.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number"></span> <span class="toc-text">浅拷贝与深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">浅拷贝的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%A0%88"><span class="toc-number"></span> <span class="toc-text">执行上下文与执行栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87-1"><span class="toc-number">1.</span> <span class="toc-text">执行上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%A0%88"><span class="toc-number">2.</span> <span class="toc-text">执行栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ajax%E5%8E%9F%E7%90%86"><span class="toc-number"></span> <span class="toc-text">ajax原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-1"><span class="toc-number">1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-1"><span class="toc-number"></span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-2"><span class="toc-number">1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-number">2.</span> <span class="toc-text">规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">匹配方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number"></span> <span class="toc-text">事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-3"><span class="toc-number">1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%88JS%E5%BC%95%E6%93%8E%E5%8F%91%E8%B5%B7%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">微任务（JS引擎发起）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%E3%80%81node%E5%8F%91%E8%B5%B7%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">宏任务（浏览器、node发起）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BOM"><span class="toc-number"></span> <span class="toc-text">BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-4"><span class="toc-number">1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DOM%E4%B8%8EBOM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">DOM与BOM的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84BOM%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">常见的BOM对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#window"><span class="toc-number">3.1.</span> <span class="toc-text">window</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#location"><span class="toc-number">3.2.</span> <span class="toc-text">location</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#navigator"><span class="toc-number">3.3.</span> <span class="toc-text">navigator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#screen"><span class="toc-number">3.4.</span> <span class="toc-text">screen</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#history"><span class="toc-number">3.5.</span> <span class="toc-text">history</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BE%E9%80%92%E5%BD%92"><span class="toc-number"></span> <span class="toc-text">尾递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E4%B8%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number"></span> <span class="toc-text">JS中内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">JS垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4-%E6%B8%85%E9%99%A4%E5%AD%98%E5%9C%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E8%A2%AB%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8F%98%E9%87%8F%E6%89%80%E5%BC%95%E7%94%A8%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E6%A0%87%E8%AE%B0"><span class="toc-number">2.1.</span> <span class="toc-text">标记清除(清除存在上下文中的变量以及被上下文变量所引用的变量的标记)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">引用计数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%83%85%E5%86%B5"><span class="toc-number"></span> <span class="toc-text">常见的内存泄露情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%A4%96%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">意外的全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85-1"><span class="toc-number">3.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E5%8F%8A%E6%97%B6%E6%B8%85%E7%90%86DOM%E5%85%83%E7%B4%A0%E5%BC%95%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">没有及时清理DOM元素引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">JS本地存储方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie"><span class="toc-number">1.</span> <span class="toc-text">cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#cookie%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">cookie常用属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#localstorage"><span class="toc-number">1.2.</span> <span class="toc-text">localstorage</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sessionStorage"><span class="toc-number">1.3.</span> <span class="toc-text">sessionStorage</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#IndexedDB"><span class="toc-number">1.4.</span> <span class="toc-text">IndexedDB</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie%E3%80%81localStorage%E3%80%81sessionStorage%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">cookie、localStorage、sessionStorage的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-5"><span class="toc-number">1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98"><span class="toc-number"></span> <span class="toc-text">JS中实现函数缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-6"><span class="toc-number">1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1"><span class="toc-number"></span> <span class="toc-text">数字精度丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.</span> <span class="toc-text">产生原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">解决方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number"></span> <span class="toc-text">防抖与节流的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8F%AF%E8%A7%86%E5%8C%BA"><span class="toc-number"></span> <span class="toc-text">判断元素是否在可视区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-7"><span class="toc-number">1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#offsetTop%E3%80%81scrollTop"><span class="toc-number">2.1.</span> <span class="toc-text">offsetTop、scrollTop</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#getBoundingClientRect"><span class="toc-number">2.2.</span> <span class="toc-text">getBoundingClientRect</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Intersection-Observer"><span class="toc-number">2.3.</span> <span class="toc-text">Intersection Observer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="toc-number">2.4.</span> <span class="toc-text">案例：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%97%B6%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-number"></span> <span class="toc-text">大文件上传时断点续传</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-8"><span class="toc-number">1.</span> <span class="toc-text">是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0"><span class="toc-number">1.1.</span> <span class="toc-text">分片上传</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0"><span class="toc-number">1.2.</span> <span class="toc-text">断点续传</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">3.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0"><span class="toc-number"></span> <span class="toc-text">实现上拉加载，下拉刷新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.</span> <span class="toc-text">上拉加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0"><span class="toc-number">2.</span> <span class="toc-text">下拉刷新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-number"></span> <span class="toc-text">单点登录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-9"><span class="toc-number">1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E5%9F%9F%E5%90%8D%E4%B8%8B%EF%BC%9Acookie-domain"><span class="toc-number">2.1.</span> <span class="toc-text">同域名下：cookie domain</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%9F%9F%E5%90%8D%E4%B8%8B%EF%BC%9Atoken"><span class="toc-number">2.2.</span> <span class="toc-text">不同域名下：token</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%9F%9F%E5%90%8D%E4%B8%8B%EF%BC%9Alocalstorage"><span class="toc-number">2.3.</span> <span class="toc-text">不同域名下：localstorage</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS%E6%94%BE%E5%A4%B4%E9%83%A8%EF%BC%8CJS%E6%94%BE%E5%B0%BE%E9%83%A8"><span class="toc-number"></span> <span class="toc-text">CSS放头部，JS放尾部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web%E5%B8%B8%E8%A7%81%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E5%8F%8A%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">web常见的攻击方式及防御方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">常见的攻击方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XSS"><span class="toc-number">2.</span> <span class="toc-text">XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-10"><span class="toc-number">2.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">存储型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">反射型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DOM%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">DOM型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E9%98%B2"><span class="toc-number">2.6.</span> <span class="toc-text">预防</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSRF%EF%BC%88%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">CSRF（跨站请求伪造）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-11"><span class="toc-number">3.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">典型流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1"><span class="toc-number">3.4.</span> <span class="toc-text">防御</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5"><span class="toc-number">4.</span> <span class="toc-text">SQL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-12"><span class="toc-number">4.1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E6%B5%81%E7%A8%8B-1"><span class="toc-number">4.2.</span> <span class="toc-text">典型流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E9%98%B2-1"><span class="toc-number">4.3.</span> <span class="toc-text">预防</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%AE%BD%E9%AB%98"><span class="toc-number"></span> <span class="toc-text">获取元素宽高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%AE%BD%E9%AB%98%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number"></span> <span class="toc-text">与宽高相关的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">元素属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">浏览器属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%AE%BD%E9%AB%98"><span class="toc-number">3.</span> <span class="toc-text">获取浏览器窗口的宽高</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number"></span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-13"><span class="toc-number">1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AB%E4%B9%89"><span class="toc-number">2.</span> <span class="toc-text">含义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number"></span> <span class="toc-text">生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-14"><span class="toc-number">1.</span> <span class="toc-text">是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E2%80%A6in-x2F-for%E2%80%A6of"><span class="toc-number"></span> <span class="toc-text">for…in &#x2F; for…of</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E4%B8%8EMap"><span class="toc-number"></span> <span class="toc-text">Object与Map</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/24/leetcode/" title="leetcode"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/array/study.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="leetcode"/></a><div class="content"><a class="title" href="/2024/08/24/leetcode/" title="leetcode">leetcode</a><time datetime="2024-08-24T08:22:49.000Z" title="发表于 2024-08-24 16:22:49">2024-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/10/%E5%9F%8B%E7%82%B9/" title="埋点"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/interview/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="埋点"/></a><div class="content"><a class="title" href="/2023/09/10/%E5%9F%8B%E7%82%B9/" title="埋点">埋点</a><time datetime="2023-09-10T09:45:12.000Z" title="发表于 2023-09-10 17:45:12">2023-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/09/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="性能优化"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/flatlist/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="性能优化"/></a><div class="content"><a class="title" href="/2023/09/09/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="性能优化">性能优化</a><time datetime="2023-09-09T12:54:23.000Z" title="发表于 2023-09-09 20:54:23">2023-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="垃圾回收"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/js/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="垃圾回收"/></a><div class="content"><a class="title" href="/2023/09/09/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="垃圾回收">垃圾回收</a><time datetime="2023-09-09T06:01:32.000Z" title="发表于 2023-09-09 14:01:32">2023-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/08/HTTP-TCP/" title="HTTP-TCP"><img src="https://cheyennee-blog.oss-cn-hangzhou.aliyuncs.com/images/http/cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP-TCP"/></a><div class="content"><a class="title" href="/2023/09/08/HTTP-TCP/" title="HTTP-TCP">HTTP-TCP</a><time datetime="2023-09-08T01:35:27.000Z" title="发表于 2023-09-08 09:35:27">2023-09-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Cheyennee</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>